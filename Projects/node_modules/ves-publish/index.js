const debug = require('debug');
debug.enable('info:ves-publish*,error:ves-publish*,' + process.env.DEBUG);

var path = require('path');
var archiver = require('archiver');
var fs = require('fs-extra');
var request = require('request');
var _ = require('lodash');

/**
 * @param name project name
 * @return logger with debug & error funcs and 'ves-publish:index:<unique id>:<project name>' as the logger namespace
 */
function getLogger(name) {
  const id = Date.now();
  const namespace = 'ves-publish:' + id + ':' + name;
  const logger = {
    info: debug('info:'+namespace),
    debug: debug(namespace),
    error: debug('error:' + namespace),
    trace: debug('trace:'+namespace),
    id: id
  };
  // set error to log via console.error
  logger.error.log = console.error.bind(console);
  return logger;
}

/**
 * @return the total number of files inside the given dir
 * @private
 */
function getFileCount(dir) {
  const walkSync = function(dir, filelist) {
    filelist = filelist || [];
    fs.readdirSync(dir).forEach(function(file) {
      const filePath = path.join(dir, file);
      filelist = fs.statSync(filePath).isDirectory() ? walkSync(filePath, filelist) : filelist.concat(filePath);
    });
    return filelist;
  };
  return walkSync(dir).length;
}
exports._getFileCount = getFileCount;

/**
 * Zip up the dist dir and upload it to an experience server.
 * @param config - see the readme.md for config details and example usage
 * @returns {Promise} resolved when upload is complete, or rejected in case of failure
 */
exports.publishApp = function(config) {
  return new Promise(function(resolve, reject) {
    if (!config || !config.baseDir || !config.name || !config.server) {
      throw new Error('Invalid config. baseDir, name, and server are required config properties.');
    }
    const log = getLogger(config.name);
    if(!fs.existsSync(config.baseDir)) {
      throw new Error(config.baseDir + ' baseDir does not exist.');
    }
    config.fileName = path.basename(config.baseDir);

    if (!config.path) {
      config.path = 'dist/phone';
    }
    var distPhone = path.join(config.baseDir, config.path);
    if(!fs.existsSync(distPhone)) {
      throw new Error(distPhone + ' directory does not exist.');
    }

    var packagePath = path.join(config.baseDir, config.name + '.zip');
    var output = fs.createWriteStream(packagePath);
    var zipArchive = archiver('zip');

    /** log the zip size in bytes & MB */
    function logZipSize() {
      if(zipArchive) {
        const bytes = zipArchive.pointer();
        const mb = bytes ? '(approximately ' + Math.round(bytes / (1024 * 1024)) + ' MB)' : '';
        log.info('zip size', bytes + ' bytes', mb);
      }
    }

    /**
     * Logs given message and error, rejects promise with message.
     */
    function logErrorAndReject(message, err, rejectObj) {
      logZipSize();
      log.error(message, err);
      reject(rejectObj || message);
    }

    /**
     * Upload the zip to the experience server.
     * Called after zipArchive is finalized and output stream is closed.
     * @param user
     */
    function uploadPackageToThingServer(user) {
      log.info('Starting Upload');
      let bytes = 0;
      const size = zipArchive.pointer();
      // throttle the logging/client notification so it is less noisy
      const logProgress = _.throttle(function() {
        const percentage = Math.trunc(100*bytes/size);
        if (config.notifyClient) {
          config.notifyClient('publishProgress', {id: log.id, max: size, value: bytes, fileName: config.fileName});
        }
        log.debug(percentage ? percentage + '%' : '', bytes, 'bytes');
      }, 500, {leading: true});
      var zipReadStream = fs.createReadStream(packagePath)
          .on('error', function(err) {
            logErrorAndReject('Failed to read zip.', err);
          })
          .on('data', function(chunk) {
            bytes += chunk.length;
            logProgress();
          });
      var formData = {
        'webapp': zipReadStream
      };

      if(!user) {
        log.debug('username/password undefined');
      }
      var reqConfig = _.defaultsDeep({}, config.requestConfig, {
        url: config.server + '/VuforiaExperienceService/content/projects?replace=true',
        formData: formData,
        strictSSL: config.sslValidate,
        headers: {
          "x-requested-with": "^HXn4_uG3g@7u1Q-",
          "Content-Type": "application/json"
        },
        auth: {
          username: user ? user.name : '',
          password: user ? user.password : '',
          sendImmediately: true
        }
      });

      log.debug('Publish to: ' + reqConfig.url);
      logProgress(); // 0%
      request.post(reqConfig, function (err, resp, body) {
        if (!resp || (resp.statusCode !== 201 && resp.statusCode !== 200) || err) {
          zipReadStream.close();
          var code = (resp || {}).statusCode;
          log.error('Response code ' + code);
          log.error('Response body ' + body);
          logErrorAndReject('Failed to upload to the Experience Service.', err, (resp && resp.statusCode)? {statusCode: resp.statusCode, message: err}: undefined);
        }
        else {
          logProgress.flush(); // 100%
          log.info('Upload successful');
          resolve();
        }
      });
    }

    output.on('close', function () {
      logZipSize();
      log.debug('archiver has been finalized and the output file descriptor has closed.');
      uploadPackageToThingServer(config.developer);
    });

    output.on('error', function (e) {
      logErrorAndReject('Failed to output zip.', e);
    });

    zipArchive.on('error', function (e) {
      logErrorAndReject('Failed to zip artifacts.', e);
    });

    let count = 0;
    const total = getFileCount(distPhone);
    // throttle the logging/client notification so it is less noisy
    const logProgress = _.throttle(function() {
      log.debug('zip progress', count, 'of', total, 'files');
      if (config.notifyClient) {
        config.notifyClient('publishProgress', {id: log.id, zipProgress: 1, max: total, value: count, fileName: config.fileName});
      }
    }, 100, {leading: true});
    zipArchive.on('entry', function(entry) {
      log.trace('zipping ', entry.name, '(' + entry.stats.size + ' bytes)');
      if(entry.stats && entry.stats.size) {
        count++;
        logProgress();
      }
    });

    log.info('Zipping ', distPhone);
    zipArchive.pipe(output);
    zipArchive.directory(distPhone, '/');
    zipArchive.finalize();
  });
};

/** Sets project access as public or private */
exports.setAccessType = function(config, ispublic) {
  return new Promise(function(resolve, reject) {
    if (!config || !config.name || !config.server) {
      reject('Invalid config. name and server are required config properties.');
    }
    const log = getLogger(config.name);

    var reqConfig = _.defaultsDeep({}, config.requestConfig, {
      url: config.server + '/VuforiaExperienceService/content/projects/' + config.name + '/access',
      body: {
        "ispublic": ispublic
      },
      json: true,
      strictSSL: config.sslValidate,
      headers: {
        "x-requested-with": "^HXn4_uG3g@7u1Q-",
        "Content-Type": "application/json"
      },
      auth: {
        username: config.developer ? config.developer.name : '',
        password: config.developer ? config.developer.password : '',
        sendImmediately: true
      }
    });

    request.put(reqConfig, function (err, resp, body) {
      if (!resp || (resp.statusCode !== 204 && resp.statusCode !== 200) || err) {
        var code = (resp || {}).statusCode;
        log.error('Response code ' + code);
        log.error('Response body ' + body);
        log.error('Failed to set the project access type.', err);
        reject('Failed to set the project access type.');
      }
      else {
        log.info('Project Access Type set to ' + (ispublic ? 'public' : 'private') + '.');
        resolve();
      }
    });
  });
};
