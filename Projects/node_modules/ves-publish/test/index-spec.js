describe('index', function() {
    'use strict';
    const chai = require('chai').use(require('chai-as-promised'));
    chai.should();
    const request = require('request');
    const path = require('path');
    const fs = require('fs-extra');

    const VESPublish = require('../index.js');

    describe('getFileCount', function() {
        it('should count all files', function() {
            expect(VESPublish._getFileCount(path.join(__dirname, 'projectToPublish', 'dist'))).toBe(1);
            expect(VESPublish._getFileCount(path.join(__dirname))).toBeGreaterThan(1);
        });
    });

    describe('publishApp', function() {
        var config, expectedZip;
        beforeEach(function() {
            config = {
                baseDir: path.join(__dirname, 'projectToPublish'),
                name: 'projectToPublish',
                developer: {name: 'foo', password: 'foopwd'},
                server: 'https://someExperienceServer',
                sslValidate: true,
                requestConfig: { customProperty: 'baz' }
            };
            expectedZip = path.join(config.baseDir, config.name + '.zip');
        });
        afterEach(function () {
            // not working to delete the zip
            //fs.unlinkSync(expectedZip);
        });

        it('should publish app', function(done) {
            var actualRequestConfig = null;
            spyOn(request, 'post').andCallFake(function(cfg, func) {
                actualRequestConfig = cfg;
                func(null, {statusCode: 200});
            });

            VESPublish.publishApp(config).should.be.fulfilled.then(function() {
                expect(actualRequestConfig.url).toBe('https://someExperienceServer/VuforiaExperienceService/content/projects?replace=true');
                expect(actualRequestConfig.strictSSL).toBe(true);
                expect(actualRequestConfig.formData.webapp).toBeDefined();
                expect(actualRequestConfig.headers['x-requested-with']).toBe('^HXn4_uG3g@7u1Q-');
                expect(actualRequestConfig.headers['Content-Type']).toBe('application/json');
                expect(actualRequestConfig.auth.username).toBe('foo');
                expect(actualRequestConfig.auth.password).toBe('foopwd');
                expect(actualRequestConfig.auth.sendImmediately).toBe(true);
                expect(actualRequestConfig.customProperty).toBe('baz');
                expect(fs.existsSync(expectedZip)).toBe(true, expectedZip + ' should be created');
                done();
            });
        });

        it('should reject with response status', function(done) {
            var errorMsg = "Call Failure Specific Message";
            spyOn(request, 'post').andCallFake(function(cfg, func) {
                func(errorMsg, {statusCode: 500});
            });

            VESPublish.publishApp(config).should.be.rejected.then(function(err) {
                expect(err).toEqual({statusCode: 500, message: errorMsg});
                done();
            });
        });

        it('should reject on request err', function(done) {
            spyOn(request, 'post').andCallFake(function(cfg, func) {
                func(new Error('Test request error'), {}, 'html body');
            });

            VESPublish.publishApp(config).should.be.rejected.then(function(err) {
                expect(err).toBe('Failed to upload to the Experience Service.');
                done();
            });
        });

        it('should reject if response is undefined', function(done) {
            spyOn(request, 'post').andCallFake(function(cfg, func) {
                func(null, undefined, 'html body');
            });

            VESPublish.publishApp(config).should.be.rejected.then(function(err) {
                expect(err).toBe('Failed to upload to the Experience Service.');
                done();
            });
        });

        it('should reject if project does not exist', function(done) {
            spyOn(request, 'post');
            config.baseDir = path.join(__dirname, 'projectDoesNotExist');
            config.name = 'projectDoesNotExist';

            VESPublish.publishApp(config).should.be.rejected.then(function(err) {
                expect(err.message).toBe(config.baseDir + ' baseDir does not exist.');
                expect(request.post).not.toHaveBeenCalled();
                done();
            });
        });

        it('should reject undefined configs', function(done) {
            VESPublish.publishApp(undefined).should.be.rejected.then(function(err) {
                expect(err.message).toBe('Invalid config. baseDir, name, and server are required config properties.');
                done();
            });
        });

        it('should reject invalid configs', function(done) {
            VESPublish.publishApp({}).should.be.rejected.then(function(err) {
                expect(err.message).toBe('Invalid config. baseDir, name, and server are required config properties.');
                done();
            });
        });
    });

    describe('setAccessType', function() {
        var config;
        beforeEach(function() {
            config = {
                name: 'projectName',
                developer: {name: 'foo', password: 'foopwd'},
                server: 'https://someExperienceServer',
                sslValidate: true,
                requestConfig: { customProperty: 'baz' }
            };
        });
        it('should set public', function(done) {
            var actualRequestConfig = null;
            spyOn(request, 'put').andCallFake(function(cfg, func) {
                actualRequestConfig = cfg;
                func(null, {statusCode: 200});
            });

            VESPublish.setAccessType(config, true).should.be.fulfilled.then(function() {
                expect(actualRequestConfig.url).toBe('https://someExperienceServer/VuforiaExperienceService/content/projects/projectName/access');
                expect(actualRequestConfig.strictSSL).toBe(true);
                expect(actualRequestConfig.body.ispublic).toBe(true);
                expect(actualRequestConfig.headers['x-requested-with']).toBe('^HXn4_uG3g@7u1Q-');
                expect(actualRequestConfig.headers['Content-Type']).toBe('application/json');
                expect(actualRequestConfig.auth.username).toBe('foo');
                expect(actualRequestConfig.auth.password).toBe('foopwd');
                expect(actualRequestConfig.customProperty).toBe('baz');
                done();
            });
        });

        it('should set private', function(done) {
            var actualRequestConfig;
            spyOn(request, 'put').andCallFake(function(cfg, func) {
                actualRequestConfig = cfg;
                func(null, {statusCode: 200});
            });
            VESPublish.setAccessType(config, false).should.be.fulfilled.then(function() {
                expect(actualRequestConfig.body.ispublic).toBe(false);
                done();
            });
        });

        it('should reject with response status', function(done) {
            spyOn(request, 'put').andCallFake(function(cfg, func) {
                func(null, {statusCode: 404});
            });
            VESPublish.setAccessType(config, true).should.be.rejected.then(function(err) {
                expect(err).toBe('Failed to set the project access type.');
                done();
            });
        });

        it('should reject on request err', function(done) {
            spyOn(request, 'put').andCallFake(function(cfg, func) {
                func(new Error('Test request error'), {}, 'html body');
            });

            VESPublish.setAccessType(config, true).should.be.rejected.then(function(err) {
                expect(err).toBe('Failed to set the project access type.');
                done();
            });
        });

        it('should reject if response is undefined', function(done) {
            spyOn(request, 'put').andCallFake(function(cfg, func) {
                func(null, undefined, 'html body');
            });

            VESPublish.setAccessType(config, true).should.be.rejected.then(function(err) {
                expect(err).toBe('Failed to set the project access type.');
                done();
            });
        });
    });
});
