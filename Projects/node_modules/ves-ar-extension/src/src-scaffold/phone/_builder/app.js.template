(function(){

  window.twx = window.twx || {};

  var requires = <%= requires =%>
  var twxViewControllersModule = angular.module('twxViewControllers', requires);

  {% for v in views %}

  twxViewControllersModule.controller('<%= v.fileName =%>_TwxViewController', [
      '$scope', '$element', '$attrs', '$timeout', '$interval', '$http', '$ionicPopup', '$ionicPopover', '$stateParams', '$location', '$rootScope', 'tml3dRenderer', '$injector', '$sce',
      function ($scope, $element, $attrs, $timeout, $interval, $http, $ionicPopup, $ionicPopover, $stateParams, $location, $rootScope, renderer, $injector, $sce) {
    $scope.app = twx.appScope;
    $scope.device = twx.device;
    $scope.view = {
        mdl: {
            custom: {}
        },
        wdg: {},
        fn: {},
        evt: {},
        prm: {},
        view: {}
    };

    var myWidgets = '';
    var activeWidgetEvents = {};
    var customWidgetEventListeners = [];

    if( $attrs['twxView'] !== undefined && $attrs['twxView'].length > 0 ) {
        $scope.app.view = $scope.app.view || {};
        $scope.app.view[$attrs['twxView']] = $scope.view;
    }

    this.setProperty = function(widgetProperty,value) {
        $scope.view.wdg[$attrs.widgetId][widgetProperty] = value;

    };

    //this.setViewProperty = function(prop,value) {
    //    console.log('twxView embedded view being told to set prop "' + prop + '" to "' + value + '" for widgetId: "' + $attrs.widgetId + '" - was "' + $scope.view.wdg[$attrs.widgetId][prop] + '"');
    //    $scope.view.wdg[$attrs.widgetId][prop] = value;
    //    //$scope[widgetId][prop] = value;
    //};


    this.addWidget = function(widgetScope,widgetElem,widgetAttrs) {
        widgetScope.app = $scope.app;
        widgetScope.view = $scope.view;
        widgetScope.device = $scope.device;
        widgetScope.viewController = $scope;
        var widgetId = widgetAttrs['widgetId'] || widgetAttrs['model'];
        var x = $scope;
        $scope.view.wdg = $scope.view.wdg || {};
        $scope.view.wdg[widgetId] = widgetScope[widgetId];
        myWidgets += '|' + widgetId;
        widgetScope['_widgetId'] = widgetId;
        //console.log('twxView --- adding widget "' + widgetId + '" to view - total widgets: ' + myWidgets);
    };

    $scope.getWidgetScope = function(widgetId){
      return $scope.view.wdg[widgetId];
    };

    $scope.getWidgetProp = function (widgetId, prop) {
      var propVal;
      if ($scope.view.wdg[widgetId] && $scope.view.wdg[widgetId][prop]) {
        propVal = $scope.view.wdg[widgetId][prop];
      }
      return propVal;
    };

    $scope.setWidgetProp = function (widgetId, prop, val) {
      if ($scope.view.wdg[widgetId] && $scope.view.wdg[widgetId][prop]) {
        $scope.view.wdg[widgetId][prop] = val;
      }
    };

    $scope.addWidgetEventListener = function (widgetId, widgetEvent, callback) {
      customWidgetEventListeners.push({
        widgetId: widgetId,
        widgetEvent: widgetEvent,
        callback: callback
      });
      if (!activeWidgetEvents[widgetEvent]) {
        activeWidgetEvents[widgetEvent] = true;
        $scope.$on(widgetEvent, function (event, args) {
          _.each(customWidgetEventListeners, function (listenerInfo) {
            if (listenerInfo.widgetId == event.targetScope.widgetId && listenerInfo.widgetEvent == event.name) {
              listenerInfo.callback();
            }
          });
        });
      }
    };

    $scope.pulse = 1.0;
    $scope.loadingPromise = null;
    $scope.modelLoaded = $element.find('twx-dt-model').length === 0;
    $scope.hidePhantom = true;
    var modelCount = $element.find('twx-dt-model').length;
    var modelLoadedCount = 0;
    var targets = $element.find('twx-dt-target');

    $scope.$on('trackingacquired', function (evt, arg) {
      renderer.getTracked(function(trackedObjects) {
        $scope.startLoadingIndicatorIfNeeded(trackedObjects);
        $scope.applyPhantomIfNeeded(trackedObjects);
      });
    });

    $scope.$on('trackinglost', function (evt, arg) {
      renderer.getTracked(function(trackedObjects) {
        $scope.applyPhantomIfNeeded(trackedObjects);
      });
    });

    $scope.$on('modelLoaded', function (evt, arg) {
      modelLoadedCount++;
      $scope.modelLoaded = true;

      renderer.getTracked(function(trackedObjects) {
        $scope.applyPhantomIfNeeded(trackedObjects);
      });
    });

    // starts the 'spinner' animation around the thing code while the model is loading
    $scope.startLoadingIndicatorIfNeeded = function (trackedObjects) {
      if (!$scope.isCompatibleObjectsTracked(trackedObjects)) {
        return;
      }

      // Start animation if this is first successful call to startLoadingIndicatorIfNeeded.
      var spinnerInterval = 0.03;
      if ($scope.pulse === 1.0 && $scope.loadingPromise === null) {
        $scope.loadingPromise = $interval(function () {
          // stop the animation after it makes one complete loop around
          if($scope.pulse <= 0) {
            // stop the animation
            $interval.cancel($scope.loadingPromise);
            $scope.loadingPromise = null;
            $scope.pulse = 0;
          }
          $scope.pulse -= spinnerInterval;
        }, 100);
      }
    };

    /*
       Returns true if any of the tracked objects match a target within the experience,
       otherwise false is returned - indicating the tracked objects don't match any of the targets
       within the experience.
     */
    $scope.isCompatibleObjectsTracked = function(trackedObjects) {
      if (trackedObjects.length === 0) {
        return false;
      }
      for(var i=0, l=targets.length; i<l; i++) {
        var targetName = angular.element(targets[i]).attr('src').substr("vuforia-vumark:///vumark?id=".length);
        if (targetName === "" || trackedObjects.indexOf(targetName) >= 0) {
          return true;
        }
      }
      return false;
    }

    $scope.applyPhantomIfNeeded = function(trackedObjects) {
      // don't show the phantom while the "model loading" spinner is displayed
      var hidePhantom = (modelLoadedCount < modelCount);

      if(!hidePhantom) {
        // all the models have been loaded so now verify at least one of the tracked objects is valid
        // within the experience, if so hide the phantom, if not show the phantom
        hidePhantom = $scope.isCompatibleObjectsTracked(trackedObjects);
      }

      $scope.$apply(function () {
        $scope.hidePhantom = hidePhantom;
      });
    };

    (function($scope, $element, $attrs, $timeout){

      <%= v.script =%>

    }($scope, $element, $attrs, $timeout))

  }]);

  {% endfor %}

  var moduleDependencies = ['ionic', 'ngCordova', 'vuforia-angular', 'com.thingworx.services', 'com.thingworx.components.charts','twxRuntime'];
  <!-- Extension Angular Modules -->
  {% for module in extensions.angular_modules %}
  moduleDependencies.push('<%= module =%>');
  {% endfor %}
  var app = angular.module('app', moduleDependencies);
//  var app = angular.module('app', ['ionic', 'ngCordova', 'twxUI', 'com.thingworx.declarative', 'com.thingworx.components.charts']);
  {% if offlineSave %}
  app.config(function($sceProvider) {
    $sceProvider.enabled(false);
  });
  {% endif %}

    twx = twx || {};
    twx.appXXX = app;

  app.config(['DataConnectorConfigProvider', '$ionicConfigProvider', function(DataConnectorConfigProvider, $ionicConfigProvider) {
//    app.twxRoot = "http://mobilelab.thingworx.com/Thingworx";
    // this will be poulated with whatever server you are working with in the mobile-builder
    app.twxRoot = "<%= thingworxServer =%>/Thingworx";

    // Get this from application config later
    DataConnectorConfigProvider.addDataProvider({
        name: 'ThingworxConnector',
        urlRoot: app.twxRoot
    });    

    try {
        if (document !== undefined) {
            var isCordovaApp = document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1;
            if( !isCordovaApp ) {
              app.twxRoot = "/Thingworx";
              DataConnectorConfigProvider.addDataProvider({
                name: 'ThingworxConnector',
                urlRoot: app.twxRoot
              });
            }
        }
    } catch(err) {}
     $ionicConfigProvider.views.swipeBackEnabled(false);
  }]);

  app.controller('AppCtrl', function ($scope, $rootScope, $state, $stateParams, $ionicModal, $location, $http, $injector) {
      var appScope = this;
      twx.appScope = this;
      twx.app.params = angular.extend(twx.app.params, $stateParams, $location.search());
      $scope.app.params = angular.extend({}, twx.app.params);
      appScope.params = twx.app.params;
      appScope.fn = twx.app.fn;
      appScope.mdl = twx.app.mdl;
      appScope.evt = twx.app.evt;

      twx.device.mdl['CurrentDevice'] = {
            svc: {
              'getCameraPictureURL': {}
            }
          };

      appScope.camera = {};
      appScope.camera.lastPictureData = "";
      appScope.camera.getPictureData = function(){
        var options = {
          destinationType: Camera.DestinationType.DATA_URL,
          sourceType: Camera.PictureSourceType.CAMERA
        };
        var $cordovaCamera = $injector.get('$cordovaCamera');
        $cordovaCamera.getPicture(options).then(function (imageData) {
          appScope.camera.lastPictureData = imageData;
        }, function (err) {
          // error
        });
      };

      appScope.camera.getPictureURL = function(){
        var options = {
          destinationType: Camera.DestinationType.FILE_URI,
          sourceType: Camera.PictureSourceType.CAMERA
        };
        var $cordovaCamera = $injector.get('$cordovaCamera');
        $cordovaCamera.getPicture(options).then(function (imageURI) {
          appScope.camera.lastPictureURL = imageURI;
          twx.device.mdl['CurrentDevice'].svc['getCameraPictureURL'].data = imageURI;
        }, function (err) {
          // error
        });
      };

      $scope.$on('device.mdl.CurrentDevice.svc.getCameraPictureURL', function () {
            appScope.camera.getPictureURL();
        });

      $scope.$on('app-fn-navigate',function(e,data) {
        twx.app.fn.navigate(data['viewname']);
      });

      $scope.showModal = function(view){

        var modalContents = '';
        var modalUrl = 'app/components/' + view + '.html';
        $http.get(modalUrl).then(function(response) {
          modalContents = response.data;
          var modalTransformedContents = modalContents.replace('ion-view','ion-modal-view');
          $scope.modal = $ionicModal.fromTemplate(modalTransformedContents, {
            scope: $scope,
            animation: 'slide-in-up'
          });
          $scope.modal.show();
        });

      };

      $scope.hideModal = function(){
        $scope.modal.hide();
        $scope.modal.remove();
      };

      $scope.$on('app-fn-show-modal',function(e,data) {
        $scope.showModal(data['viewname']);
      });

      $scope.$on('app-fn-hide-modal',function(e,data) {
        $scope.hideModal();
      });

      appScope.acceleration = {};

      appScope.location = {};
      appScope.location.getCurrentLocation = function(){
        var posOptions = {timeout: 10000, enableHighAccuracy: false};
        var $cordovaGeolocation = $injector.get('$cordovaGeolocation');
        $cordovaGeolocation
          .getCurrentPosition(posOptions)
          .then(function (position) {
            var lat  = position.coords.latitude
            var long = position.coords.longitude
            appScope.location.lastLocation = { latitude: lat, longitude: long };
          }, function(err) {
            // error
          });
      };
      appScope.location.lastLocation = {
        latitude: 40.056545,
        longitude: -99.672037
      };

      if($rootScope.enableVoiceCommands) {
        // add the speech service to the app scope when there are voice alias'd app events
        appScope.speech = $injector.get('appSpeechService');
      }

      twx.device.camera = appScope.camera;
      twx.device.location = appScope.location;
      twx.device.acceleration = appScope.acceleration;
      appScope.listCanSwipe = true;
    });

  app.controller('AppsMenuCtrl', function ($scope, $timeout, $http, $ionicSideMenuDelegate,
  $location, $ionicHistory, $templateCache, $log, $window) {
      $scope.isCordovaApp = window.cordova === undefined ? false : true;
      if( !($scope.isCordovaApp) ) {
        $scope.hasBackView = function () {
           return ($ionicHistory.backView() != null);
        };
      }

      $scope.toggleLeftMenu = function () {
        $ionicSideMenuDelegate.toggleLeft();
      };

      $scope.navigateFromLeftMenu = function (path) {
        $location.path(path);
        $ionicSideMenuDelegate.toggleLeft();
      };

      $scope.$watch(function(){
          return $ionicSideMenuDelegate.getOpenRatio();
      }, function(newValue, oldValue) {
          $scope.hideLeftMenu = !$ionicSideMenuDelegate.isOpenLeft();
      });
    });

  app.controller('BaseCtrl',['$scope', '$parse', '$location', '$state', '$ionicPopup', '$timeout', 'vuforiaCleanup', function ($scope, $parse, $location, $state, $ionicPopup, $timeout, vuforiaCleanup) {
    $scope['twInvokeAction'] = function(name){
      if (this['twActions'] && this['twActions'][name]){
        var action = this['twActions'][name];
        var fn = $parse(action.do, /* interceptorFn */ null, /* expensiveChecks */ true);
        fn(action.scope);
      } else {
        console.log('Action "' + name + '" not found');
      }
    };

    $scope._fixMediaURL = function(originalURL){
      if (originalURL) {
          var newURL = originalURL;
          if (newURL.indexOf('/Thingworx') == 0) {
            newURL = newURL.replace('/Thingworx', app.twxRoot);
          }
          return newURL;
      } else {
          return '';
      }
    };

    $scope._setCurrentAndNavigate = function(items, item, target){
      items.Current = item;
      $scope.navigate(target);
    };

    $scope.$on('setFailed', function(event, data) {
        if (data && data.model) {
            // Figure out what to do
        }
    });

    $scope.showConfirmPopup = function (title, subtitle, confirmEventId, confirmView) {
      var confirmPopup = $ionicPopup.confirm({
        title: title,
        template: subtitle
      });
      confirmPopup.then(function (res) {
        if (res) {
          $scope.$emit(confirmEventId);
          if (confirmView !== '') {
            $scope.navigateOnTimeout(confirmView);
          }
        }
      });
    };

    $scope.navigateOnTimeout = function(target){
      $timeout(function () {
        $scope.navigate(target);
      }, 300);
    };

    $scope.$on('$stateChangeStart',function() {
       vuforiaCleanup.cleanUpAndPause();
    });

    $scope.navigate = function(target){
      {% if usesTabs %}

      var tabs = {};
      {% for v in views %}
      {% if v.showInMainMenu %}
      tabs['<%= v.fileName =%>'] = {};
      {% endif %}
      {% endfor %}

      if (tabs[target]) {
        target = 'tab.' + target;
      } else {
        target = 'tab.' + $state.current.data.targetPrefix + target;
      }

      {% endif %}
      $state.go(target);
    };
  }]);

  function onDeviceReady() {
      //if (device.platform === 'iOS' && parseFloat(device.version) >= 7.0) {
      //  document.body.style.marginTop = "20px";
      //}
    }

  document.addEventListener('deviceready', onDeviceReady, false);

}(window, document, angular));
