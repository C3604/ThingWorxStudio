/* begin copyright text
 *
 * Copyright Â© 2016 PTC Inc., Its Subsidiary Companies, and /or its Partners. All Rights Reserved.
 *
 * end copyright text
 */
(function () {
    var app = angular.module('twxRuntime', ['ionic', 'ngCordova', 'com.thingworx.declarative', 'ngCordova.plugins.network', 'twxViewControllers', 'com.thingworx.services']);

    var twx = window.twx || {};
    window.twx = twx;
    var styleCount = 0;
    var autoWidgetCount = 0;

    twx.device = twx.device || {
          fn: {},
          mdl: {
              CurrentDevice: {}
          },
          evt: {}
      };

    twx.app = twx.app || {
            fn: {},
            mdl: {
                custom: {}
            },
            evt: {},
            params: {}
        };

    twx.app.buildTagsFromTagDescriptionWithSemicolons = function (description) {
        var tags = [];

        var tagStrings = description.split(';');

        for (var i = 0; i < tagStrings.length; i++) {
            var tagString = tagStrings[i].trim();
            if (tagString.length > 0) {
                var tagPortions = tagString.split(':');
                tags.push({ vocabulary: tagPortions[0], vocabularyTerm: tagPortions[1] });
            }
        }
        return tags;
    };

    twx.app.convertStringPropertyToBasetype = function(stringValue,baseType) {
        var convertedValue = stringValue;
        if( baseType !== undefined ) {
            switch (baseType.toLowerCase()) {
                case 'boolean':
                    if (stringValue === undefined || stringValue.length === 0) {
                        convertedValue = undefined;
                    } else {
                        stringValue = stringValue.toLowerCase();
                        switch (stringValue) {
                            case '1':
                            case 'true':
                                convertedValue = true;
                                break;
                            default:
                                convertedValue = false;
                        }
                    }
                    break;

                case 'number':
                case 'integer':
                case 'long':
                    if (stringValue === undefined || stringValue.length === 0) {
                        convertedValue = undefined;
                    } else {
                        try {
                            if (baseType === 'number') {
                                convertedValue = parseFloat(stringValue);
                            } else {
                                convertedValue = parseInt(stringValue);
                            }
                        } catch (err) {
                            console.log('runtime conversion exception converting "' + stringValue + '" from STRING to ' + baseType, err);
                        }
                    }
                    break;

                case 'datetime':
                    if (stringValue === undefined || stringValue.length === 0) {
                        convertedValue = undefined;
                    } else {
                        try {
                            convertedValue = new Date(stringValue);
                        } catch (err) {
                            console.log('runtime conversion exception converting "' + stringValue + '" from STRING to DATETIME', err);
                        }
                    }
                    break;

                case 'tags':
                    if (stringValue === undefined || stringValue.length === 0) {
                        convertedValue = undefined;
                    } else {
                        try {
                            convertedValue = twx.app.buildTagsFromTagDescriptionWithSemicolons(stringValue);
                        } catch (err) {
                            console.log('runtime conversion exception converting "' + stringValue + '" from STRING to TAGS', err);
                        }
                    }
                    break;

                case 'infotable':
                    if (stringValue === undefined || stringValue.length === 0) {
                        convertedValue = undefined;
                    } else {
                        try {
                            convertedValue = JSON.parse(stringValue);
                        } catch (err) {
                            console.log('runtime conversion exception converting "' + stringValue + '" from STRING to TAGS', err);
                        }
                    }
                    break;
            }
        }
        return convertedValue;
    };

    app.directive('twxViewProxy', function () {
        return {
            require: '^twxWidget',
            restrict: 'E',
            link: function ($scope, elem, attrs) {
            },
            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
                var propertiesToProxyList = $attrs.proxyProperties;
                var propertiesToProxyArray = [];

                var currentPropertyValues = {};
                var containedViewControllerEl;
                var containedViewController;
                if( propertiesToProxyList )  {
                    propertiesToProxyArray = propertiesToProxyList.split(',');

                    var updateContainedViewProperty = function(prop,value) {
                        if( containedViewController ) {
                            containedViewController.setViewProperty(prop,value);
                        } else {
                            currentPropertyValues[prop] = value;
                        }
                    };

                    angular.forEach(propertiesToProxyArray, function(propToProxy)  {
                        $scope.$watch('me.' + propToProxy,function(newValue,oldValue) {
                            updateContainedViewProperty(propToProxy,newValue);
                        });
                    });
                }

                this.yourContentIsLoaded = function() {
                    containedViewControllerEl = angular.element($element.find('twx-widget')[0]);
                    //containedViewController = containedViewControllerEl.controller('twxView');
                    containedViewController = containedViewControllerEl.controller('twxWidget');

                    angular.forEach(currentPropertyValues,function(value,key) {
                        updateContainedViewProperty(key,value);
                    });
                };
            }]
        };
    });

    app.directive('twxView', function ($log) {
        return {
            restrict: 'A',
            link: function ($scope, elem, attrs) {
              if($scope.app.speech) {
                var viewName = attrs.twxView;
                var grammarUrl = 'app/components/' + viewName + '-grammar.xml';
                $log.debug('initializing speech service', grammarUrl);
                $scope.app.speech.initViewGrammar(grammarUrl);
              }
            },
            controllerAs: 'twxViewCtrl',
            controller: '@',
            name: 'ctrlName'
        };
    });

    app.directive('twxDatabind', function () {
        return {
            require: ['?^twxWidget','?^twxModel','?^twxUserModel', '?^twxAppParam'],
            link: function ($scope, elem, attrs, controllers) {
                var controller = controllers[0] || controllers[1] || controllers[2] || controllers[3];
                controller.addDataBinding(attrs.fromExpression, attrs.toProperty, elem);
            },
            controller: ['$scope', function ($scope) {
            }]
        };
    });

    app.directive('twxUserModel', function(){
        return {
            restrict: 'E',
            link: function ($scope, elem, attrs, viewCtrl) {
            },
            controller: function ($scope, $element, $attrs, $rootScope, filterService) {
                var modelName = '';

                this.init = function (element) {
                    modelName = element.attr('name');
                };

                this.addDataBinding = function(fromExpression, toProperty, element){
                    if (fromExpression && toProperty) {
                        $scope.$watch(fromExpression, function (newValue, oldValue) {
                            //console.log('Binding update fromExpression:"' + fromExpression + '", result is ' + newValue + ', was ' + oldValue);
                            twx.app.mdl.custom[modelName] = filterService.filterValue(newValue, element);
                        });
                    }
                };

                this.init($element);
            }
        };
    });

    app.directive('twxWidget', function(){
        return {
            require: '?^twxView',
            restrict: 'E',
            scope: true,
            link: function ($scope, elem, attrs, viewCtrl) {
                var twxViewCtrl;
                var viewScope = $scope;
                while (twxViewCtrl === undefined) {
                    viewScope = viewScope.$parent;
                    twxViewCtrl = viewScope['twxViewCtrl'];
                }
                twxViewCtrl.addWidget($scope, elem, attrs);
                var thisCtrl = elem.controller('twxWidget');
                thisCtrl.templateScope.view = $scope.view;
                thisCtrl.templateScope.device = $scope.device;
                thisCtrl.templateScope.vc = $scope.viewController;
            },
            controller: function ($scope, $element, $attrs, $rootScope, $timeout, $filter, DataConnector, filterService) {
                var widgetId,
                  props,
                  delegate = {};

                this.defaultValues = {};

                this.init = function (element) {
                    widgetId = $attrs.widgetId;
                    if (!widgetId) {
                        widgetId = 'auto-' + Date.now() + autoWidgetCount++;
                        $element.attr('widget-id', widgetId);
                        $attrs.widgetId = widgetId;
                    }
                    props = {};
                    $scope[widgetId] = props;
                    if ($attrs.twxAutoAssignItem !== undefined) {
                        $scope[widgetId].item = $scope.item;
                    }
                };

                this.addContent = function (templateScope) {
                    this.templateScope = templateScope;
                    templateScope['me'] = props;
                    templateScope['delegate'] = delegate;
                    templateScope.widgetId = $attrs.widgetId;
                };

                this.addProperty = function (name, value, isBound, valueExpression, elem, datatype) {
                    if (name) {
                        if (datatype === 'json') {
                            $scope[widgetId][name] = JSON.parse(value);
                            if (isBound === undefined) {
                                this.defaultValues[name] = JSON.parse(value);
                            }
                            if (valueExpression) {
                                $scope.$watch(valueExpression, function (newValue, oldValue) {
                                    $scope[widgetId][name] = newValue;
                                });
                            }
                        } else {
                            $scope[widgetId][name] = value;
                            if (isBound === undefined) {
                                this.defaultValues[name] = value;
                            }
                            if (valueExpression) {
                                $scope.$watch(valueExpression, function (newValue, oldValue) {
                                    $scope[widgetId][name] = newValue;
                                });

                            }
                            if (name === 'stateFormatValue' && value) {
                                if ($element[0].querySelector('twx-widget-property[name="enableStateFormatting"][value="true"]')) {
                                    //console.log("stateformat", name, value, valueExpression);
                                    $scope.$watch(function() {
                                        return $scope[widgetId].stateFormatValue;
                                    }, function(newValue, oldValue) {
                                        if ($scope[widgetId]._stateFormatUnregister) {
                                            $scope[widgetId]._stateFormatUnregister();
                                        }
                                        $scope[widgetId]._stateFormatUnregister = $scope.$watch(function() {
                                            return _.get($scope[widgetId], newValue);
                                        }, function(val) {
                                            twx.app.fn.applyStateFormat($element, val, $scope[widgetId].stateFormat, DataConnector);
                                        });
                                    });
                                }
                            }
                        }
                    }
                };

                /**
                 * Add listeners for the given service
                 * @param name the name of a service (e.g. 'play', 'rewind')
                 * @param elem a jqLite wrapped element that may or may not currently be in the DOM
                 */
                this.addService = function(name, elem){
                    if (!name) {
                        console.log('Widget service name is undefined!');
                        return;
                    }

                    var serviceHandler = function (evt, data) {
                      if (delegate[name]) {
                        delegate[name]();
                      }
                      else {
                        var svcHandler = $element[0].querySelector('[twx-service-handler]');
                        if (svcHandler && typeof svcHandler[name] === 'function') {
                          svcHandler[name](data);
                        }
                        //Notify child (widget) scope to invoke its service
                        $scope.$broadcast('serviceInvoke', {serviceName: name, params: data});
                      }
                    };

                    // find the viewName to construct an event name (as of 1.10)
                    var viewName = '', e = elem;
                    while(e && !viewName) {
                        viewName = e.attr('twx-view');
                        e = e.parent();
                    }
                    if(viewName) {
                        $scope.$on('app.view["' + viewName + '"].wdg["' + widgetId + '"].svc.' + name, serviceHandler);
                    } else {
                        console.error('Unable to determine view name. Service handler not added.', name, widgetId);
                    }
                    //backwards compatible (pre 1.10 event name should not be needed?)
                    $scope.$on('app.view["' + widgetId + '"].svc.' + name, serviceHandler);
                };

                this.setViewProperty = function(prop,value) {
                    $scope.view.wdg[widgetId][prop] = value;
                };

                this.addDataBinding = function(fromExpression, toProperty, element) {
                    var isStateFormat = element.attr('binding-type') === 'stateFormat';
                    if (fromExpression && (toProperty || isStateFormat)) {
                        var first = true;
                        $scope.$watch(fromExpression, function(newValue, oldValue) {
                            //console.log('Binding update fromExpression:"' + fromExpression + '", result is ' + newValue + ', was ' + oldValue);
                            var finalValue = filterService.filterValue(newValue, element);
                            if (toProperty && toProperty.indexOf('app.params') !== 0) {
                                if (!first || newValue !== undefined) {  //On startup, don't set undefined over a preset
                                    if (finalValue !== undefined && finalValue.primitiveValue && typeof $scope[widgetId][toProperty] !== 'object') {
                                        //Convert complex object to a primitive value
                                        finalValue = finalValue.primitiveValue();
                                    }
                                    $scope[widgetId][toProperty] = finalValue;
                                }
                            }
                            else {
                                if (finalValue !== undefined && finalValue !== '' && finalValue !== oldValue) {
                                    $scope.$eval(toProperty + '= "' + finalValue + '"');
                                }
                            }
                            first = false;
                        });
                    }
                };

                function addEventData(eventBindingElem, data) {
                    _.each(eventBindingElem.find('twx-event-data'),function(dataEl) {
                        dataEl = angular.element(dataEl);
                        data[dataEl.attr('name')] = twx.app.convertStringPropertyToBasetype(dataEl.attr('value'),dataEl.attr('base-type'));
                    });
                }

                this.addEventBinding = function(attrs, eventBindingElem) {
                    var eventName = attrs.srcEvent;
                    var handler = attrs.handler;
                    var data = {};

                    var eventSourceType = attrs.srcType;
                    if(eventSourceType && eventSourceType === 'event') {
                        // it's a TWX entity event or an App event

                        eventBindingElem.on('twxEventEmitted', function (event) {
                            data = event.detail;
                            addEventData(eventBindingElem, data);


                            $rootScope.$broadcast(handler, data);
                        });
                    } else {
                        // otherwise, it must be a widget or service event, add a listener to the element
                        $scope.$on(eventName,function(e) {
                            //handler = 'app.mdl.DeliveryHelper.GetOutstandingDeliveries';
                            addEventData(eventBindingElem, data);
                            $rootScope.$broadcast(handler, data);
                        });
                    }
                };

                $scope.fireEvent = function(name, data) {
                    $scope.$emit(name, data);
                };

                this.init($element);
            }
        };
    });

    /**
     * Apply filters to new value when bound data changes.
     */
    app.service('filterService', function($filter) {
        var filtersCache = [];
        /**
         * Gets filters for the given element and store them in a cache for later use
         * @param element a databind element
         */
        function getFilters(element) {
            var id = element.attr('databind-id');
            var filters = filtersCache[id];
            if(!filters) {
                filters = [];
                var filterEls = element.children('twx-data-filter');
                angular.forEach(filterEls, function (el) {
                    filters.push(new Function('value', '$filter', el.attributes['filter-body'].value)); // jshint ignore:line
                });
                filtersCache[id] = filters;
            }
            return filters;
        }
        return {
            /**
             * @param newValue
             * @param element a twx-databind element
             * @returns resulting value after sending given newValue through all filters on given data binding,
             *          or newValue itself if there are no filters
             */
            filterValue: function(newValue, element) {
                var filteredValue = newValue;
                var filters = getFilters(element);
                filters.forEach(function(filter) {
                    filteredValue = filter.call({}, filteredValue, $filter);
                });
                return filteredValue;
            }
       };
    });

    app.directive('twxRepeaterContent', function () {
        return {
            require: '^twxWidget',

            link: function ($scope, elem, attrs, widgetCtrl) {
                //console.log('twxRepeaterContent - in link');
            },
            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
                this.item = $scope['item'];
            }]
        };
    });

    app.directive('twxEventbind', function () {
        return {
            require: ['?^twxWidget','?^twxModel'],

            link: function ($scope, elem, attrs, controllers) {
                var controller = controllers[0] || controllers[1];
                controller.addEventBinding(attrs, elem);
            },
            controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
                //no-op
            }]
        };
    });

    /**
     * Applies the state format CSS classes to the element that this directive is applied to.
     */
    app.directive('twxStateFormat', function () {
        return {
            restrict: "A",
            controllerAs: 'ctrl',
            bindToController: true,
            link: function ($scope, elem, attrs) {
            },
            controller: function ($scope, $element, $attrs, DataConnector) {
                var ctrl = this;

                $attrs.$observe("stateFormatValue", function(newValue, oldValue) {
                    if(newValue && $attrs.twxStateFormat) {
                        if (ctrl._stateFormatUnregister) {
                            ctrl._stateFormatUnregister();
                        }
                        ctrl._stateFormatUnregister = $scope.$watch(newValue, function(val) {
                            twx.app.fn.applyStateFormat($element, val, $attrs.twxStateFormat, DataConnector);
                        });
                    }
                });
            }
        };
    });

    if (window.Element && !Element.prototype.closest) {
        Element.prototype.closest =
          function(s) {
              var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                i,
                el = this;
              do {
                  i = matches.length;
                  while (--i >= 0 && matches.item(i) !== el) {}
              } while ((i < 0) && (el = el.parentElement));
              return el;
          };
    }

    app.directive('twxWidgetContent', function () {
        return {
            require: '^twxWidget',
            scope: true,
            link: function ($scope, elem, attrs, widgetCtrl) {

                $scope.childViewProxyLoadedContent = function() {
                    var viewProxyEl = elem.children()[0];
                    var viewProxyController = angular.element(viewProxyEl).controller('twxViewProxy');
                    viewProxyController.yourContentIsLoaded();
                };

                var closestRepeaterElem = elem[0].closest('twx-repeater-content');
                if( closestRepeaterElem ) {
                   closestRepeaterElem = angular.element(closestRepeaterElem);
                   var repeaterCtrl = closestRepeaterElem.controller('twxRepeaterContent');
                   if( repeaterCtrl !== undefined ) {
                       var item = repeaterCtrl.item;
                       $scope['item'] = item;
                   }
                }

                widgetCtrl.addContent($scope);

                if( attrs['twxInline'] !== undefined ) {
                    //elem[0].childNodes[0].style(attrs['style']);
                    elem[0].childNodes[0].style.display = 'inline-block';
                    elem[0].childNodes[0].style.float = 'left';
                }

                if( attrs['twxFloat'] !== undefined ) {
                    elem[0].childNodes[0].style.float = attrs['twxFloat'];
                }
                if( attrs['twxDisplay'] !== undefined ) {
                    elem[0].childNodes[0].style.display = attrs['twxDisplay'];
                }
                if( attrs['twxMinHeight'] !== undefined ) {
                    elem[0].childNodes[0].style.minHeight = attrs['twxMinHeight'];
                }
                if( attrs['twxMaxHeight'] !== undefined ) {
                    elem[0].childNodes[0].style.maxHeight = attrs['twxMaxHeight'];
                }
                if( attrs['twxMinWidth'] !== undefined ) {
                    elem[0].childNodes[0].style.minWidth = attrs['twxMinWidth'];
                }
                if( attrs['twxBorderStyle'] !== undefined ) {
                    elem[0].childNodes[0].style.borderStyle = attrs['twxBorderStyle'];
                }
                if( attrs['twxBorderWidth'] !== undefined ) {
                    elem[0].childNodes[0].style.borderWidth = attrs['twxBorderWidth'];
                }
                if( attrs['twxMarginRight'] !== undefined ) {
                    elem[0].childNodes[0].style.marginRight = attrs['twxMarginRight'];
                }
                if( attrs['twxMarginBottom'] !== undefined ) {
                    elem[0].childNodes[0].style.marginBottom = attrs['twxMarginBottom'];
                }
                //if( attrs['twxClickMutliSelect'] !== undefined ) {
                //    //angular.element(elem).attributes['ng-click'] = 'app.fn.test()';
                //    elem[0].attributes['ng-click'] = 'app.fn.test();';
                //    elem[0].attributes['phil'] = 'hello';
                //}
                $scope.app = twx.app;
                $scope.device = twx.device;
            },
            template: function (elem,attrs) {
                // var click = '';
                // if( attrs['twxClickMutliSelect'] !== undefined ) {
                //     click = ' ng-click="app.fn.test(' + attrs['twxClickMutliSelect'] + ');" ';
                // }
                // return '<div ' + click + '>' + elem.html() + '</div>';
                return elem.html();
            }
        };
    });

    app.directive('twxWidgetProperty', function () {
        return {
            require: '^twxWidget',
            compile: function compile(tElem, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, elem, attrs, widgetCtrl) {
                        var value = attrs.value;
                        if (attrs.datatype === 'boolean' && typeof value === 'string') {
                            value = (value === 'true');
                        }
                        else if (attrs.datatype === 'integer' && typeof value === 'string') {
                            value = parseInt(value, 10);
                        }
                        else if (attrs.datatype === 'number' && typeof value === 'string') {
                            value = parseFloat(value);
                        }
                        widgetCtrl.addProperty(attrs.name, value, attrs.twxBound, attrs.valueExpression, elem, attrs.datatype);
                    },
                    post: function postLink(scope, iElement, iAttrs, controller) {
                    }
                };
            },


            controller: ['$scope', '$attrs', function ($scope,$attrs) {
            }]
        };
    });

    app.directive('twxWidgetService', function () {
        return {
            require: '^twxWidget',
            link: function ($scope, elem, attrs, widgetCtrl) {
                widgetCtrl.addService(attrs.name, elem);
            },
            controller: ['$scope', '$attrs', function ($scope, $attrs) {
            }]
        };
    });

    app.directive('twxWidgetEvent', function () {
        return {
            require: '^twxWidget',
            link: function ($scope, elem, attrs, widgetCtrl) {
                var createEventHandler = function($scope, expression){
                    return function(event, data){
                        $scope.event = event;
                        $scope.$eval(expression, {data: data});
                        delete $scope.event;
                    };
                };
                // Bind to the twx-widget's scope so that fireEvent emitting from a child of twx-widget.
                $scope.$on(attrs.name, createEventHandler($scope, attrs.value));
            },
            controller: ['$scope', '$attrs', function ($scope, $attrs) {
            }]
        };
    });

    var STYLE_CACHE = {};
    var STATE_DEF_CACHE= {};

  /**
   * Adds a style block to the head
   * @param id
   * @param css  content of the new block
   */
    function addStyleToHead(id, css, element) {
        var head = document.head || document.getElementsByTagName('head')[0],
          style = document.createElement('style');

        style.type = 'text/css';
        style.id = id;
        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        } else {
            style.appendChild(document.createTextNode(css));
        }

        head.appendChild(style);
    }

    /**
     *
     * @param classname - css class name to create
     * @param styleDef - Object with all defined style options from twx
     * @returns {string} - CSS block of variable to define
     */
    function createCSSFromStyleDefinition(classname, styleDef, element) {
        var css = '.' + classname + ' {\n';

        if(!styleDef.lineColor) {
            var lineProperties = ['lineStyle', 'lineColor', 'lineThickness'];
            _.each(lineProperties, function (prop) {
                _.unset(styleDef, prop);
            });
        }

        Object.keys(styleDef).forEach(function(key) {
            var val = styleDef[key];
            if(key === 'image' && val){
                element.addClass('hasImage');
            }
            if(key === 'secondaryBackgroundColor' && !val) {
                val = styleDef.backgroundColor;
            }
            if (val !== undefined && val !== '' && !key.startsWith('_')) {
                if (key === 'fontEmphasisBold') {
                    val = val ? 'bold' : 'normal';
                } else if (key === 'fontEmphasisUnderline') {
                    val = val ? 'underline' : 'none';
                } else if (key === 'fontEmphasisItalic') {
                    val = val ? 'italic' : 'normal';
                } else if (key === 'lineThickness') {
                    val = val + 'px';
                } else if (key === 'image') {
                    val = 'url(' + location.origin + '/Thingworx/MediaEntities/' + encodeURI(val) + ')';
                } else if (key === 'textSize') {
                    switch(val) {
                        case 'xsmall':
                            val = '9px';
                            break;
                        case 'small':
                            val = '10px';
                            break;
                        case 'normal':
                            val = '11px';
                            break;
                        case 'large':
                            val = '12px';
                            break;
                        case 'xl':
                            val = '14px';
                            break;
                        case 'xxl':
                            val = '16px';
                            break;
                        case '2xl':
                            val = '18px';
                            break;
                        default:
                            val = val;
                    }
                }
                css += '  --' + key + ': ' + val + ';\n';
            }
        });
        css += '}';
        return css;
    }

    /**
     *
     * @param styleDef - Object with all defined style options from twx
     * @param element - dom el to add the class
     */
    function _addImageClass(styleDef, element) {
        Object.keys(styleDef).forEach(function(key) {
            var val = styleDef[key];
            if(key === 'image' && val){
                element.addClass('hasImage');
            }
        });
    }

    /**
     * Removes bad chars from the passed String,
     *   removes leading numbers, replace other chars with -
     */
    function cleanClassName(name) {
        if (name) {
            //remove bad chars, remove leading numbers
            return name.replace(/[^A-Za-z0-9_-]/g, '-').replace(/^[\d]*/, '');
        }
    }

    function _addStateStyles(name, styles, resolve, reject, element) {
        var classname = cleanClassName(name);
        var css = createCSSFromStyleDefinition(classname, styles, element);

        if (!document.querySelector('style#' + classname)) {
            twx.app.fn.addStyleToHead(classname, css, element);
        }
        resolve(styles);
    }

    /**
     * Will download the style defined by the state and create a new style tag in the head if necessary
     * @param element - DOM el of the binding
     * @param stateDef - Object that has the twx meta data about the state definition to apply
     * @param $http
     */
    function createStateStyles(element, stateDef, DataConnector) {
        var existingClass;
        var name = stateDef.defaultStyleDefinition;

        if (typeof name === 'object') {
            var styleDef = name;
            name = name.displayString;
            if (!name) {
                if (!styleDef._customCSSName) {
                    styleDef._customCSSName = 'custom-styles-' + Date.now() + '-' + styleCount++;
                }
                name = styleDef._customCSSName;
            }
            if (!STYLE_CACHE[name]) {
                STYLE_CACHE[name] = new Promise(function(resolve, reject) {
                    _addStateStyles(name, styleDef, resolve, reject, element);
                });
            } else  {
                _addImageClass(styleDef, element);
                element[0].dispatchEvent(new CustomEvent('styleReady'));
            }
        }
        else if (!name) {
            //No new style found, remove old styles
            existingClass = element.data('stateFormatClass');
            if (existingClass) {
                element.removeClass(existingClass);
            }
            return;
        }
        else if (typeof name === 'string') {
            if (!STYLE_CACHE[name]) {
                STYLE_CACHE[name] = new Promise(function(resolve, reject) {
                    DataConnector.executeService('ThingworxConnector', {
                          entityType: 'StyleDefinitions',
                          entity: name,
                          method: 'GET',
                          requestType: 'json'
                      })
                      .then(function successCallback(data) {
                          _addStateStyles(name, data.content, resolve, reject, element);
                          element[0].dispatchEvent(new CustomEvent('styleReady'));
                      }, function errorCallback(response) {
                          reject();
                          console.error("could not get the styles", response);
                      });
                });
            }
            else {
                STYLE_CACHE[name].then(function(styles) {
                    _addImageClass(styles, element);
                    element[0].dispatchEvent(new CustomEvent('styleReady'));
                });
            }
        }
        // ADD class name immediately
        var classname = cleanClassName(name);
        var stateDefName = '';
        if (stateDef.name) {
            stateDefName = cleanClassName(stateDef.name);
        }
        existingClass = element.data('stateFormatClass');
        if (existingClass) {
            element.removeClass(existingClass);
            element.removeClass('hasImage');
        }
        var newClasses = 'has-statedef-styles ' + classname + ' ' + stateDefName;
        element.addClass(newClasses);
        element.data('stateFormatClass', newClasses);
        element[0].dispatchEvent(new CustomEvent('styleReady'));

        return STYLE_CACHE[name];
    }

    /**
     * Downloads the state definition from twx
     * @param name - Name of the stateDefinition in twx
     * @param $http
     * @returns {*}
     */
    function getStateDefinition(name, DataConnector) {
        if (!STATE_DEF_CACHE[name]) {
            STATE_DEF_CACHE[name] = new Promise(function(resolve, reject) {
                DataConnector.executeService('ThingworxConnector', {
                    entityType: 'StateDefinitions',
                    entity: name,
                    method: 'GET',
                    requestType: 'json'
                })
                .then(function successCallback(data) {
                    resolve(data);
                    //console.log('statedefs', response.data);
                }, function errorCallback(response) {
                    console.error("Could not download the state definitions for ", name, response);
                    reject();
                });
            });
        }
        return STATE_DEF_CACHE[name];
    }

  /**
   * Returns the selected stateDefinition entity is selected based on the value and rules
   * @param stateDefEntity - Object from thingworx with all the state definitions and metadata
   * @param value - String or Number that will be used to evaluate against the rules
   * @returns {*}
   */
    function getSelectedStateStyle(stateDefEntity, value) {
        if (stateDefEntity && stateDefEntity.content && !(value === undefined || value === null)) {
            var stateDefs = stateDefEntity.content.stateDefinitions;
            var i, val, l = stateDefs.length;
            if (stateDefEntity.content.stateType === 'string') {
                // value could be boolean, number, object, etc. - convert the value so we can compare to the state value
                val = (typeof value !== 'string') ? value.toString() : value;
                for (i = 0; i < l; i++) {
                    if (stateDefs[i].defaultValue === val || i === (l - 1)) {  //Last one is default setting
                        return stateDefs[i];
                    }
                }
            }
            if (stateDefEntity.content.stateType === 'numeric') {
                val = (typeof value !== 'number') ? Number(value) : value;
                var startingIndex = isNaN(val) ? (l-1) : 0;  // if the value is not a number, return the last one (the default)
                for (i = startingIndex; i < l; i++) {
                    if (i === (l - 1) ||
                      val < stateDefs[i].defaultValue ||
                      (val === stateDefs[i].defaultValue && stateDefs[i].comparator === '<=')) {  //Last one is default setting
                        return stateDefs[i];
                    }
                }
            }
        }
        return '';
    }

  /**
   * Find the stateDefinition that matches the value and add the style if needed
   * @param element - DOM element with state-format properties
   * @param finalValue - Value (String or Number) to use in evaluation
   * @param DataConnector
   */
    function applyStateFormat(element, finalValue, stateDefName, DataConnector) {
        //console.log("twx-state-format", finalValue);
        getStateDefinition(stateDefName, DataConnector).then(function(stateDefs) {
            var selectedStateStyle = getSelectedStateStyle(stateDefs, finalValue);
            if (selectedStateStyle) {
                createStateStyles(element, selectedStateStyle, DataConnector);
            }
        });
    }

    twx.app.fn.applyStateFormat = applyStateFormat;
    twx.app.fn.getSelectedStateStyle = getSelectedStateStyle;
    twx.app.fn.cleanClassName = cleanClassName;
    twx.app.fn.createCSSFromStyleDefinition = createCSSFromStyleDefinition;
    twx.app.fn.createStateStyles = createStateStyles;
    twx.app.fn.addStyleToHead = addStyleToHead;

    // dynamically build textattrs attribute from it's component parts that can be changed live
    twx.app.fn.buildTextAttrs = function( textx,texty,font,fontsize,textattrs )  {
        var result = textattrs;
        if (textx) {
            result = "x:" + textx + ";" + result;
        }

        if(texty) {
            result = "y:" + texty + ";" + result;
        }

        if(font && fontsize) {
            result = "font:" + fontsize + " " + font + ";" + result;
        }
        return result;
    };

    // dynamically build imageattrs attribute from it's component parts that can be changed live
    twx.app.fn.buildImageAttrs = function(imagex,imagey,imageattrs)  {
        var result = imageattrs;

        if (imagex) {
            result = "x:" + imagex + ";" + result;
        }

        if(imagey) {
            result = "y:" + imagey + ";" + result;
        }
        return result;
    };

    twx.app.fn.isTrue = function(value) {
        if( typeof value === 'string' &&  value.toLowerCase() === 'false' ) {
            return false;
        }
        return !!value;
    };

    twx.app.fn.navigate = function (target) {
        if( window.location.hash.indexOf('#/tab/') >= 0 ) {
            window.location.hash = '#/tab/' + target;
        } else {
            window.location.hash = '#/' + target;
        }
    };

    //Makes an html widget event bindable in studio,  expr is an optional expression to eval
    twx.app.fn.triggerStudioEvent = function(target, eventName, expr, data) {
        var $scope = angular.element(target).scope();
        $scope.fireEvent(eventName, data);
        if (expr) {
            $scope.$eval(expr);
        }
        $scope.$applyAsync();
    };

    var selectedRowsName = 'selectedRows';
    var currentName = 'current';

    twx.app.fn._setCurrentAndNavigate = function (items, selectedItem, target) {
        items[currentName] = selectedItem;
        angular.forEach(items,function(item) {
            item._isSelected = false;
        });
        selectedItem._isSelected = true;

        twx.app.fn.navigate(target);
    };

    function updateCurrentAndSelectedRowsAfterUnselectInMultiSelect(list) {
        if( list === undefined ) {
            console.log('clickItemInRepeater not passing in list');
            return;
        }
        var current;
        var selectedRows = [];

        for( var i=0; i<list.length; i++ ) {
            if( list[i]._isSelected === true ) {
                if( current === undefined ) {
                    current = list[i];
                }
                selectedRows.push(list[i]);
            }
        }

        list[currentName] = current;
        list[selectedRowsName] = selectedRows;
    }

    twx.app.fn.clickItemInRepeater = function(item,list,isMultiSelect) {
        // clean up if anything wrong with list
        if( list ) {
            if( list[selectedRowsName] === undefined ) {
                list[selectedRowsName] = [];
            }
        }

        if( isMultiSelect === true || isMultiSelect === 'true' ) {

            // multi-select
            if( item ) {
                if(item._isSelected ) {
                    item._isSelected = false;
                } else {
                    item._isSelected = true;
                }
            } else {
                console.log('clickItemInRepeater not passing in item');
            }
            updateCurrentAndSelectedRowsAfterUnselectInMultiSelect(list);

        } else {
            // single-select
            if( item ) {
                // don't bother if it's already selected
                if( item._isSelected === undefined || !item._isSelected ) {

                    // clear old selected item
                    if( list[currentName] !== undefined ) {
                        list[currentName]._isSelected = false;
                    }

                    item._isSelected = true;
                    list[currentName] = item;
                    list[selectedRowsName] = [];
                    list[selectedRowsName].push(item);
                }
            } else {
                console.log('clickItemInRepeater not passing in item');
            }

        }
    };

    twx.app.fn.clickItemInSelect = function(list,isMultiSelect,value,valueField) {
        var item;
        _.each(list,function(listItem) {
           if( listItem[valueField] === value) {
               item = listItem;
           }
        });

        return twx.app.fn.clickItemInRepeater(item, list, isMultiSelect);
    };

    twx.app.fn.isItemSelected = function(item) {
        return item._isSelected;
    };

    twx.app.view = {};

    document.addEventListener('userpick', function(e) {
        var threedview = e.target.closest('twx-dt-view');
        if (threedview) {
            var widget = e.target.closest('twx-widget');
            if (widget) {
                window.twx.app.fn.triggerStudioEvent(widget, 'click', null, {originalEvent: e});
            }
        }
    });

}(window, document, angular));
