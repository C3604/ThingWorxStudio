/* begin copyright text
 *
 * Copyright Â© 2016 PTC Inc., Its Subsidiary Companies, and /or its Partners. All Rights Reserved.
 *
 * end copyright text
 */
var PTC = {};
(function() {
    var byocModule = angular.module('twx.byoc', []); // Forward declaration of the twx.byoc module, used by Studio, but not by View.
    var vuforiaModule = angular.module('vuforia-angular', ['ionic', 'twx.byoc']);

    vuforiaModule.factory('tml3dRenderer', function($window, $injector){
        if($window.cordova) { //assuming this means we are in the thing-browser
            return vuforia; //from vuforia.js
        } else {
            return $injector.get('threeJsTmlRenderer');
        }
    });

    vuforiaModule.config(function($sceDelegateProvider) {
        var originalWhitelist = $sceDelegateProvider.resourceUrlWhitelist();
        $sceDelegateProvider.resourceUrlWhitelist(originalWhitelist.concat([
            // Allow same origin resource loads.
            'self',
            // allow vufora-* scheme
            'vuforia-vumark://**',
            'vuforia-image://**',
            'vuforia-cloud://**'
        ]));
    });

    vuforiaModule.controller('VuforiaController', ['$scope', function ($scope) {
    }]);

    vuforiaModule.factory('vuforiaCleanup', ['tml3dRenderer', function(renderer) {
        return {
            cleanUpAndPause: function() {
                if (renderer && renderer.cleanUpAndPause) {
                    // Tell the native side to clean up its scene graph and pause
                    renderer.cleanUpAndPause();
                }
                // Manually clean up the javascript scene graph
                PTC.GLOBAL_SCENE = new PTC.ARScene();
            }
        };
    }]);

    vuforiaModule.factory('appSpeechService', ['tml3dRenderer', function(renderer) {
        return {
            initViewGrammar: function(grammarFile) {
                if (renderer && typeof(renderer.initViewSpeechGrammar) === "function") {
                    // called on view link to load the view-specific speech grammar
                    renderer.initViewSpeechGrammar(grammarFile);
                }
            },
            say: function(message) {
                if (renderer && typeof(renderer.say) === "function") {
                    // Use speech synthesis on message to render it into audio
                    renderer.say(message);
                }
            }
        };
    }]);

    vuforiaModule.directive('twxDtView', ['tml3dRenderer', '$rootScope', function (renderer, $rootScope) {
        var loadTrackerDefSuccessCallback = function (dataset, element) {
            try {
                document.body.style.backgroundColor = 'rgba(255,0,0,0)';

                // before we load the content, lets see if there are any shaders defined in <script> form
                gatherShaders(function(s, ts) {
                    renderer.setShader(s, ts.vertex, ts.fragment);
                });

                var mycss = VF_ANG.applyStyles() || function() {};

                dataset.trackers.forEach(function(tracker) {
                    var successCallback = function() {
                        tracker.targets.forEach(function(target) {
                            target.addAsset(tracker);
                        });

                        tracker.assets.forEach(function(asset) {
                            mycss(asset.element);
                            asset.addAsset(tracker);
                        });
                    };

                    var failureCallback = function(error) {
                        alert("Error adding tracker: [" + tracker.name + "] due to [" + error + "]");
                    };

                    if (window.thingworxview &&
                        window.thingworxview.configuration &&
                        window.thingworxview.configuration.trackingHints === true) {
                        renderer.addTracker(
                            {
                                name: tracker.name,
                                trackingHints: tracker.trackingHints
                            },
                            successCallback,
                            failureCallback
                        );
                    }
                    else {
                        renderer.addTracker(tracker.name,
                                            successCallback,
                                            failureCallback
                                           );
                    }
                });

                renderer.getTracked(function(trackedObjects) {
                    angular.forEach(trackedObjects, function(tracked) {
                        var elementToFireEventAgainst =
                            element[0].querySelector('twx-dt-target[src$="id=' + tracked + '"]') ||
                            element[0];
                        console.log("firing trackingacquired via $rootScope and domID [" + elementToFireEventAgainst.id + "] for target [" + tracked +"]");
                        $rootScope.$broadcast("trackingacquired", tracked, "twx-dt-target");
                        var evt = new CustomEvent("trackingacquired", {
                            detail: { targetName: tracked },
                            bubbles: true
                        });
                        elementToFireEventAgainst.dispatchEvent(evt);
                    });
                }, function() {
                    console.log('Failed getting tracked objects.');
                });
            } catch (err) {
                console.log(err);
                alert(err.message);
            }
        };

        function linkFunc( scope, element, attrs ) {
            setTimeout(VF_ANG.makeTransparent(element), 1000); // In case that a handcrafted experience hasn't made it transparent in the first place.
            VF_ANG.nativeEventHandler = function(evtName, targetName, targetType, evtData) {
                if (!evtName) {
                    console.warn("TML layer asked to emit an event with no name!");
                    return;
                }

                var evt;
                var parsedEventData = {};
                try {
                    if (evtData) {
                        parsedEventData = angular.fromJson(evtData);
                    }
                }
                catch (e) {
                    console.warn("TML layer was given event data for ["+evtName+"] that could not be parsed as json. evtData is: ");
                    console.warn(evtData);
                    // The DOM Event will be fired as if evtData were {}, but the angular event will be fired with the literal evtData passed in.
                    // This is to preserve historic behaviour.
                }

                var elementToDispatchWith = null;

                // search for the right element to dispatch with
                if (targetType === 'twx-dt-target') {
                    // dt-targets have a special form
                    elementToDispatchWith =
                        element[0].querySelector(targetType + '[src$="id=' + targetName +'"]');
                } else {
                    // everything else we assume that targetName is the DOM id, which should be unique
                    elementToDispatchWith = element[0].querySelector('[id="' + targetName +'"]');
                }

                if (elementToDispatchWith) {
                    if (targetType === "twx-dt-model" && parsedEventData.occurrence) {
                        var modelItem = VF_ANG.modelItemDOMLookup(elementToDispatchWith, parsedEventData.occurrence);
                        if (modelItem) {
                            elementToDispatchWith = modelItem;
                        }
                    }
                }

                if (!elementToDispatchWith) {
                    // fall back to the first linking element (i.e. twx-dt-view)
                    elementToDispatchWith = element[0];
                } else if (targetType !== 'twx-dt-target') {
                    targetName = elementToDispatchWith.id;
                    targetType = null; // It means that targetName is a unique DOM id
                }

                console.log("event [" + evtName + "] broadcast on rootScope" +
                            " and dispatched against domID [" + elementToDispatchWith.id + "]" +
                            " with type [" + targetType + "], targetName [" + targetName + "] and data [" + evtData + "]");

                //choosing to use rootScope over an emit + a broadcast
                $rootScope.$broadcast(evtName, targetName, targetType, evtData);

                evt = new CustomEvent(evtName, {
                    detail: angular.extend( {targetName: targetName}, parsedEventData),
                    bubbles: true
                });
                elementToDispatchWith.dispatchEvent(evt);
            };

            var elementExists = true;

            var clickHandler = function(event) {
                console.log("Tap on twx-dt-view element at pageX = " + event.pageX + ", pageY = " + event.pageY);
                if (typeof(renderer.userPick) === "function") {
                    renderer.userPick({x: event.pageX, y: event.pageY});
                }
            };
            element[0].addEventListener('click', clickHandler);

            element.on('$destroy', function() {
                console.log("twx-dt-view tag is removed from DOM.");
                elementExists = false;
                element[0].removeEventListener('click', clickHandler);
            });

            renderer.setupAREventsCommand(VF_ANG.nativeEventHandler, function () {
                console.log('setupAREventsCommand Failed setting up callback data set');
            });

            var maxtracking = (attrs.maxtracking === undefined) ? 1 : attrs.maxtracking;
            var extendedtracking = (attrs.extendedtracking === undefined) ? true : attrs.extendedtracking;
            var persistmap = (attrs.persistmap === undefined) ? false : attrs.persistmap;
            renderer.initializeAR(scope.license, maxtracking, extendedtracking, persistmap, attrs.near, attrs.far, function () {
                if (elementExists === false) {
                    console.log('Skip success callback of initializeAR');
                    return;
                }
                var dataset = scope.dataset;
                var markerArg = [];
                dataset.trackers.forEach(function(tracker) {
                    tracker.targets.forEach(function(target) {
                        var markerDef = {};
                        markerDef.src = target.element.attr("src");
                        if (target.element.attr("size") !== undefined) {
                            markerDef.size = target.element.attr("size");
                        }
                        markerArg.push(markerDef);
                    });
                });

                renderer.loadTrackerDef(markerArg,
                                        function() {
                                            if (elementExists) {
                                                loadTrackerDefSuccessCallback(dataset, element);
                                            } else {
                                                console.log('Skip success callback of loadTrackerDef');
                                            }
                                        },
                                        function () {
                                            alert('Failed loading data set');
                                        });
            }, function () {
                alert('Failed initializing AR');
            });
        }

        return {
            restrict: 'E',
            scope: true,
            controller: function ($scope, $element, $attrs) {
                $scope.dataset = {
                    trackers: []
                };

                this.addTracker = function (t) {
                    $scope.dataset.trackers.push(t);
                };
            },
            link: linkFunc
        };
    }]);

    vuforiaModule.directive('twxDtTracker', ['tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtView',
            controller: function ($scope, $element, $attrs) {
                $scope.tracker = {
                    targets: [],
                    assets: [],
                    models: [],
                    trackingHints: {}
                };
                $scope.tracker.name = $element.attr('id');

                if ($element.attr('stationary') === 'false') {
                    $scope.tracker.trackingHints.stationary = false;
                }

                this.getTracker = function () {
                    return $scope.tracker;
                };
                this.queueTargetForAddition = function (t) {
                    $scope.tracker.targets.push(t);
                };
                this.queueAssetForAddition = function (t) {
                    $scope.tracker.assets.push(t);
                };
                this.associateModelItem = function (modelName, obj) {
                    if($scope.tracker.models[modelName] === undefined) {
                        $scope.tracker.models[modelName] = [];
                    }
                    $scope.tracker.models[modelName].push(obj);
                };

            },
            link: function (scope, element, attrs, ctrl) {
                ctrl.addTracker(scope.tracker);

                if (attrs.enabletrackingevents === "true") {
                    renderer.setupTrackingEventsCommand(function (target, eyepos, eyedir, eyeup) {
                        var result = element[0];
                        var args = {
                            targetName: target,
                            position: eyepos,
                            gaze: eyedir,
                            up: eyeup
                        };
                        scope.$emit("tracking", args);

                        if (result !== undefined) {
                            var evt = new CustomEvent("tracking", {detail: args});
                            result.dispatchEvent(evt);
                        }

                    }, undefined);
                }
            }
        };
    }]);

    vuforiaModule.directive('twxDtTarget', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            controller: function ($scope, $element, $attrs) {
                $scope.target = VF_ANG.createObj("twx-dt-target", $element);
                this.getTarget = function () {
                    return $scope.target;
                };
            },
            link: function (scope, element, attrs, ctrl) {
                scope.target.addAsset = function(tracker) {
                    var successCallback = function() {
                        if (!VF_ANG.hasBatch(renderer)) {
                            renderer.setRotation(element.attr("id"), element.attr("rx"), element.attr("ry"), element.attr("rz"));
                            renderer.setTranslation(element.attr("id"), element.attr("x"), element.attr("y"), element.attr("z"));
                        }

                        scope.$watch(function () { return element.attr('rx') + element.attr('ry') + element.attr('rz'); }, function (value) {
                            renderer.setRotation(element.attr('id'), element.attr('rx'), element.attr('ry'), element.attr('rz'));
                        });
                        scope.$watch(function () { return element.attr('x') + element.attr('y') + element.attr('z'); }, function (value) {
                            renderer.setTranslation(element.attr('id'), element.attr('x'), element.attr('y'), element.attr('z'));
                        });

                        var originalSize;
                        if (element.attr("size") !== undefined) {
                            originalSize = element.attr("size").trim().split(" ");

                            // Validate that the first element of the specified size is actually a number.
                            // The empty string always coerces to 0, so we have to explicitly check for it.
                            // isNaN handles most other cases, but reports the string "Infinity" as a number.
                            // So the third check ensures we have a finite number.
                            if (originalSize[0] === "" ||
                                isNaN(originalSize[0]) ||
                                !isFinite(originalSize[0])) {
                                console.log("Warning, initial size specified on [" + element.attr("id") + "] is not a number: [" + element.attr("size") + "]");
                                originalSize = undefined;
                            }
                        }

                        if (originalSize !== undefined) {
                            scope.$watch(function() { return element.attr("size"); }, function (value) {
                                if (value === undefined || value === null || value === "") {
                                    // This should really go back to the default size (from dataset file)
                                    // as if size where never specified in TML in the first place.
                                    console.log("a size on the twx-dt-target is now required.");
                                    return;
                                }
                                var newSize = value.split(" ");
                                var scale = newSize[0] / originalSize[0];
                                if (scale) { // a valid, non-zero, non-nan number
                                    renderer.setScale(element.attr("id"), scale, scale, scale);
                                } else {
                                    console.log("Cannot set scale to 0 or NaN: " + newSize[0] + " / " + originalSize[0]);
                                }
                            });
                        }
                    };
                    var failureCallback = function(error) {
                        alert("Error adding marker [" + target.element.attr("id") + "] due to [" + error + "]");
                    };

                    VF_ANG.addMarker(renderer, element, function() {
                        renderer.addMarker(tracker.name,
                                           element.attr("id"),
                                           element.attr("src"),
                                           element.attr("size"),
                                           successCallback,
                                           failureCallback);
                    });
                };

                ctrl.queueTargetForAddition(scope.target);
                scope.$on('trackingacquired', function(event, args) {
                    if ( event.currentScope.me === undefined ) {
                        return;
                    }
                    event.currentScope.$apply(function() { event.currentScope.me.istracked = true; });
                    // console.log('istracked set to true for %s', event.currentScope.me.markerId);
                });
                scope.$on('trackinglost', function(event, args) {
                    if ( event.currentScope.me === undefined ) {
                        return;
                    }
                    event.currentScope.$apply(function() { event.currentScope.me.istracked = false; });
                    // console.log('istracked set to false for %s', event.currentScope.me.markerId);
                });
            }
        };
    }]);

    vuforiaModule.directive('twxDt3dobject',[ 'tml3dRenderer', function (renderer)  {
        return {
            restrict: 'E',
            require: '^twxDtTracker',/* TODO: a content widget may be attached to target as well*/
            link: function (scope, element, attrs, ctrl) {
                // if user hasn't declared a shader, provide a default
                if (element.attr('shader') === undefined) {
                    element.attr('shader', 'file:Default');
                }
                var asset = VF_ANG.createObj("twx-dt-3dobject", element);
                asset.addAsset = function(tracker) {
                    var successCallback = function () {
                        VF_ANG.addAssetCallback(scope, asset, renderer);
                    };
                    var failureCallback = function (error) {
                        alert("Problem adding 3dObject with id [" + element.attr("id") + "] due to [" + error + "]");
                    };
                    VF_ANG.addAsset(renderer, asset, function() {
                        renderer.add3DObject(tracker.name,
                                             element.attr("id"),
                                             scope.$eval(element.attr("vertices")),
                                             scope.$eval(element.attr("normals")),
                                             scope.$eval(element.attr("texcoords")),
                                             scope.$eval(element.attr("indexes")),
                                             scope.$eval(element.attr("color")),
                                             element.attr("texture"),
                                             undefined, // unused parent parameter.
                                             successCallback,
                                             failureCallback
                                            );
                    });
                };
                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtEmitter', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',/* TODO: a content widget may be attached to target as well*/
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-emitter", element);
                asset.addAsset = function(tracker) {
                    var successCallback = function () {
                        VF_ANG.addAssetCallback(scope, asset, renderer);
                    };

                    var failureCallback = function (error) {
                        alert("Error in addEmitter for [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    VF_ANG.addAsset(renderer, asset, function() {
                        renderer.addEmitter(tracker.name,
                                            element.attr("id"),
                                            scope.$eval(element.attr("particles")),
                                            scope.$eval(element.attr("radius")),
                                            scope.$eval(element.attr("velocity")),
                                            scope.$eval(element.attr("decay")),
                                            scope.$eval(element.attr("gravity")),
                                            scope.$eval(element.attr("spread")),
                                            scope.$eval(element.attr("size")),
                                            scope.$eval(element.attr("mass")),
                                            scope.$eval(element.attr("rate")),
                                            scope.$eval(element.attr("wind")),
                                            scope.$eval(element.attr("blend")),
                                            scope.$eval(element.attr("color")),
                                            element.attr("texture"),
                                            undefined, // unused "parent" parameter.
                                            successCallback,
                                            failureCallback
                                           );
                    });
                };

                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtLabel', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-label", element);
                asset.addAsset = function(tracker) {
                    var successCallback = function() {
                        VF_ANG.addAssetCallback(scope, asset, renderer);

                        scope.$watch(function () {
                            return element.attr('text') + element.attr('textattrs');
                        }, function (value) {
                            renderer.setTexture(element.attr('id'),
                                                VF_ANG.textToImage(element.attr('text'),
                                                                   element.attr('textattrs')));
                        });
                    };

                    var failureCallback = function(error) {
                        alert("twx-dt-label: Error in add3DImage id: [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    VF_ANG.addAsset(renderer, asset, function() {
                        renderer.add3DImage(tracker.name,
                                            element.attr("id"),
                                            VF_ANG.textToImage(element.attr("text"),
                                                               element.attr('textattrs')),
                                            undefined,
                                            undefined,
                                            undefined,
                                            undefined,
                                            element.attr("width"),
                                            element.attr("height"),
                                            element.attr("pivot"),
                                            successCallback,
                                            failureCallback
                                           );
                    });
                };

                ctrl.queueAssetForAddition(asset);
            }

        };
    }]);

    vuforiaModule.directive('twxDtImage', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-image", element);
                asset.addAsset = function(tracker) {
                    var addSuccessCallback = function() {
                        VF_ANG.addAssetCallback(scope, asset, renderer);

                        scope.$watch(function () { return element.attr('src'); }, function (value) {
                            var image = element.attr("src");
                            if (image.toLowerCase().endsWith(".svg")) {
                                ArSensor.downloadImage(image, function(imageObj) {
                                    if (imageObj === null) {
                                        console.log("failed to download svg for twx-dt-image id: [" + element.attr("id") + "] url [" + image + "]");
                                        return;
                                    }
                                    if (imageObj.origsrc === element.attr("src")) {
                                        var imageData = ArSensor.rebuildCanvas(element, imageObj);
                                        renderer.setTexture(element.attr("id"), imageData);
                                    }
                                });
                            }
                            else {
                                renderer.setTexture(element.attr('id'), element.attr('src'));
                            }
                        });
                    };
                    var addFailureCallback = function (error) {
                        alert("Error in add3DImage for [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    var image = element.attr("src");
                    if (image.toLowerCase().endsWith(".svg")) {
                        ArSensor.downloadImage(image, function(imageObj) {
                            if (imageObj === null) {
                                console.log("failed to download svg for twx-dt-image id: [" + element.attr("id") + "] url [" + image + "]");
                                return;
                            }

                            var imageData = ArSensor.rebuildCanvas(element, imageObj);
                            VF_ANG.addAsset(renderer, asset, function() {
                                renderer.add3DImage(tracker.name,
                                                    element.attr("id"),
                                                    imageData,
                                                    undefined,
                                                    element.attr("leaderx"),
                                                    element.attr("leadery"),
                                                    element.attr("anchorType"),
                                                    element.attr("width"),
                                                    element.attr("height"),
                                                    element.attr("pivot"),
                                                    addSuccessCallback,
                                                    addFailureCallback
                                                   );
                            });
                        });
                    } else {
                        VF_ANG.addAsset(renderer, asset, function() {
                            renderer.add3DImage(tracker.name,
                                                element.attr("id"),
                                                image,
                                                undefined,
                                                element.attr("leaderx"),
                                                element.attr("leadery"),
                                                element.attr("anchorType"),
                                                element.attr("width"),
                                                element.attr("height"),
                                                element.attr("pivot"),
                                                addSuccessCallback,
                                                addFailureCallback
                                               );
                        });
                    }
                };

                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtLeaderline', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-leaderline", element);
                asset.addAsset = function(tracker) {
                    var successCallback = function() {
                        scope.$watch(function () { return element.attr('vertices'); }, function (value) {
                            renderer.setVertices(element.attr('id'), scope.$eval(element.attr('vertices')));
                        });

                        VF_ANG.addAssetCallback(scope, asset, renderer);
                    };

                    var failureCallback = function (error) {
                        alert("Error adding leader line [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    VF_ANG.addAsset(renderer, asset, function() {
                        renderer.addLeaderLine(tracker.name,
                                               element.attr('id'),
                                               scope.$eval(element.attr("vertices")),
                                               scope.$eval(element.attr("color")),
                                               element.attr("texture"),
                                               element.attr("nbScreenCoord"),
                                               element.attr("pointSize"),
                                               element.attr("lineWidth"),
                                               undefined, // unused "parent" param
                                               successCallback,
                                               failureCallback
                                              );
                    });
                };

                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtSensor', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-sensor", element);
                asset.addAsset = function(tracker) {
                    var currentImage = null;

                    var successCallback = function () {
                        VF_ANG.addAssetCallback(scope, asset, renderer);

                        scope.$watch(function() { return element.attr('src'); }, function(newValue, oldValue) {
                            if (currentImage !== null && newValue === currentImage.origsrc) {
                                // ignore this firing, we've already cached that src.
                                return;
                            }

                            ArSensor.downloadImage(newValue, function(image) {
                                if (image === null) {
                                    console.log("download of sensor image failed.");
                                    return;
                                }
                                if (image.origsrc !== element.attr('src')) {
                                    // the src updated while we were downloading an older src.
                                    console.log("skipping updating of image since src was updated while we were downloading the image.");
                                    console.log("downloaded image url [" + image.origsrc + "]  vs [" + element.attr('src') + "]");
                                    return;
                                }
                                currentImage = image;
                                var imageData = ArSensor.rebuildCanvas(element, currentImage);
                                renderer.setTexture(element.attr('id'), imageData);
                            });
                        });


                        var canvasPropertiesWatchGroup = [];
                        ArSensor.CANVAS_RENDERING_ATTRIBUTES.forEach(function(canvasAttr) {
                            canvasPropertiesWatchGroup.push(function() { return element.attr(canvasAttr); });
                        });

                        scope.$watchGroup(canvasPropertiesWatchGroup, function (value) {
                            var imageData = ArSensor.rebuildCanvas(element, currentImage);
                            renderer.setTexture(element.attr('id'), imageData);
                        });
                    };

                    var failureCallback = function (error) {
                        alert("Error adding sensor [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    var originalImageSrc = element.attr("src");
                    ArSensor.downloadImage(originalImageSrc, function(image) {
                        if (image === null) {
                            console.log("sensor image download failed for [" + originalImageSrc + "]");
                            return;
                        }

                        currentImage = image;
                        var imageData = ArSensor.rebuildCanvas(element, currentImage);
                        VF_ANG.addAsset(renderer, asset, function() {
                            renderer.add3DImage(tracker.name,
                                                element.attr("id"),
                                                imageData,
                                                undefined,
                                                undefined,
                                                undefined,
                                                undefined,
                                                element.attr("width"),
                                                element.attr("height"),
                                                element.attr("pivot"),
                                                successCallback,
                                                failureCallback
                                               );
                        });
                    });
                };

                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtSvg', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var asset = VF_ANG.createObj("twx-dt-svg", element);
                asset.addAsset = function(tracker) {
                    var successCallback = function () {
                        VF_ANG.addAssetCallback(scope, asset, renderer);

                        scope.$watch(
                            function () { return element.attr("innerHTML");},
                            function (value) {  //%WARNING -- this is probably a perf killer
                                // rebuild svg element
                                VF_ANG.buildARSVG(asset, function(ctx) {
                                    VF_ANG.svgToImage(ctx, function(ctx, imageData) {
                                        renderer.setTexture(ctx.element.attr('id'), imageData);
                                    });
                                });
                            });
                    };

                    var failureCallback = function (error) {
                        alert("Error adding SVG [" + element.attr("id") + "] due to [" + error + "]");
                    };

                    VF_ANG.buildARSVG(asset, function(ctx) {
                        VF_ANG.svgToImage(ctx, function(ctx, imageData) {
                            VF_ANG.addAsset(renderer, asset, function() {
                                renderer.add3DImage(tracker.name,
                                                    element.attr("id"),
                                                    imageData,
                                                    undefined, // unused parent
                                                    undefined, // unused leaderX
                                                    undefined, // unused leaderY
                                                    undefined, // unused anchor
                                                    element.attr("width"),
                                                    element.attr("height"),
                                                    element.attr("pivot"),
                                                    successCallback,
                                                    failureCallback
                                                   );
                            });
                        });
                    });
                };

                asset.svgElem = element.find("svg")[0];
                asset.svgElem.hidden = true; //we dont want to render this in 2D
                ctrl.queueAssetForAddition(asset);
            }

        };
    }]);

    vuforiaModule.directive('twxDtModel', ['tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                // if user hasn't declared a shader, provide a default
                if (element.attr('shader') === undefined) {
                    element.attr('shader', 'file:Default');
                }

                var asset = VF_ANG.createObj('twx-dt-model', element);
                asset.addAsset = function(tracker) {
                    var url = element.attr("src");
                    if (url) {
                        VF_ANG.addAsset(renderer, asset, function() {
                            renderer.addPVS(tracker.name,
                                            element.attr('id'),
                                            url,
                                            element.attr("cull"),
                                            null, // unused parent parameter.
                                            VF_ANG.PVSLoader(element.attr("id"),
                                                             tracker,
                                                             scope,
                                                             renderer,
                                                             element,
                                                             attrs),
                                            null);
                        });
                    }
                };

                ctrl.queueAssetForAddition(asset);
            }
        };
    }]);

    vuforiaModule.directive('twxDtModelitem', [ 'tml3dRenderer', function (renderer) {
        return {
            restrict: 'E',
            require: '^twxDtTracker',
            link: function (scope, element, attrs, ctrl) {
                var tracker = ctrl.getTracker();
                var obj = VF_ANG.createObj('twx-dt-modelitem',element);
                var modelName = element.parent().attr('id');
                // if defined, use for attr instead of parent's name
                if(element.attr('for') !== undefined) {
                    modelName = element.attr('for');
                }
                else{
                    element.attr('for', modelName);
                }

                obj.addAsset = function() {
                    var itemName = modelName + "-" + element.attr('occurrence');
                    VF_ANG.applyWatch(scope,element,renderer,itemName);
                    scope.$watch(function () {
                        return element.attr('color');
                    }, function (value) {
                        renderer.setColor(itemName, element.attr('color'));
                    });
                    scope.$watch(function () {
                        return element.attr('texture');
                    }, function (value) {
                        renderer.setTexture(itemName, element.attr('texture'));
                    });
                };

                if (tracker.models[modelName] === undefined) {
                    tracker.models[modelName] = [];
                }

                if (VF_ANG.isModelItemPreloadSupported() || tracker.models[modelName].modelLoaded === true) {
                    obj.addAsset();
                }

                ctrl.associateModelItem(modelName, obj);
            }
        };
    }]);
})();



// we ather shaders from script elements which are marker as x-shader/*
function gatherShaders(cb) {
    var shaders = {};
    var scripts = document.getElementsByTagName("script");
    if (scripts !== undefined) {
        for(var s=0; s<scripts.length; s++) {
            var typestr = scripts[s].type;
            if ((typestr !== undefined) && typestr.indexOf('x-shader') === 0) {
                var sname = scripts[s].attributes.name.value;
                var stype = typestr.substr(11);

                // have we defined this before?
                var shader = shaders[sname];
                if (shader === undefined) {
                    // no, create a new one
                    shader = {};
                    shaders[sname] = shader;
                }
                shader[stype] = scripts[s].innerHTML;
            }
        }
    }
    if (cb !== undefined) {
        for (var sh in shaders) {
            var ts = shaders[sh];
            cb(sh, ts);
        }
    }
}

var VF_ANG = {};

VF_ANG.applyStyles = function(media) {
    var styles = document.getElementById('styles');
    if (styles !== undefined && styles !== null) {
        var st = styles.innerHTML;
        var css = CSSLoader;
        css.loadcss(st, media||'{}');
        return function(element) {
            var ename = element[0].tagName.toLowerCase();
            css.gather(ename,element.attr('id'),element.attr('class'),element.attr('style'),function(vals) {
                //console.log(vals);
                for(var a in vals) {
                    element.attr(a, vals[a]);
                }
            });
        };
    }
    else
        return undefined;
};

VF_ANG.applyWatch = function(scope,element,renderer,id) {
    var nodeId = id || element.attr('id');
    scope.$watch(function () { return element.attr('rx') + element.attr('ry') + element.attr('rz'); }, function (value) {
        renderer.setRotation(nodeId, element.attr('rx'), element.attr('ry'), element.attr('rz'));
    });
    scope.$watch(function () { return element.attr('x') + element.attr('y') + element.attr('z'); }, function (value) {
        renderer.setTranslation(nodeId, element.attr('x'), element.attr('y'), element.attr('z'));
    });
    scope.$watch(function () { return element.attr('sx') + element.attr('sy') + element.attr('sz'); }, function (value) {
        renderer.setScale(nodeId, element.attr('sx'), element.attr('sy'), element.attr('sz'));
    });
    scope.$watch(function () { return nodeId + element.attr('billboard') + element.attr('occlude') + element.attr('hidden') + element.attr('phantom') + element.attr('opacity') + element.attr('decal') + element.attr('shader') + element.attr('force-hidden'); }, function (value) {

        var decalValue = element.attr('decal');
        var eleType = element[0].localName;
        if(decalValue === undefined && (eleType === 'twx-dt-sensor' || eleType === 'twx-dt-svg' || eleType === 'twx-dt-label'  || eleType === 'twx-dt-image')) {
            decalValue = true;
        }

        var phantomValue = false;
        var forceHiddenValue = false;
        if(eleType === 'twx-dt-model' || eleType === 'twx-dt-modelitem'){
            phantomValue = element.attr('phantom');
            forceHiddenValue = element.attr('force-hidden');
        }

        renderer.setProperties(nodeId, {
            billboard: element.attr('billboard'),
            occlude:   element.attr('occlude'),
            opacity:   element.attr('opacity'),
            hidden:    element.attr('hidden'),
            decal:     decalValue,
            shader:    element.attr('shader'),
            phantom:   phantomValue,
            forceHidden: forceHiddenValue
        });
    });
};

VF_ANG.createObj = function(name,element) {
    var obj = {
        objtype: name,
        element: element
    };
    return obj;
};

VF_ANG.getTextAttrs = function(textArgs) {
    var fallbackTextAttrs = {
        "font": "36px Arial",
        "fill": "rgba(120, 255,200 , 1)",
        "stroke": "rgba(0, 0, 255, 1)",
    };
    var textAttrs = {};

    if (textArgs === undefined){
        textAttrs = fallbackTextAttrs;
    } else {
        var tmp = textArgs.split(";");
        for (var i = 0; i < tmp.length; i++) {
            // Ignore empty components and last empty one (caused by trailing ';')
            if (tmp[i].trim().length === 0) {
                continue;
            }
            var inds = tmp[i].split(":");
            textAttrs[inds[0].toLowerCase().trim()] = inds[1].trim();
        }
    }

    if (textAttrs.font === undefined) {
        textAttrs.font = fallbackTextAttrs.font;
    }

    if (textAttrs.linewidth === undefined) {
        textAttrs.linewidth = 1;
    }

    return textAttrs;
};

VF_ANG.getMeasurementCssStyle = function(textAttrs) {
    var style = {};
    style.font = textAttrs.font;
    return style;
};

VF_ANG.measureTextWidth = function(ctx, text, textAttrs) {
    var fontBackup = ctx.font;

    ctx.font = textAttrs.font;

    var width = ctx.measureText(text).width;

    if (width <= 0) {
        // If the width is 0 (for example with an empty string) then use 1.
        // This is to force the canvas to render something.
        width = 1;
    }

    ctx.font = fontBackup;

    // Unfortunately ctx.lineWidth does not affect measureText results... so I do not even try to set it and approximate
    // width difference using textAttrs.linewidth. Difference on one side of text should be textAttrs.linewidth / 2
    // which gives 2 * textAttrs.linewidth / 2 == textAttrs.linewidth for both sides of text. I'm assuming that letters
    // are not getting spaced differently when textAttrs.linewidth changes.

    // +2 for antialiasing

    var lineWidth = parseFloat(textAttrs.linewidth);
    lineWidth = textAttrs.stroke !== undefined ? lineWidth : 0;
    return width + lineWidth + 2;
};

VF_ANG.measureTextHeight = function(text, textAttrs) {
    if (VF_ANG.TEXT_MEASUREMENT_SPAN === undefined) {
        VF_ANG.TEXT_MEASUREMENT_SPAN = document.createElement("span");
        document.body.appendChild(VF_ANG.TEXT_MEASUREMENT_SPAN);
    }

    var span = VF_ANG.TEXT_MEASUREMENT_SPAN;
    span.textContent = text;
    Object.assign(span.style, VF_ANG.getMeasurementCssStyle(textAttrs));
    span.style.visibility = "hidden";
    var height = span.offsetHeight;

    if (height <= 0) {
        height = 1;
    }

    // Unfortunately base Windows 10 Edge is missing support for -webkit-text-stroke CSS style so I have to approximate
    // it like width.

    var lineWidth = parseFloat(textAttrs.linewidth);
    lineWidth = textAttrs.stroke !== undefined ? lineWidth : 0;
    return height + lineWidth + 2;
};

VF_ANG.textToImage = function(text, textArgs) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');

    var textAttrs = VF_ANG.getTextAttrs(textArgs);

    var retImg;
    if (text === undefined || text === null){
        text = "";
    }

    var textWidth = VF_ANG.measureTextWidth(ctx, text, textAttrs);
    canvas.width = textWidth;

    var textHeight = VF_ANG.measureTextHeight(text, textAttrs);
    canvas.height = textHeight;

    // Setting width and height resets the font to default so we need to restore it.
    ctx.font = textAttrs.font;

    ctx.textAlign = "start";
    ctx.textBaseline = "middle";

    // Enable to test width & height computations.
    if (false) {
        ctx.fillStyle = "#ff0000";
        ctx.fillRect(0, 0, textWidth, textHeight);
    }

    var xOffset = textAttrs.stroke === undefined ? 0 : textAttrs.linewidth / 2;

    if (textAttrs.fill !== undefined) {
        ctx.fillStyle = textAttrs.fill;
        ctx.fillText(text, xOffset, canvas.height/2);
    }
    if (textAttrs.stroke !== undefined) {
        ctx.strokeStyle = textAttrs.stroke;
        ctx.lineWidth = textAttrs.linewidth;
        ctx.strokeText(text, xOffset, canvas.height/2);
    }
    retImg = canvas.toDataURL();

    return retImg;
};

VF_ANG.encodeImg = function(objctx, src, callback) {
    //debugger;
    var retImg;
    if (src === undefined) { callback(retImg); return; }
    var image = new Image();
    image.onload = function () {
        //console.log(image.width);
        //console.log(image.height);

        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        // Get drawing context for the Canvas
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0);
        var retImg = canvas.toDataURL();
        callback(objctx, retImg, image.width, image.height);
    };
    image.src = src;
};

VF_ANG.svgToImage = function(objCtx, callback) {
    //debugger;
    var svgElem = objCtx.element.find("svg")[0];
    var seri = new XMLSerializer();
    var src = seri.serializeToString(svgElem);
    var imgSrc = 'data:image/svg+xml;base64,' + window.btoa(src);

    var image = new Image();
    image.width = objCtx.element.attr("canvaswidth");
    image.height = objCtx.element.attr("canvasheight");
    image.src = imgSrc;
    image.onload = function () {
        var canvas = document.createElement('canvas');
        canvas.width = image.width;
        canvas.height = image.height;
        // Get drawing context for the Canvas
        var ctx = canvas.getContext('2d');
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        var retImg = canvas.toDataURL();
        callback(objCtx, retImg);
    };
};

VF_ANG.buildARSVG = function (objCtx, callback) {
    var svgElem = objCtx.element.find("svg")[0];
    callback(objCtx);
};

VF_ANG.makeTransparent =  function(ele) {
    var x = ele;
    return function() {
        var keepGoing = true;
        do {
            x = angular.element(x.parent());
            if (x === undefined || x[0] === undefined)  { // this can happen in tml unit tests
                break;
            }
            x[0].style.backgroundColor = 'rgba(255,0,0,0)';
            if (x[0].tagName.toLowerCase() === 'body') {
                keepGoing = false;
            }
        } while (keepGoing);
        //Hack fix to force DOM back to transparent, sometimes it leaves itself on top of AR
        angular.element(document.body)[0].style.backgroundColor = 'rgba(1, 0, 0, .01)';
        setTimeout(function() {
            angular.element(document.body)[0].style.backgroundColor = 'rgba(255,0,0,0)';
        }, 500);
    };
};

/**
 * Returns a no-arg function that will apply the TML values of modelItems to the renderer/scene graph.
 *
 * This function is safe to call more than once.
 */
VF_ANG.applyTMLToModelItemsFactory = function(tracker, modelName, renderer) {
    return function() {
        var items = tracker.models[modelName]; // this is a flat list of twx-dt-modelitems associated with the twx-dt-model.
        if (items === null || items === undefined) {
            return;
        }

        items.forEach(function(modelItemObj) {
            var element = modelItemObj.element;
            var modelItemID = modelName + "-" + element.attr("occurrence");

            // get the values from the DOM just once
            var tmlValues = {};
            ['rx', 'ry', 'rz', 'x', 'y', 'z', 'sx', 'sy', 'sz', 'color', 'texture'].forEach(function(attr) {
                tmlValues[attr] = element.attr(attr);
            });

            // Check to see which values from the DOM need to be set:
            if (tmlValues.rx !== undefined || tmlValues.ry !== undefined || tmlValues.rz !== undefined) {
                renderer.setRotation(modelItemID, tmlValues.rx, tmlValues.ry, tmlValues.rz);
            }

            if (tmlValues.x !== undefined || tmlValues.y !== undefined || tmlValues.z !== undefined) {
                renderer.setTranslation(modelItemID, tmlValues.x, tmlValues.y, tmlValues.z);
            }

            if (tmlValues.sx !== undefined || tmlValues.sy !== undefined || tmlValues.sz !== undefined) {
                renderer.setScale(modelItemID, tmlValues.sx, tmlValues.sy, tmlValues.sz);
            }

            if (tmlValues.color) {
                renderer.setColor(modelItemID, tmlValues.color);
            }

            if (tmlValues.texture !== undefined) {
                renderer.setTexture(modelItemID, tmlValues.texture);
            }

            renderer.setProperties(modelItemID, {
                billboard:    element.attr("billboard"),
                occlude:      element.attr("occlude"),
                hidden:       element.attr("hidden"),
                opacity:      element.attr("opacity"),
                decal:        element.attr("decal"),
                shader:       element.attr("shader"),
                phantom:      element.attr('phantom'),
                forceHidden:  element.attr('force-hidden')
            });
        });
    };
};

VF_ANG.findAndRemoveAllPivotNodes = function(modelID, renderer) {
    var pivotNodeNames = [];
    var findPivotNodes = function(node) {
        if (node.name.startsWith("PIVOT_")) {
            pivotNodeNames.push(node.name);
        }
        node.children.forEach(findPivotNodes);
    };

    var model = PTC.GLOBAL_SCENE.getItem(modelID+"-/");
    if (!model) {
        return;
    }

    findPivotNodes(model);

    pivotNodeNames.forEach(function(nodeName) {
        renderer.removeNode({name:nodeName, reparent:true});
    });
};

VF_ANG.resetSceneGraphsToAsLoaded = function(modelID, renderer) {
    VF_ANG.findAndRemoveAllPivotNodes(modelID, renderer);
    PTC.GLOBAL_SCENE.reloadModelData(modelID);

    // This is the json datastructure that is sent as part of the modelLoaded callback
    var modelAndModelItems = PTC.GLOBAL_SCENE.getAsLoadedModelData(modelID);

    modelAndModelItems.forEach(function(item) {
        renderer.setTranslation(item.name, item.x, item.y, item.z);
        var q = new THREE.Quaternion(item.qx, item.qy, item.qz, item.qw);
        var eu = new THREE.Euler();
        eu.setFromQuaternion(q,"ZYX");
        renderer.setRotation(item.name,
                             eu.x * 180/Math.PI,
                             eu.y * 180/Math.PI,
                             eu.z * 180/Math.PI);

        if ((item.sx !== undefined) && (item.sy !== undefined) && (item.sz !== undefined)) {
            renderer.setScale(item.name, item.sx, item.sy, item.sz);
        } else {
            renderer.setScale(item.name, 1.0, 1.0, 1.0);
        }

        if (item.cr === undefined) {
            renderer.setColor(item.name, null);
        } else {
            var color = [item.cr, item.cg, item.cb, item.ca];
            renderer.setColor(item.name, color);
        }

        renderer.setProperties(item.name, {
            hidden: -1,
            phantom: true,
            opacity: -1,
            forceHidden: false
        });
    });
};

VF_ANG.resetScopeAndTMLValues = function(scope, element, applyTMLValuesFunc) {
    // apply TML values
    if(typeof(applyTMLValuesFunc) === "function") {
        applyTMLValuesFunc();
    }

    // The sequence attribute was cleared;
    // set an "empty" player and set steps/currentStep to the empty string for display purposes.

    scope.me.steps = "";
    scope.me.currentStep = "";
    scope.me.playing = false;
    scope.$emit('sequenceloaded', element.attr('id'), 'twx-dt-model', undefined);
};

VF_ANG.isNativeSequencerAvailable = function() {
    if (window.thingworxview && window.thingworxview.configuration && window.thingworxview.configuration.nativeSequencer) {
        return true;
    }

    return false;
};

VF_ANG.isModelItemPreloadSupported = function() {
    /* Currently model item preload is supported precisely when the native sequencer is available,
       so we just check that rather than introducing additional configuration flags.
    */
    return VF_ANG.isNativeSequencerAvailable();
};

VF_ANG.NativeSequencerHelper = function (modelId, aEventEmitter, renderer) {
    var MODEL_ID = modelId;
    var TOTALSTEPS = 0;
    var STEPS = [];
    var FIRST_STEP = 0;
    var CURRENT_STEP = 0;
    var eventEmitterFunc = aEventEmitter;

    function emitEventAsync(eventName, eventData) {
        var localData = eventData;

        if (typeof(eventData) !== "string") {
            localData = JSON.stringify(eventData);
        }

        setTimeout(function() {
            eventEmitterFunc(eventName, MODEL_ID, "twx-dt-model", localData);
        }, 0);
    }

    function getStepName(number) {
        return STEPS[number].name;
    }

    function getStepDuration(number) {
        return STEPS[number].duration;
    }

    function getCurrentStep() {
        return CURRENT_STEP;
    }

    function getTotalSteps() {
        return TOTALSTEPS - FIRST_STEP;
    }

    function getFirstStep() {
        return FIRST_STEP;
    }

    function loadSequence(url, speed, callback) {
        // ignore speed, native sequencer doesn't have such concept
        var pviParams = {
            modelID: MODEL_ID,
            url: url
        };
        renderer.loadPVI(pviParams, function (sequenceData) {
            // load completed callback
            STEPS = sequenceData.stepVec;
            TOTALSTEPS = STEPS.length;
            FIRST_STEP = 0;

            // if step 0 has acknowledgment, start on step 0, otherwise start on step 1
            if ((TOTALSTEPS > 0) && (STEPS[0].acknowledge === false) ) {
                FIRST_STEP = 1;
            }
            // ThingView might still be on step 0, but the next step to be played is CURRENT_STEP
            CURRENT_STEP = FIRST_STEP;

            if ( callback !== undefined ) {
                callback(undefined, undefined);
            }
        }, function () {
            // load failed callback
            console.log(MODEL_ID + " failed to load pvi " + url);
        });
    }

    function playSequence(callback) {
        var playParams = {
            modelID: MODEL_ID,
            stepNumber: CURRENT_STEP
        };
        renderer.playStep(playParams, null, function () {
            console.log(MODEL_ID + " failed to play step number " + CURRENT_STEP);
        });
        CURRENT_STEP++;
    }

    function previousSequence(callback) {
        if (CURRENT_STEP <= 0) {
            console.log("ignoring attempt to back up beyond step 1");
            return;
        }

        CURRENT_STEP--;
        var gotoParams = {
            modelID: MODEL_ID,
            stepNumber: CURRENT_STEP,
            position: "start"
        };
        renderer.gotoStep(gotoParams, null, null);
    }

    function nextSequence(callback) {
        if (CURRENT_STEP >= TOTALSTEPS) {
            console.log("ignoring attempt to next beyond last step");
            return;
        }

        CURRENT_STEP++;
        var gotoParams = {
            modelID: MODEL_ID,
            stepNumber: CURRENT_STEP,
            position: "start"
        };

        // if we do forward on last step, go to the end of the step
        if (CURRENT_STEP == TOTALSTEPS) {
            gotoParams.stepNumber = CURRENT_STEP - 1;
            gotoParams.position = "end";
        }

        renderer.gotoStep(gotoParams, null, null );
    }

    function reset(callback) {
        CURRENT_STEP = FIRST_STEP;
        var gotoParams = {
            modelID: MODEL_ID,
            stepNumber: CURRENT_STEP,
            position: "start"
        };
        renderer.gotoStep(gotoParams, null, null );

        if (callback !== undefined) {
            callback();
        }
    }

    function goToStep(step) {
        var gotoParams = {
            modelID: MODEL_ID,
            stepNumber: step,
            position: "start"
        };
        if (step >= FIRST_STEP && step < TOTALSTEPS ) {
            renderer.gotoStep(gotoParams, null, null);
            CURRENT_STEP = step;
        }
    }

    return {
        getStepName: getStepName,
        getStepDuration: getStepDuration,
        getCurrentStep: getCurrentStep,
        getTotalSteps: getTotalSteps,
        getFirstStep: getFirstStep,
        goToStep: goToStep,
        loadSequence: loadSequence,
        playSequence: playSequence,
        nextSequence: nextSequence,
        previousSequence: previousSequence,
        reset: reset
    };
};

VF_ANG.PVSLoader = function (name, tracker, scope, renderer, element, attrs) {
    var data = {
        name: name,
        tracker: tracker,
        scope: scope,
        element:element
    };
    return function (created) {
        try {
            var asset = {
                objtype: 'twx-dt-model',
                element: element
            };
            VF_ANG.applyWatch(scope, element, renderer);
            if (!VF_ANG.hasBatch(renderer)) {
                VF_ANG.setTransformAndRenderingProps(asset, renderer);
            }

            if (VF_ANG.isNativeSequencerAvailable() === false) {
                if (created !== undefined) {
                    PTC.GLOBAL_SCENE.loadModelData(data.name, created);
                }
            }

            // Send event up and down the scope chain. The view up the chain needs to know to keep track of the count of the loaded models,
            // the twx-widget down the chain needs to know to invoke its specific bindings.
            // The rootscope wouldn't work here as the event binding code would confuse the event from coming from other models.
            var items = data.tracker.models[data.name];
            if (data.tracker.models[data.name] === undefined) {
                data.tracker.models[data.name] = [];
            }

            data.tracker.models[data.name].modelLoaded = true;
            if (!VF_ANG.isModelItemPreloadSupported()) {
                data.tracker.models[data.name].forEach(function (modelItemAsset) {
                    modelItemAsset.addAsset();
                });
            }

            scope.$apply(function() { // Make sure setupSequence is done in angular digest loop for setting up watches
                var applyTMLFunc = VF_ANG.applyTMLToModelItemsFactory(data.tracker, data.name, renderer);
                VF_ANG.setupSequence(scope, data.name, data.element, renderer, applyTMLFunc);
            });

            data.scope.$emit('modelLoaded', data.name);
            data.scope.$broadcast('modelLoaded',data.name);
            data.scope.$root.modelLoaded = true;

        } catch (e) {
            //Error was being completely ignored before thus logging at warn rather than error
            console.warn('Error caught in VF_ANG.PVSLoader: %o', e);
        }
    };
};

VF_ANG.setupSequence = function(scope, modelID, element, renderer, applyTMLValuesFunc) {

    scope.$watch(function () { return element.attr("sequence");}, function (value, oldValue) {
        if (value === oldValue) {  // this happens the first time the watch is fired.
            if (value === undefined || value === null || value === "") {  // this means no sequence is set.
                console.log("skipping initial sequence watch invocation when there is no sequence to set.");
                return;
            }
        }

        if (!scope.me) {
            scope.me = {};
        }

        var sequenceToLoad = element.attr("sequence");

        scope.validSequenceLoaded = false;

        if (VF_ANG.isNativeSequencerAvailable() === true) {
            scope.SEQPLAYER = VF_ANG.NativeSequencerHelper(modelID,VF_ANG.nativeEventHandler,renderer);
        } else {
            scope.SEQPLAYER = new PTC.SequencePlayer(element.attr('id'), VF_ANG.nativeEventHandler, renderer);
            scope.SEQPLAYER.setSequenceAdapter(new PTC.ARPlayerAnimationAdapter(element.attr('id'),PTC.GLOBAL_SCENE));
        }

        if (sequenceToLoad !== undefined && sequenceToLoad !== null && sequenceToLoad !== "") {
            scope.SEQPLAYER.loadSequence(sequenceToLoad, 1, function (object, result) {
                scope.$apply(function() {
                    scope.me.steps = scope.SEQPLAYER.getTotalSteps();
                    scope.me.currentStep = scope.SEQPLAYER.getCurrentStep();
                    scope.me.playing = false;
                    scope.validSequenceLoaded = true;
                });

                // this is intentionally in a separate $apply block so that the listener on scope.me.currentStep gets fired before the 'sequenceloaded' event is emitted.
                scope.$apply(function() {
                    scope.$emit('sequenceloaded', element.attr('id'), 'twx-dt-model', sequenceToLoad);

                    if (scope.me.steps > 0) {
                        var name = scope.SEQPLAYER.getStepName(scope.me.currentStep);
                        scope.$emit('newStep',"(" + scope.me.currentStep + "/" + scope.SEQPLAYER.getTotalSteps() + ") " + name);
                    }
                });
                if(typeof(applyTMLValuesFunc) === "function") {
                    applyTMLValuesFunc();
                }
            });
        } else {
            // reset the scene graphs to as-loaded + tml values since we're swapping away from an animation.
            // This should only be done for the javascript animation engine; the native animation engine will have to have a different call
            if (VF_ANG.isNativeSequencerAvailable() === true) {
                scope.SEQPLAYER.loadSequence("", 1, function() {
                    scope.$apply(function() {
                        VF_ANG.resetScopeAndTMLValues(scope, element, applyTMLValuesFunc);
                    });
                });
            } else {
                VF_ANG.resetSceneGraphsToAsLoaded(modelID, renderer);
                VF_ANG.resetScopeAndTMLValues(scope, element, applyTMLValuesFunc);
            }
        }
    });

    scope.$on('serviceInvoke', function(evt, data) {
        var name = data.serviceName;
        if (scope[name]) {
            scope[name](data.params);
        }
    });

    scope.stop = function() {
        // currently "stop" will only stop playback of a playAll when it reaches the end of a step.
        scope.continuousPlayback = false;
    };

    scope.$watch('me.currentStep', function(newVal, oldVal){
        if (newVal && oldVal !== undefined) {
            if (typeof newVal === 'string') {
                newVal = Number(newVal);
            }
            var currentSeqStep = scope.SEQPLAYER.getCurrentStep();
            var totalSeqSteps = scope.SEQPLAYER.getTotalSteps();
            if (!scope.me.playing && newVal !== currentSeqStep && newVal <= totalSeqSteps && newVal > 0) {
                setTimeout(scope.goToStep, 10);
            }
        }
    });

    scope.playAll = function() {
        if (scope.validSequenceLoaded !== true) {
            return;
        }

        if (scope.me.playing === true) {
            console.log("Ignoring attempt to playAll while playing.");
            return;
        }

        // Automatically restart from the beginning if we're at the end of the sequence.
        var currentStep = scope.SEQPLAYER.getCurrentStep();
        if (currentStep > scope.SEQPLAYER.getTotalSteps()) {
            scope.reset(function() {
                setTimeout(scope.playAll, 100);
            });

            return;
        }

        scope.continuousPlayback = true;
        scope.SEQPLAYER.playSequence();
    };

    scope.play = function() {
        if (scope.validSequenceLoaded !== true) {
            return;
        }

        if (scope.me.playing === true) {
            console.log("Ignoring attempt to play while playing.");
            return;
        }

        // Automatically restart from the beginning if we're at the end of the sequence.
        var currentStep = scope.SEQPLAYER.getCurrentStep();
        if (currentStep > scope.SEQPLAYER.getTotalSteps()) {
            scope.reset(function() {
                setTimeout(scope.play, 100);
            });

            return;
        }

        scope.SEQPLAYER.playSequence();
    };

    scope.$on('stepstarted', function(event, targetID, unused_targetType, data) {
        // Check to make sure this event applies to the correct model.
        // since angular events are broadcast from the root scope we may get events pertaining to other twx-dt-models.
        if (modelID !== targetID) {
            return;
        }

        scope.$apply(function() {
            var parsedData = JSON.parse(data);
            scope.me.playing = true;
            scope.$emit('playstarted');
        });
    });

    scope.$on('stepcompleted', function(event, targetID, unused_targetType, data) {
        // Check to make sure this event applies to the correct model.
        // since angular events are broadcast from the root scope we may get events pertaining to other twx-dt-models.
        if (modelID !== targetID) {
            return;
        }

        scope.$apply(function() {
            var parsedData = JSON.parse(data);
            var name;

            if (parsedData.nextStep === -1) {
                // Reached the last step; unilaterally turn off continuousPlayback.
                scope.continuousPlayback = false;
            }

            if (parsedData.acknowledge) {
                // Acknowledgements turn off continuous playback.
                scope.continuousPlayback = false;

                // don't emit acknowledge event on a reset (known ThingView issue)
                if (parsedData.nextStep !== 0) {
                    setTimeout(function() {
                        scope.$emit('sequenceacknowledge', parsedData);
                    }, 0);
                }
            }

            if (scope.continuousPlayback === true) {
                setTimeout(function() {
                    scope.SEQPLAYER.playSequence();
                }, 100);
            } else {
                scope.me.playing = false;
                scope.$emit('playstopped', parsedData);
            }

            if (parsedData.nextStep !== -1) {
                scope.me.currentStep = parsedData.nextStep;
                name = scope.SEQPLAYER.getStepName(parsedData.nextStep);
                scope.$emit('newStep', "(" + parsedData.nextStep + "/" + parsedData.totalSteps + ") " + name);
            }
        });
    });

    scope.rewind = function(callback) {
        if (scope.validSequenceLoaded !== true) {
            return;
        }

        if (scope.me.playing === true) {
            console.log("Ignoring attempt to rewind while playing");
            return;
        }
        if (scope.me.currentStep === 1) {
            console.log("Ignoring attempt to rewind when already at the beginning.");
            return;
        }

        scope.SEQPLAYER.previousSequence(callback);
    };

    scope.forward = function(callback) {
        if (scope.validSequenceLoaded !== true) {
            return;
        }

        if (scope.me.playing === true) {
            console.log("Ignoring attempt to forward while playing");
            return;
        }
        if (scope.me.currentStep > scope.SEQPLAYER.getTotalSteps()) {
            console.log("Ignoring attempt to forward when already at the last step.");
            return;
        }

        scope.SEQPLAYER.nextSequence(callback);
    };

    scope.goToStep = function(callback) {
        if (scope.validSequenceLoaded !== true) {
            return;
        }

        if (scope.me.playing === true) {
            return;
        }

        if (scope.SEQPLAYER.getCurrentStep() === scope.me.currentStep) {
            return;
        }

        scope.SEQPLAYER.goToStep(scope.me.currentStep, callback);
    };

    // scope.reset() is now asynchronous. callback will be invoked for after a successful reset.
    scope.reset = function(callback) {
        scope.SEQPLAYER.reset(function() {
            // applyTMLValues is mostly synchronous.
            applyTMLValuesFunc();

            var current = "";
            var name = "";
            if (scope.validSequenceLoaded === true) {
                current = scope.SEQPLAYER.getCurrentStep();
                name = scope.SEQPLAYER.getStepName(current);
            }
            scope.me.currentStep = current;
            scope.me.playing = false;
            scope.continuousPlayback = false;
            if (scope.validSequenceLoaded === true) {
                scope.$emit('newStep',"(" + current + "/" + scope.SEQPLAYER.getTotalSteps() + ") " + name);
            }
            scope.$emit('sequencereset', modelID, "twx-dt-model");
            // be backwards compatible for now and emit the old onReset event as well.
            // note that it doesn't have any extra event data associated with it.
            // Only hand-crafted TML examples utilize this event, and in most cases do nothing with it.
            // In the few cases that something is done, that work may nolonger be necessary due to
            // appropriately applying TML values after a reset.
            scope.$emit('onReset');
            scope.$applyAsync();

            if (typeof(callback) === "function") {
                setTimeout(callback, 0);
            }
        });
    };
};

VF_ANG.setTransformProps = function(obj, renderer) {
    renderer.setScale( obj.element.attr('id'),  obj.element.attr("sx"),  obj.element.attr("sy"),  obj.element.attr("sz"));
    renderer.setRotation( obj.element.attr('id'),  obj.element.attr("rx"),  obj.element.attr("ry"),  obj.element.attr("rz"));
    renderer.setTranslation( obj.element.attr('id'),  obj.element.attr("x"),  obj.element.attr("y"),  obj.element.attr("z"));
};

VF_ANG.setRenderingProps = function(obj, renderer) {
    var decalValue = obj.element.attr("decal");
    if(decalValue === undefined && (obj.objtype === "twx-dt-sensor" || obj.objtype === "twx-dt-svg" || obj.objtype === "twx-dt-label"  || obj.objtype === "twx-dt-image")) {
        decalValue = true;
    }
    var phantomValue = false;
    var forceHiddenValue = false;
    if (obj.objtype === 'twx-dt-model' || obj.objtype === 'twx-dt-modelitem'){
        phantomValue = obj.element.attr('phantom');
        forceHiddenValue = obj.element.attr('force-hidden');
    }

    renderer.setProperties( obj.element.attr('id'),
                            {
                                billboard:  obj.element.attr("billboard"),
                                occlude : obj.element.attr("occlude"),
                                hidden : obj.element.attr("hidden"),
                                opacity:  obj.element.attr("opacity"),
                                decal : decalValue,
                                shader : obj.element.attr("shader"),
                                phantom: phantomValue,
                                forceHidden: forceHiddenValue
                            });
};

VF_ANG.setTransformAndRenderingProps = function(asset, renderer) {
    VF_ANG.setTransformProps(asset, renderer);
    VF_ANG.setRenderingProps(asset, renderer);
};

VF_ANG.hasBatch = function(renderer) {
    return window.thingworxview && window.thingworxview.configuration && window.thingworxview.configuration.batchProcessing === true;
};

VF_ANG.addAsset = function(renderer, asset, addFunc) {
    if (VF_ANG.hasBatch(renderer)) {
        renderer.startBatch();
        addFunc();
        VF_ANG.setTransformAndRenderingProps(asset, renderer);
        renderer.executeBatch();
    } else {
        addFunc();
    }
};

VF_ANG.addAssetCallback = function(scope, asset, renderer) {
    VF_ANG.applyWatch(scope, asset.element, renderer);
    if (!VF_ANG.hasBatch(renderer)) {
        VF_ANG.setTransformAndRenderingProps(asset, renderer);
    }
};

VF_ANG.addMarker = function(renderer, element, addFunc) {
    if (VF_ANG.hasBatch(renderer)) {
        renderer.startBatch();
        addFunc();
        renderer.setRotation(element.attr("id"), element.attr("rx"), element.attr("ry"), element.attr("rz"));
        renderer.setTranslation(element.attr("id"), element.attr("x"), element.attr("y"), element.attr("z"));
        renderer.executeBatch();
    } else {
        addFunc();
    }
};

VF_ANG.modelItemDOMLookup = function(model, idPath) {
    var modelItem = null;
    while(idPath) {
        var selector = 'twx-dt-modelitem[occurrence="' + idPath + '"]';
        // Look for descendants of model first
        modelItem = model.querySelector(selector);
        if (!modelItem) {
            // Look for twx-dt-modelitem as descendant of twx-dt-view
            modelItem = document.querySelector(selector + '[for="' + model.id + '"]');
        }
        if (modelItem) {
            return modelItem;
        } else {
            idPath = idPath.substr(0, idPath.lastIndexOf('/'));
        }
    }
    return null;
};

var ArSensor = ( function(me)  {

    function deriveTextAttrs(props) {
        var textAttrs = {
            "font": "30px Arial",
            "fill": "rgba(255, 255, 255, 1)",
            "stroke": "rgba(255, 255, 255, 0)",
            "x": props.textx,
            "y": props.texty,
            "linewidth": 1
        };

        textAttrs = overrideLocallyDefinedInlineAttributes(textAttrs, props.textattrs);
        return textAttrs;
    }

    function overrideLocallyDefinedInlineAttributes(locallyDefined, builderDefined) {
        if (builderDefined !== undefined) {
            var tmp = builderDefined.split(";");
            var i;
            for (i = 0; i < tmp.length; i++) {
                var inds = tmp[i].split(":");
                locallyDefined[inds[0].toLowerCase()] = inds[1];
            }
        }
        return locallyDefined;
    }

    function drawImageOnCanvas(props, imageObj, canvas) {
        var imgAttrs = {
            "x": props.imagex ? props.imagex : 0,
            "y": props.imagey ? props.imagey : 0,
            "width": imageObj.width,
            "height": imageObj.height
        };

        imgAttrs = overrideLocallyDefinedInlineAttributes(imgAttrs, props.imageattrs);
        //appData.props['imageattrs'] = imgAttrs;

        var ctx = canvas.getContext('2d');
        ctx.drawImage(imageObj, Number(imgAttrs.x), Number(imgAttrs.y), Number(imgAttrs.width), Number(imgAttrs.height));
    }

    function drawTextOnCanvas(props, canvas) {
        if (props.text !== undefined && props.text.length) {

            var textAttrs = deriveTextAttrs(props);

            //appData.props['textattrs'] = textAttrs;

            var ctx = canvas.getContext('2d');

            ctx.font = textAttrs.font;

            if (textAttrs.textalign !== undefined) {
                ctx.textAlign = textAttrs.textalign;
            }

            if (textAttrs.textbaseline !== undefined) {
                ctx.textBaseline = textAttrs.textbaseline;
            }

            if (textAttrs.fill !== undefined) {
                ctx.fillStyle = textAttrs.fill;
                ctx.fillText(props.text, Number(textAttrs.x), Number(textAttrs.y));
            }

            if (textAttrs.stroke !== undefined) {
                ctx.strokeStyle = textAttrs.stroke;
                ctx.lineWidth = textAttrs.linewidth;

                ctx.strokeText(props.text, Number(textAttrs.x), Number(textAttrs.y));
            }
        }
        else {
            console.log("skipping drawing the empty string: [", props.text, "]");
        }
    }

    function adjustCanvasSize(props, imageObj, canvas) {
        var width = 0;
        var height = 0;
        var ctxt = canvas.getContext('2d');

        function adjustToImage() {
            var imagex = props.imagex ? Number(props.imagex) : 0;
            if (width < imageObj.width + imagex) {
                width = imageObj.width + imagex;
            }
            var imagey = props.imagey ? Number(props.imagey) : 0;
            if (height < imageObj.height + imagey) {
                height = imageObj.height + imagey;
            }
        }

        function adjustToText() {
            var textAttrs = deriveTextAttrs(props);

            var textBasedWidth = Number(props.textx) + VF_ANG.measureTextWidth(ctxt, props.text, textAttrs);
            if (width < textBasedWidth) {
                width = textBasedWidth;
            }

            var textBasedHeight = Number(props.texty) + VF_ANG.measureTextHeight(props.text, textAttrs);
            if (height < textBasedHeight) {
                height = textBasedHeight;
            }
        }

        switch (props.canvasgrowthoverride) {
            case 'canvas':
                width = canvas.width;
                height = canvas.height;
                break;
            case 'image':
                adjustToImage();
                break;
            case 'text':
                adjustToText();
                break;
            case 'image+text':
                adjustToImage();
                adjustToText();
                break;
            default:
                width = canvas.width;
                height = canvas.height;
                if (!width || !height) {
                    adjustToImage();
                }

                break;
        }

        props.canvasheight = height;
        props.canvaswidth = width;

        canvas.height = height;
        canvas.width = width;

        ctxt.fillStyle = 'rgba(191,191,191, 0)';
        ctxt.fillRect(0, 0, canvas.width, canvas.height);
    }

    function createCanvas(props) {
        var canvas = document.createElement('canvas');

        canvas.width = props.canvaswidth;
        canvas.height = props.canvasheight;

        return canvas;
    }

    // Download an image and invoke callback; the callback will be pass 'null' in case of failure and an Image object on success.
    me.downloadImage = function downloadImage(imageURL, callback) {
        var image = new Image();

        image.onload = function() {
            callback(image);
        };

        image.onerror = function(e) {
            console.log("download failed for [" + imageURL + "]");
            console.log(e);
            callback(null);
        };

        // Capture the original literal string as a separate parameter.
        // This is because reading from image.src will result in a fully-qualified URL making it harder to compare with the
        // DOM attribute on the sensor.
        image.origsrc = imageURL;
        image.src = imageURL;
    };

    // Returns a Data URL representation of a canvas, or null if any error happened.
    me.rebuildCanvas = function rebuildCanvas(element, imageObj) {
        var props = {};
        var canvas;

        me.CANVAS_RENDERING_ATTRIBUTES.forEach(function(canvasAttr) {
            props[canvasAttr] = element.attr(canvasAttr);
        });

        // id is useful when debugging, but we do not want to setup an angular $watch on it; so it isn't in the list of CANVAS_RENDERING_ATTRIBUTES
        props.id = element.attr('id');

        try {
            canvas = createCanvas(props);
            adjustCanvasSize(props, imageObj, canvas);
            drawImageOnCanvas(props, imageObj, canvas);
            drawTextOnCanvas(props, canvas);
            return canvas.toDataURL();
        }
        catch (e) {
            console.log(e);
            return null;
        }
    };

    // These are the properties used in rendering a Sensor Canvas.
    me.CANVAS_RENDERING_ATTRIBUTES = [
        'canvaswidth',
        'canvasheight',
        'canvasgrowthoverride',
        'text',
        'textattrs',
        'textx',
        'texty',
        'imageattrs',
        'imagex',
        'imagey'
    ];

    return me;
}( ArSensor || {} ) );
