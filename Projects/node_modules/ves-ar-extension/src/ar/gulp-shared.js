/* begin copyright text
 *
 * Copyright Â© 2016 PTC Inc., Its Subsidiary Companies, and /or its Partners. All Rights Reserved.
 *
 * end copyright text
 */
var gulp = require('gulp');
var fs = require('fs-extra');
var gulpDebug = require('gulp-debug'); // jshint ignore:line
var path = require('path');
var del = require('del');
var argv = require('yargs').argv;
var _ = require('lodash');
var $ = require('cheerio');
var swig = require('swig');
var debug = require('debug')('ar-extension:gulp-shared');
var AdmZip = require('adm-zip');
var Q = require('q');
var preservetime = require('gulp-preservetime');

// TODO fixup remaining jshint errors and remove this comment:
/* jshint latedef: false, undef: false */

swig.setDefaults({
  autoescape: false,
  cache: false,
  varControls: ['<%=', '=%>']
});

var appPath = __dirname;
var srcPath = path.join(appPath, 'src');
var srcScaffoldPath = path.join(appPath, 'src-scaffold');

function getScaffoldDir(params) {
  var scaffoldDir;
  if (params.settings && params.settings.scaffoldDirectory) {
    scaffoldDir = params.settings.scaffoldDirectory;
  }
  else {
    if (params.NODE_MODULE_DIR) {
      scaffoldDir = path.join(params.NODE_MODULE_DIR, 'ves-ar-extension', 'src', 'src-scaffold');
    }
    else {
      scaffoldDir = path.join(appPath, 'src-scaffold');
    }
  }
  return scaffoldDir;
}

function copySrc(cb, appBaseDir, scaffoldDir, params) {
  debug('copySrc');
  if (!appBaseDir) {
    appBaseDir = appPath;
  }
  scaffoldDir = getScaffoldDir(params);
  const settings = params ? params.settings : fs.readJsonSync('appConfig.json');
  if(settings.thumbnail) {
    // copy thumbnail to public dir DT-6919
    fs.copySync(appBaseDir + '/src/phone/resources/' + settings.thumbnail, appBaseDir + '/dist/phone/public/' + settings.thumbnail, {clobber: true, overwrite: true});
  }

  var srcDeferred = Q.defer();
  var resourceDeferred = Q.defer();
  var sharedDeferred = Q.defer();
  var sharedjsonDeferred = Q.defer();
  var runtimeDeferred = Q.defer();
  var cssDeferred = Q.defer();
  var tmlDeferred = Q.defer();
  var scaffoldDeferred = Q.defer();

  gulp.src(appBaseDir + '/src/phone/components/*')
    //.pipe(gulpDebug({title: 'copy-src-components'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/app/components/'))
    .on('end', srcDeferred.resolve)
    .on('error', srcDeferred.reject);

  gulp.src([scaffoldDir + '/phone/resources/**/*', appBaseDir + '/src/phone/resources/**/*'])
    //.pipe(gulpDebug({title: 'copy-src-components'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/app/resources/'))
    .pipe(preservetime())
    .on('end', resourceDeferred.resolve)
    .on('error', resourceDeferred.reject);

  gulp.src([appBaseDir + '/src/shared/**/*', '!' + appBaseDir + '/src/shared/**/*.scss'])
    //.pipe(gulpDebug({title: 'copy-src-shared'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/app/shared/'))
    .on('end', sharedDeferred.resolve)
    .on('error', sharedDeferred.reject);

  gulp.src(appBaseDir + '/src/shared/components/*.json')
    //.pipe(gulpDebug({title: 'JSON'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/WEB-INF/'))
    .on('end', sharedjsonDeferred.resolve)
    .on('error', sharedjsonDeferred.reject);

  gulp.src([appBaseDir + '/extensions/combined-extension-runtime-libs.js'])
    //.pipe(gulpDebug({title: 'cp-ext'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/extensions/'))
    .on('end', runtimeDeferred.resolve)
    .on('error', runtimeDeferred.reject);

  // exclude the design time css files, those are not needed in the runtime
  gulp.src([appBaseDir + '/css/*.css', '!' + appBaseDir + '/css/*-designtime.css'])
    .pipe(gulp.dest(appBaseDir + '/dist/phone/css/'))
    .on('end', cssDeferred.resolve)
    .on('error', cssDeferred.reject);

  gulp.src([scaffoldDir + '/tml/**/*'])
    //.pipe(gulpDebug({title: 'copy-tml'}))
    .pipe(gulp.dest(appBaseDir + '/dist/tml/'))
    .pipe(preservetime())
    .on('end', tmlDeferred.resolve)
    .on('error', tmlDeferred.reject);

  gulp.src([scaffoldDir + '/phone/**/*', '!' + scaffoldDir + '/phone/resources/**/*', '!' + scaffoldDir + '/**/components/*',
      appBaseDir + '/src/phone/**/*', '!' + appBaseDir + '/src/phone/resources/**/*', '!' + appBaseDir + '/src/**/components/*'])
    //.pipe(gulpDebug({title: 'cp-src-3'}))
    .pipe(gulp.dest(appBaseDir + '/dist/phone/'))
    .pipe(preservetime())
    .on('end', scaffoldDeferred.resolve)
    .on('error', scaffoldDeferred.reject);

  return Q.all([ srcDeferred.promise,
    resourceDeferred.promise,
    sharedDeferred.promise,
    sharedjsonDeferred.promise,
    runtimeDeferred.promise,
    cssDeferred.promise,
    tmlDeferred.promise,
    scaffoldDeferred.promise
  ]);
}

function clean(cb, appBaseDir) {
  debug('clean');
  if (!appBaseDir) {
    appBaseDir = appPath;
  }
  var distPath = path.join(appBaseDir, 'dist');
  var syncResult = del.sync([distPath], {force: true});
  if (cb && typeof cb === 'function') {
    cb();
  }
  return syncResult;
}

function init(templatesPath, params) {
  if (!templatesPath) {
    templatesPath = path.join(srcScaffoldPath, 'templates');
  }

  var settingsFile = path.join(appPath, 'appConfig.json');
  var settings = fs.readJsonSync(settingsFile);
  //debug(settings.viewType);
  try {
    var isEyewear = (settings.projectType === 'eyewear');
    const viewTemplate = (settings.viewType === 'ar') ? (isEyewear ? 'home-ar-eyewear.json' : 'home-ar.json') : 'home-2d.json';
    settings.targets.phone.components[0].viewType = settings.viewType;    
    fs.writeJsonSync(settingsFile, settings, {spaces: 2});
    fs.copySync(path.join(templatesPath, viewTemplate), path.join(srcPath, 'phone/components/Home.json'));

    if(isEyewear) {
      let eyewearData = fs.readJsonSync(path.join(templatesPath, 'data-for-eyewear.json'));
      let dataPath = path.join(srcPath, 'shared/components/Data.json');
      let data = fs.readJsonSync(dataPath);
      // add the data from the eyewear data file to the main data file
      data.children = data.children.concat(eyewearData.children);
      fs.writeJsonSync(dataPath, data);
      if (params && params.projectConfig) {
        fs.copySync(path.join(params.projectConfig.defaultResourcesPath, 'src'), srcPath, {preserveTimestamps: true, overwrite: true});
      }
    }
  } catch (err) {
    console.error(err);
  }
}

/**
 * Retrieves the app params from the Data.json file
 * @param data Contents of the Data.json file as a JSON object
 * @return {{}} JSON Object where the key is the param id and the value is the app param attributes
 */
function getAppParams (data) {
  let params = {};
  let appParams = _.filter(data.children, { 'name': 'twx-app-param'});
  _.each(appParams, function(appParam) {
    params[appParam.attributes.id] = appParam.attributes;
  });

  return params;
}

function buildApp(cb, appBaseDir, scaffoldDir, params) {
  debug('build');
  var settings;
  if (!params) {
    params = {
      builderSettings: {}
    };
  }
  if (params && params.settings) {
    settings = params.settings;
  }
  if (!appBaseDir) {
    appBaseDir = appPath;
  }
  var buildTheApp = function() {
    twxAppBuilder = require(path.resolve(appBaseDir, 'extensions', 'combined-widgets.js'));
    if (settings === undefined) {
      var settingsFile = path.join(appBaseDir, 'appConfig.json');
      settings = fs.readJsonSync(settingsFile);
      params.settings = settings;
    }

    if(fs.existsSync(appPath)) {
      // generate distribution files

      ['phone'].forEach(function(target) {
        // an object containing useful information about the save operation
        var saveConfig = {
          destTargetRoot: path.join(appBaseDir, 'dist', target),
          srcTargetRoot: path.join(appBaseDir, 'src', target),
          srcSharedRoot: path.join(appBaseDir, 'src', 'shared'),
          views: (settings.targets && settings.targets[target]) ? settings.targets[target].components : [],
          projectSettings: settings
        };

        // compile all the twxml into html
        var needsMenuLayout = compileTwxmlToHtml(path.join(saveConfig.srcTargetRoot, 'components'),
          path.join(saveConfig.destTargetRoot, 'app', 'components'),
          saveConfig, params);

        compileSharedTwxmlToHtml(path.join(saveConfig.srcSharedRoot, 'components'),
          path.join(saveConfig.destTargetRoot, 'app', 'shared', 'components'));

        if(settings.projectType === 'eyewear') {
          compileVoiceRecGrammarFiles(_.assign(saveConfig, {scaffoldDir: getScaffoldDir(params)}));
        }

        // generate any additional files for distribution
        var runtimeExtensions = getRuntimeExtensionsInfo(appBaseDir);
        var sharedMetadataJsonPath = path.join(saveConfig.srcSharedRoot, 'components', 'metadata.json');
        var tmlPathPrefix = argv.tmlPathPrefix || saveConfig.projectSettings.tmlPathPrefix || 'tml';
        var offlineSave = saveConfig.projectSettings.offlineSave || false;
        var deviceHTMLContents = fs.readFileSync(path.join(saveConfig.destTargetRoot, 'app', 'shared', 'components', 'Device.html'), 'utf8');
        var dataHTMLContents = fs.readFileSync(path.join(saveConfig.destTargetRoot, 'app', 'shared', 'components', 'Data.html'), 'utf8');
        if (offlineSave) {
          // Augment the views with an appropriately inlineable value.
          // use 'saveConfig' as the 'this' object in the loop.
          settings.targets[target].components.forEach(addEscapedInlineHTML, saveConfig);
        }

        var metadata = fs.readJsonSync(sharedMetadataJsonPath);
        var defaultRoute = (metadata.experiences && metadata.experiences.length > 0) ? metadata.experiences[0].viewName : settings.targets[target].components[0].fileName;

        var dataFile = fs.readJsonSync(path.join(saveConfig.destTargetRoot, 'app', 'shared', 'components', 'Data.json'));
        var appParams = getAppParams(dataFile);
        var enableVoiceCommands = _.find(dataFile.children, {name: 'twx-app-event'}) !== undefined;

        var templateLocals = {
          theme: settings.theme || 'twx-light',
          mainNavigationMenuStyle: settings.mainNavigationMenuStyle,
          views: settings.targets[target].components,
          usesTabs: (settings.mainNavigationMenuStyle === 'tabBarMenu'),
          uuid: Date.now(),
          extensions: runtimeExtensions,
          defaultRoute: defaultRoute,
          metadata: JSON.stringify(metadata),
          parameters: JSON.stringify(appParams),
          offlineSave: offlineSave,
          tmlPathPrefix: tmlPathPrefix,
          deviceHTMLContents: deviceHTMLContents,
          dataHTMLContents: dataHTMLContents,
          enableVoiceCommands: enableVoiceCommands
        };

        // add the thumbnail info to the templateLocals only if the project has one defined
        if(settings.thumbnail) {
          templateLocals['thumbnail'] = {
            href: 'public/' + settings.thumbnail,
            type: 'image/' + path.extname(settings.thumbnail).substr(1) /* should produce a string like image/png */
          };
        }

        var defaultRouteFound = false;
        _.each(templateLocals.views, function(view) {
          if (view.fileName === defaultRoute) {
            defaultRouteFound = true;
          }
          var scriptFile = path.join(appBaseDir, 'src', target, 'components', view.fileName + '.js');
          if (fs.existsSync(scriptFile)) {
            view.script = fs.readFileSync(scriptFile);
          } else {
            console.log('no script for ' + view.fileName);
          }
        });

        if (!defaultRouteFound) {
          //Default to the first view if none found on url
          templateLocals.defaultRoute = templateLocals.views[0].fileName;
        }
        generateIndex(path.join(appBaseDir, 'dist', target), templateLocals, null, (params? params.builderSettings.useNewPreview: true), params, needsMenuLayout);

        if (settings.mainNavigationMenuStyle === 'tabBarMenu') {
          generateTabs(path.join(appBaseDir, 'dist', target), templateLocals);
        }
        generateAppJs(appBaseDir, path.join(appBaseDir, 'dist', target), templateLocals, runtimeExtensions);
      });
    } else {
      console.error(appPath + ' does not exist');
      return;
    }
  };

  return buildTheApp();
}

function readProjectSettingsSync(appBaseDir) {
  if (!appBaseDir) {
    appBaseDir = appPath;
  }
  var config = path.join(appBaseDir, 'appConfig.json');
  var data = fs.readJsonSync(config);
  return data;
}

function getServer(appBaseDir) {
  var projectData = readProjectSettingsSync(appBaseDir);
  return projectData.thingworxServer;
}

function generateIndex(appPath, locals, callback, useNewPreview, params, needsMenuLayout) {
  var indexTemplate;
  if (!params) {
    params = {};
  }
  locals.menu = (locals.mainNavigationMenuStyle === 'leftSideMenu' && (locals.views && locals.views.length > 1)) || needsMenuLayout === true;
  if (params.settings && params.settings.indexTemplate) {
    indexTemplate = params.settings.indexTemplate;
  }
  else if (locals.mainNavigationMenuStyle === 'leftSideMenu' || locals.mainNavigationMenuStyle === 'noMenu') {
    indexTemplate = 'index_sidemenu_nav.html.template';
  } else {
    indexTemplate = 'index_tabbar_nav.html.template';
  }
  var output = swig.renderFile(path.join(appPath, '_builder', indexTemplate), locals);
  if (output) {
    fs.writeFileSync(path.join(appPath, 'index.html'), output, 'utf8');

    var tmlRenderer = '<script src="../../preview3d/preview-3d.js"></script>\n ';
    var desktopOutput = output.replace('<!-- VuforiaImpl -->', tmlRenderer);
    desktopOutput = desktopOutput.replace('//desktop-ready-replacement', 'window.ionic.Platform.ready(setupWrapper);');
    var settingObj = {};
    Object.keys(params.builderSettings).forEach(function(k) {
      if (k.toLowerCase().indexOf('enabled') >= 0 || k.toLowerCase().indexOf('mode') >= 0) {
        settingObj[k] = params.builderSettings[k];
      }
    });
    desktopOutput = desktopOutput.replace('//<Replace-add-on-load>', 'top.postMessage({event: "previewReloaded"}, "*"); \n' +
      'window.builderSettings = ' + JSON.stringify(settingObj));
    fs.writeFileSync(path.join(appPath, 'index-desktop.html'), desktopOutput, 'utf8');
    if (callback) {
      callback();
    }
  }
}

function generateAppJs(appBaseDir, distPhonePath, locals) {
  locals.thingworxServer = getServer();
  locals.requires = [];
  locals.requires = locals.requires.concat(getRuntimeExtensionsInfo(appBaseDir).runtimeAngularModulesRequires);
  locals.requires = JSON.stringify(locals.requires);

  var theAppPath = path.join(distPhonePath, 'app');
  fs.ensureDirSync(theAppPath);

  var output = swig.renderFile(path.join(distPhonePath, '_builder', 'app.js.template'), locals);
  if (output) {
    fs.writeFileSync(path.join(theAppPath, 'app.js'), output, 'utf8');
  }

  output = swig.renderFile(path.join(distPhonePath, '_builder', 'app-initializer.js.template'), locals);
  if (output) {
    fs.writeFileSync(path.join(theAppPath, 'app-initializer.js'), output, 'utf8');
  }
}

function getRuntimeExtensionsInfo() {
  var runtimeExtensions = {};
  try {
    runtimeExtensions = require(appPath + '/extensions/runtimeExtensions.json');
  } catch (e) {
    console.error("could not load extensions/runtimeExtensions.json", e);
  }
  return runtimeExtensions;
}

function compileTwxmlToHtml(srcPath, stagePath, saveConfig, params) {
  fs.ensureDirSync(stagePath);
  var needsMenuLayout = false;

  _.each(saveConfig.views, function(view) {
    const srcFile = path.join(srcPath, view.fileName + '.json');
    if (fs.existsSync(srcFile)) {
      var targetFile = path.join(stagePath, view.fileName + '.html');
      var contents = fs.readFileSync(srcFile, 'utf8');
      var compiledContents = compileViewContents(JSONToXML(contents), view.fileName, view.name, saveConfig, params);
      fs.writeFileSync(targetFile, compiledContents);
      needsMenuLayout = needsMenuLayout ||
        compiledContents.indexOf('original-widget="twx-view-header"') > 0 ||
        compiledContents.indexOf('ion-footer-bar') > 0;
    } else {
      console.error(srcFile, 'does not exist');
    }
  });
  return needsMenuLayout;
}

function compileSharedTwxmlToHtml(srcPath, stagePath) {
  var files = fs.readdirSync(srcPath);
  fs.ensureDirSync(stagePath);

  _.each(files, function(file) {
    if (_.endsWith(file, '.json') && !file.includes('metadata.json')) {
      var srcFile = path.join(srcPath, file);
      var targetFile = path.join(stagePath, file.replace('.json', '.html'));
      var contents = fs.readFileSync(srcFile, 'utf8');
      var compiledContents = JSONToXML(contents);
      fs.writeFileSync(targetFile, compiledContents);
    }
  });
}

/**
 * Takes an input a file path.
 * Returns as output a data url of base mimetype image or null if the file does not exist.
 *
 * The following extensions are supported and will return the correct mime type:
 * - svg
 * - png
 * - jpg
 * - jpeg
 * - gif
 *
 * Any other extension will return image/unknown.
 */
function encodeAsDataURL(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  var ext = path.extname(filePath).toLowerCase();
  var prefix = 'data:';
  switch (ext) {
    case '.svg':
      prefix += 'image/svg+xml;base64,';
      break;
    case '.png':
      prefix += 'image/png;base64,';
      break;
    case '.jpg':
    case '.jpeg':
      prefix += 'image/jpeg;base64,';
      break;
    case '.gif':
      prefix += 'image/gif;base64,';
      break;
    default:
      prefix += 'image/unknown;base64,';
      break;
  }

  return prefix + fs.readFileSync(filePath).toString('base64');
}

function compileViewContents(contents, viewName, viewTitle, saveConfig, params) {
  debug('compile view contents ', viewName);
  // this const has to be shared between client and server
  var HTML_BOOLEAN_ATTRIBUTES = ['disabled', 'autofocus'];
  var compiledDoc = $('<div></div>');
  var overlayWidgetId;
  var headerContentItems = [];
  var hasOverlay = false;
  var hasFooter = false;
  var isEmbeddable = false;
  var overlayDoc = $('<div><div class="overlay ng-hide" ng-show=""></div></div>');
  compiledDoc.html(contents);
  var fullOriginalDoc = $('<div></div>').html(contents);
  var $target = compiledDoc.find('[twx-widget]').first();
  var idNumber = 0;
  var isViewWidget = false;
  var headerContentsHtml = '';
  var footerContentsHtml = '';
  var popupContentsHtml = '';
  var isModalView = false;
  var viewType = '';
  var footerEl;
  var isARView = false;

  while ($target.length === 1) {
    var tagName = $target[0].name; // $target.prop('tagName');

    var widgetFn = findWidgetByTag(tagName);
    if (widgetFn) {
      //console.log('Compiler - handling ----' + tagName + '-----');
      var widgetDef = widgetFn();

      isViewWidget = false;

      var isThisTagAnEmbeddableView = false;
      if (tagName === 'twx-view') {
        isViewWidget = true;
        isModalView = false;
        viewType = $target.attr('viewtype');
        if ($target.attr('viewtype') === 'embedded') {
          isEmbeddable = true;
          isThisTagAnEmbeddableView = true;
        } else if ($target.attr('viewtype') === 'modal') {
          isModalView = true;
        }
      }
      var widgetId = $target.attr('widget-id');
      if (widgetId === undefined || widgetId.length === 0) {
        widgetId = 'x' + idNumber++;
      }
      let widgetName = $target.attr('widget-name');
      if (widgetName) {
        widgetName = 'widget-name="' + widgetName + '"';
      }
      else {
        widgetName = '';
      }

      var compiledEl = $('<twx-widget widget-id="' + widgetId + '" original-widget="' + tagName + '" ' +
        widgetName + (isThisTagAnEmbeddableView ? ' twx-view ' : '' ) + '><twx-widget-content></twx-widget-content></twx-widget>');

      var properties = widgetDef.properties;
      var services = widgetDef.services || [];
      var events = widgetDef.events;
      var widgetProperties = {};
      var twxWidgetEl = compiledEl;
      var getValueFromComment = function(comment) {
        var retVal = comment;
        retVal = retVal.substring((retVal.indexOf('<!--') + 4), retVal.lastIndexOf('-->'));
        return retVal;
      };

      // TODO don't make functions within a loop
      _.each(properties, function(property) { // jshint ignore:line
        var key = property.name;
        var attrVal;
        var datatype = property.runtimeDatatype || property.datatype;

        if (datatype === 'custom_ui') {
          // Do nothing...
        } else {
          if (datatype === 'xml') {
            var propValEl = $target.find('twx-widget-property-value[name="' + _.kebabCase(key) + '"]');
            if (propValEl && propValEl.length > 0) {
              attrVal = propValEl.html();
              attrVal = getValueFromComment(attrVal);

              if (!attrVal) {
                attrVal = $target.attr(_.kebabCase(key));
              }
              propValEl.remove();
            }
            else {
              attrVal = $target.attr(_.kebabCase(key));
            }
          } else {
            attrVal = $target.attr(_.kebabCase(key));
          }

          var propValue;
          if (property.default !== undefined && property.default !== null) {

            if (property.datatype === 'json') {
              propValue = JSON.stringify(property.default || {});
            } else {
              propValue = property.default;
            }
            //console.log('set to property default: ' + property.name + ' = ' + propValue);
            if (attrVal !== undefined && attrVal !== null && attrVal !== propValue) {
              propValue = attrVal;
              //console.log('override default: ' + property.name + ' = ' + propValue);
            }
          } else {
            propValue = attrVal;
            //console.log('no default, set to defined attribute value: ' + property.name + ' = ' + propValue);
          }

          if (datatype !== undefined) {
            switch (datatype.toLowerCase()) {
              case 'number':
              case 'boolean':
                if (propValue === '') {
                  propValue = property.default;
                } else if (_.indexOf(HTML_BOOLEAN_ATTRIBUTES, propValue) > -1) {
                  propValue = true;
                }
                break;
            }
          }

          if (datatype === 'resource_url' && propValue) {
            if (saveConfig.projectSettings.offlineSave === true &&
              property.inlineForOffline === true) {
              // inline the resource.
              // TODO: handle null which can occur when the file doesn't exist on disk or cannot be read.
              propValue = encodeAsDataURL(path.join(saveConfig.destTargetRoot, 'app', 'resources', propValue));
            } else {
              propValue = 'app/resources/' + encodeURI(propValue);
            }
          }

          if (isViewWidget && property.name === 'title' && propValue !== property.default) {
            viewTitle = propValue;
          }

          if (propValue !== undefined && propValue !== null) {
            widgetProperties[key] = propValue;
          }

          if (datatype !== 'xml' && datatype !== 'custom_ui') {
            var twxWidgetPropertyEl = $('<twx-widget-property></twx-widget-property>');
            twxWidgetPropertyEl.attr('name', key);
            twxWidgetPropertyEl.attr('datatype', (datatype || ''));
            if (propValue !== undefined && propValue !== null) {
              twxWidgetPropertyEl.attr('value', propValue);
            }
            twxWidgetEl.prepend(twxWidgetPropertyEl);
          }
        }
      });

      extractPVI_ifNecessary(widgetProperties, saveConfig.srcTargetRoot, saveConfig.destTargetRoot, twxWidgetEl);

      // TODO dont' make functions within a loop
      _.each(services, function(service) { // jshint ignore:line
        var key = service.name;
        var twxWidgetServiceEl = $('<twx-widget-service></twx-widget-service>');
        twxWidgetServiceEl.attr('name', key);
        twxWidgetEl.prepend(twxWidgetServiceEl);
      });


      // TODO dont' make functions within a loop
      _.each(events, function(event) { // jshint ignore:line
        var eventExpressionName = event.name + 'Expression';
        if ($target.attr(event.name.toLowerCase() + '-expression')) {
          widgetProperties[eventExpressionName] = $target.attr(event.name.toLowerCase() + '-expression');
          twxWidgetEl.prepend('<twx-widget-event name="' + event.name + '" value="' + $target.attr(event.name.toLowerCase() + '-expression') + '"></twx-widget-event>');
        }
      });

      widgetProperties['widgetId'] = widgetId;

      var containerContentsHtml = undefined;
      if (widgetDef.isContainer === true || widgetDef.isRepeater === true) {
        var theContentEl = undefined;
        if (widgetDef.isContainer === true) {
          theContentEl = $target.find('twx-container-content').first();
        } else {
          theContentEl = $target.find('twx-repeater-content').first();
        }

        containerContentsHtml = theContentEl.html();
        theContentEl.remove();
      } else if (widgetDef.outputElementsOnly === true) {
        containerContentsHtml = $target.first().html();
      }

      var target_contents = $target.contents();
      //var contentsHtml = $target.html();
      //console.log(' ------ just testing, contentsHtml: ' + contentsHtml);
      twxWidgetEl.append(target_contents);
      compiledEl.find('twx-widget-content').append(widgetDef.runtimeTemplate(widgetProperties, twxWidgetEl, fullOriginalDoc, $));
      //console.log('  compiledEl after:' + twxWidgetEl.html());

      if (widgetDef.outputElementsOnly === true) {
        //console.log(' generating a widget with outputElementsOnly == true');
        compiledEl = $(widgetDef.runtimeTemplate(widgetProperties, twxWidgetEl, fullOriginalDoc, $));

        var newContainer = compiledEl.find('twx-container-content');
        if (newContainer === undefined || newContainer.length === 0) {
          compiledEl.append(containerContentsHtml);
        } else {
          newContainer.append(containerContentsHtml);
        }

      } else if (widgetDef.isRepeater === true) {
        var repeaterContainer = compiledEl.find('twx-widget-content').find('twx-repeater-content');
        repeaterContainer.append(containerContentsHtml);
      } else if (widgetDef.isContainer === true) {
        var widgetContainer = compiledEl.find('twx-widget-content').find('twx-container-content');
        widgetContainer.append(containerContentsHtml);
      }

      if (tagName === 'twx-header-buttons' || tagName === 'twx-header-title') {
        headerContentItems.push(compiledEl);
      }

      if (tagName === 'twx-view-footer') {
        footerEl = compiledEl;
        hasFooter = true;
      }

      $target.replaceWith(compiledEl);

      if (tagName === 'twx-toolbar') {
        hasFooter = true;
      }

      if (tagName === 'twx-overlay-panel') {
        hasOverlay = true;
        overlayWidgetId = widgetId;
      }
      if (tagName === 'twx-overlay-container') {
        isARView = true;
      }

      var scrollableElement = false;
      if (compiledEl.find('twx-widget-property[name="scrollable"][value="true"]').length > 0) {
        scrollableElement = true;
      }

      if (scrollableElement === true && isARView === true) {
        compiledEl.attr('scrollable', 'true');
      }


      //console.log('$target after: ' + $target.html());

      //console.log('   ');
    } else {
      // if we don't remove the twx-widget we keep looking for it and end up in an infinite loop
      console.log('******** cannot process twx-widget ' + tagName);
      $target.attr('twx-widget', null);
    }

    $target = compiledDoc.find('[twx-widget]').first();
  }

  if (hasOverlay) {
    var overlayEl = compiledDoc.find('div.twx-overlay-panel');
    overlayDoc.find('.overlay').append(overlayEl.html());
    overlayEl.remove();

    overlayDoc.find('.overlay').attr('ng-show', "view.wdg['" + overlayWidgetId + "'].visible == true");
  }

  if (headerContentItems.length > 0) {
    for (var i = 0; i < headerContentItems.length; i += 1) {
      var headerContentEl = headerContentItems[i];
      headerContentsHtml += headerContentEl.children('twx-widget-content').html();
      headerContentItems[i].remove();
    }
  }

  compiledDoc.find('.gridLayout[even-rows="true"]').closest('twx-widget').addClass('hasEvenlySpacedRows');
  compiledDoc.find('.gridLayout[even-rows="false"]').closest('twx-widget').removeClass('hasEvenlySpacedRows');

  var hasEvenlySpacedRowGridClass = (compiledDoc.find('.gridLayout[even-rows="true"]').length > 0).toString();


  var popupEl = compiledDoc.find('[original-widget="twx-popup"]');
  if(popupEl.length > 0) {
    popupContentsHtml = $.html(popupEl);
    popupEl.remove();
  }

  if (params.settings.projectType === 'eyewear') {
    // if there are more than one thingmarks defined (which shouldn't be the case for eyewear projects), it will use
    // the "stationary" property value from the first thingmark.
    let isTargetStationary = compiledDoc.find('twx-dt-target').closest('twx-widget').find('twx-widget-property[name="stationary"]').attr("value") || 'true';
    compiledDoc.find('twx-dt-view > twx-dt-tracker').attr('stationary', isTargetStationary);

    // remove extended tracking properties from the 3D container
    let _3DContainer = compiledDoc.find('twx-dt-view');
    _3DContainer.removeAttr('extendedtracking');
    _3DContainer.removeAttr('persistmap');
  }

  if (hasFooter) {
    footerContentsHtml = footerEl.find('ion-footer-bar').parent().html();
    footerEl.remove();
    return '<ion-view hasGridEvenRows="' + hasEvenlySpacedRowGridClass + '" view-type="' + viewType + '" twx-view="' + viewName + '" view-title="' + viewTitle + '" ctrl-name="' + viewName + '_TwxViewController" can-swipe-back="false">' + headerContentsHtml + overlayDoc.html() + '<ion-content scroll="' + ((isARView) ? "false" : "true") + '">' + compiledDoc.first().html() + '</ion-content>' + popupContentsHtml + footerContentsHtml + '</ion-view>';
    // we only should add the has-footer class if we dont want the ion-content to be under the footer, in the AR case, we do, so leave the class out.
    // return '<ion-view twx-view><ion-content class="has-footer">' + compiledDoc.first().html() + '</ion-content>' + footerDoc.html() + '</ion-view>';
  } else if (isEmbeddable) {
    return compiledDoc.first().html();
  } else if (isModalView) {
    return '<ion-modal-view twx-view="' + viewName + '" view-title="' + viewTitle + '" ctrl-name="' + viewName + '_TwxViewController">' + headerContentsHtml + overlayDoc.html() + '<ion-content scroll="' + ((isARView) ? "false" : "true") + '">' + compiledDoc.first().html() + '</ion-content></ion-modal-view>';
  } else {
    return '<ion-view hasGridEvenRows="' + hasEvenlySpacedRowGridClass + '" view-type="' + viewType + '" twx-view="' + viewName + '" view-title="' + viewTitle + '" ctrl-name="' + viewName + '_TwxViewController" can-swipe-back="false">' + headerContentsHtml + overlayDoc.html() + '<ion-content scroll="' + ((isARView) ? "false" : "true") + '">' + compiledDoc.first().html() + '</ion-content>' + popupContentsHtml +'</ion-view>';
  }
  //return '<ion-view twx-view><ion-content>' + compiledDoc.html() + '</ion-content></ion-view>';

}

/**
 * Generates a grammar file into the dist folder for each view.  The grammar file defines the voice commands that will
 * cause the associated Application Event to be fired when the voice command is recognized by the device.  If there are no
 * application events with an associated voice alias, the generation of the grammar files will be skipped.
 *
 * @param saveConfig Object containing properties/settings used to read/write files from the various locations
 */
function compileVoiceRecGrammarFiles(saveConfig) {
  let viewsDistPath = path.join(saveConfig.destTargetRoot, 'app', 'components');
  fs.ensureDirSync(viewsDistPath);

  const dataFile = fs.readJsonSync(path.join(saveConfig.srcSharedRoot, 'components', 'Data.json'));
  // find all twx-app-event elements that have a non-empty voicealias attribute
  var appEvents = _.filter(dataFile.children, function(item) {
    return item.name === 'twx-app-event' && item.attributes && item.attributes['voicealias'];
  });

  if (appEvents.length < 1) {
    debug("not generating the grammar files for the views since there are no app events with a voice alias");
    return;
  }

  var templatesPath = path.join(saveConfig.scaffoldDir, 'templates');
  var grammarTemplate = fs.readFileSync(path.join(templatesPath, "view-grammar.xml.template"), 'utf8');
  var compiledContents = generateVoiceRecGrammar(appEvents, grammarTemplate);

  _.each(saveConfig.views, function (view) {
    var grammarFile = path.join(viewsDistPath, (view.fileName + '-grammar.xml'));
    fs.writeFileSync(grammarFile, compiledContents);
  });
}

/**
 * Generates the contents of the grammar file for the given set of application events containing a voice alias command.
 *
 * @param voiceCommandAppEvents List of application events that have a voice alias command associated to it
 * @param grammarTemplate The template containing the content structure
 * @return {string}
 */
function generateVoiceRecGrammar(voiceCommandAppEvents, grammarTemplate) {

  var $grammar = $(grammarTemplate, {
    xmlMode: true,
    normalizeWhitespace: true
  });

  var helpTokens=[];
  var $cmds = $grammar.find('#cmds > one-of');
  var cmdCount = 1;

  _.each(voiceCommandAppEvents, function(appEvent) {
    var cmdToken = appEvent.attributes['voicealias'];
    var cmd = appEvent.attributes['name'];
    var cmdId = 'voice_command_' + (cmdCount++);
    var cmdHelp = appEvent.attributes['voicehelp'] || '';

    var commandBlob = " out.command=\"" + cmd + "\";";
    // the response is intentionally blank here, it's added as a event listener in the twx-app-event directive in twx-client-core-all.js
    var responseBlob = " out.response=\"\";";
    var helpBlob = " out.help=\"" + cmdHelp + "\";";
    var ruleBlob = "  <rule id=\"" + cmdId + "\">\n" +
      "    <item>\n" +
      "      <tag> " + commandBlob + responseBlob + helpBlob + "</tag>\n" +
      "      <token>" + cmdToken + "</token>\n" +
      "    </item>\n" +
      "  </rule>\n";

    $grammar.append(ruleBlob);
    var ruleRefBlob = "  <item><ruleref uri=\"#" + cmdId + "\"/></item>\n";
    $cmds.append(ruleRefBlob);
    helpTokens.push(cmdToken);
  });

  var $help = $grammar.find('#help tag');
  if($help.length){
    var $helplist = $help.eq(0);
    var helpindex = $helplist.html().replace('%%help%%', " " + helpTokens.join(", "));
    $helplist.html(helpindex);
  }

  const beautify = require('js-beautify').html;
  return beautify("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n" + $.xml($grammar), {indent_size: 2, "html": {"end_with_newline": true}});
}

function findWidgetByTag(tag) {
  var widgets = twxAppBuilder.widgets();
  var widgetWithTag = _.find(widgets, function(widgetFn) {
    var widgetDef = widgetFn();
    return (tag.toLowerCase() === widgetDef.elementTag);
  });
  return widgetWithTag;
}

// called via Array.prototype.forEach
// expects 'this' to be saveConfig.
function addEscapedInlineHTML(view) {
  var viewFilePath = path.join(this.destTargetRoot, 'app', 'components', view.fileName + '.html');
  console.log('working with view named ' + viewFilePath + ' which exists? [' + fs.existsSync(viewFilePath) + ']');
  var viewFile = fs.readFileSync(viewFilePath, 'utf8');
  var lines = viewFile.split('\n');

  lines.forEach(function(line, idx, arr) {
    arr[idx] = "'" + line.replace(/\'/g, "&apos;") + "'";
  });

  view.inlineableHTML = lines.join('+\n');
}

// Convert JSON design files to Twxml format
function JSONToXML (jsonString) {
  var xml = "";
  if (jsonString.length > 0) {
    var jsonContents = JSON.parse(jsonString);
    var rootNode = jsonContents.name;
    if (rootNode) {
      var root = $('<' + rootNode + '/>');
      root.append(convertJSON(jsonContents));
      xml = root.html();
    }
  }
  return xml;
}

function convertJSON(source) {
  var sourceName = source['name'];
  var xml = $('<' + sourceName + '/>');
  if (source.attributes) {
    _.forEach(source.attributes, function (attrValue, attrName) {
      xml.attr(attrName, attrValue);
    });
  }
  if (source.children) {
    _.forEach(source.children, function (childValue) {
      xml.append(convertJSON(childValue));
    });
  }
  return xml;
}

/**
 * Extracts PVI file from PVZ if there is a PVZ src defined and
 * the PVI sequence is defined, but PVI file doesn't exist.
 *
 * @param {object} widgetProperties that may or may not be for a Model (and may or may not have src & sequence)
 * @param {string} srcRoot path to root dir of src where PVZ and PVI should reside
 * @param {string} destRoot path to root dir of destination to extract PVI to if necessary
 * @private
 */
function extractPVI_ifNecessary(widgetProperties, srcRoot, destRoot, twxWidgetEl) {
  var src = widgetProperties.src;
  var sequence = widgetProperties.sequence;
  if(sequence && src && /\.pvz$/i.test(src)) {
    src = decodeURI(src);
    sequence = decodeURI(sequence);
    const srcpvz = path.join(srcRoot, src.substring(src.indexOf('app') + 4));
    if (!fs.existsSync(path.join(destRoot, sequence))) {
      //Do not need to extract if the pvi already exists in the uploaded dir
      var fileName = src.substring(src.lastIndexOf('/') + 1, src.length - 4);
      fileName = fileName.replace(/[^a-zA-Z0-9\-\_\.]/gi, '_');
      var newDir = fileName;
      let destpvi = path.join(destRoot, sequence.substring(0, sequence.lastIndexOf('/')), newDir, sequence.substring(sequence.lastIndexOf('/') + 1));

      //The PVI may have the same name as others in different PVZ files (removal.pvi for engine and transmission)
      //They may also exist in multiple views.   Allow for multiple duplicates by using a sub-directory of the widget id
      //and index extension to make sure it can eventually find a unique solution
      let count = 1;
      while (fs.existsSync(destpvi) && count < 1000) {
        newDir = fileName + '_' + count++;
        destpvi = path.join(destRoot, sequence.substring(0, sequence.lastIndexOf('/')), newDir, sequence.substring(sequence.lastIndexOf('/') + 1));
      }
      widgetProperties.sequence = encodeURI(sequence.replace('Uploaded/', 'Uploaded/' + newDir + '/'));
      twxWidgetEl.find('[name="sequence"]').attr('value', widgetProperties.sequence);
      debug('Extract pvi from src pvz zip', srcpvz, destpvi);
      extractPVI(srcpvz, sequence, destpvi);
    }
  }
}

/**
 * @param pvzFile  {String} file path to pvz file
 * @param pviPath  {String} url path of the pvi file.
 * @param pviFinalPath {String}  file path of the pvi file in dist
 * @private
 */
function extractPVI(pvzFile, pviPath, pviFinalPath) {
  var zip = new AdmZip(pvzFile);
  var pviNameInZip = pviPath.substring(pviPath.lastIndexOf('/') + 1);
  var pathWithoutName = pviFinalPath.substring(0, pviFinalPath.lastIndexOf(pviNameInZip));
  try {
    zip.extractEntryTo(pviNameInZip, pathWithoutName, /*maintainEntryPath*/false);
  }
  catch (e) {
    console.error('PVI extract failure', pviNameInZip, pathWithoutName, pvzFile, e);
  }
}

exports.copySrc = copySrc;
exports.clean = clean;
exports._extractPVI_ifNecessary = extractPVI_ifNecessary;
exports.init = init;
exports.readProjectSettingsSync = readProjectSettingsSync;
exports.buildApp = buildApp;
exports.getScaffoldDir = getScaffoldDir;
exports._compileVoiceRecGrammarFiles = compileVoiceRecGrammarFiles;
exports.generateIndex = generateIndex;