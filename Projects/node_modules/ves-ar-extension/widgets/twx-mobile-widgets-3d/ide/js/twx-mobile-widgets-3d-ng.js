/* begin copyright text
 *
 * Copyright Â© 2016 PTC Inc., Its Subsidiary Companies, and /or its Partners. All Rights Reserved.
 *
 * end copyright text
 */
(function () {
  'use strict';

  // Inform vuforia-angular.js about the configuration and capabilities of the preview client
  window.thingworxview = {
    configuration: {
      nativeSequencer: true
    }
  };

  var cvApi;
  var cvModel;
  var cvModelItem;
  var cvImageMarker;
  var selectedWidget;
  var unRegSelect, unRegDeselect, unRegMove, unRegLoaded, unRegReady, unRegLoadErr;

  var twxWidgets = angular.module('twx-mobile-widgets-3d-ng', []);
  var twxWidgets2 = angular.module('twx.byoc', []);

  twxWidgets.factory('threeJsTmlRenderer', renderer);
  twxWidgets2.factory('threeJsTmlRenderer', renderer);

  function renderer($rootScope, $timeout) {

    var session, cvApi;
    var floorsize = { size: 0, pos: { x: 0, y: 0 } };

    getCvWidgetClasses_preview();

    function getCanvasOffsetTop(el) {
      var offsetTop = 0;
      var offsetParent = el.offsetParent;
      while (offsetParent && offsetParent.tagName !== 'body') {
        offsetTop += offsetParent.offsetTop;
        offsetParent = offsetParent.offsetParent;
      }
      getCanvasOffsetTop = function() { return offsetTop; }; //Memoize
      return offsetTop;
    }

    function cvApiReady() {
      var els = document.querySelectorAll('twx-dt-view');
      if (els && els.length) {
        var el = els[els.length - 1];
        if (el) {
          if (!el.id) {
            el.id = 'twxDtView' + Date.now();

            if (el.parentElement) {
              var parent = el.parentElement;
              parent.setAttribute('style', 'position: absolute; width: 100vw; height: 100vh; top: 0px; left: 0px;');
            }
          }
        }
        session = cvApi.CreateSession(el.id);

        var canvasEl = el.querySelector('canvas[id*="' + el.id + '"]');
        if (canvasEl) {
          canvasEl.addEventListener('click', function(e) {
            if (session) {
              var offsetTop = getCanvasOffsetTop(canvasEl);
              session.DoUserPick(e.pageX, e.pageY - offsetTop, true, {
                  type: "click",
                  resolveFn: function(widget) {
                    $rootScope.$broadcast("userpick", widget.getAttribute("widget-id"), "", "");
                  },
                  rejectFn: function() {}
                }, function() {}
              );
            }
          });
        }

        session.AllowPartSelection(false);
        session.SetDragMode(Module.DragMode.NONE);
        session.SetDragSnap(false);
        session.SetBackgroundColor(0xEEEEEEFF);
        session.ShowGnomon(false);
        session.SetNavigationMode(Module.NavMode.VUFORIA_NOPICK);
        session.AllowCameraApplications(false);

        if (window.builderSettings.antiAliasingEnabled === false)
          session.SetAntialiasingMode(Module.AntialiasingMode.NONE);
        else
          session.SetAntialiasingMode(Module.AntialiasingMode.SS4X);

        if (window.builderSettings.viewMode === "orthographic")
          session.SetOrthographicProjection(1.0);
        else
          session.SetPerspectiveProjection(45);

        loadedObj = 0;
        addedObj = 0;
      }
    }

    function getCvWidgetClasses_preview() {
      if (cvModel == undefined) {
        cvModel = Module.Model.extend("Model", {
          loaded: false,
          stepInfoVec: [],
          OnLoadComplete: function () {
            this.loaded = true;
            $rootScope.$broadcast('loaded3DObj', { name: this.name });
          },

          OnLoadIllustrationComplete: function (name, siVec) {
            this.stepInfoVec = [];
            for (var i = 0; i < siVec.size() ; i++)
            {
              var TVstepInfo = siVec.get(i);
              var stepInfo = {
                acknowledge: TVstepInfo.acknowledge,
                duration: TVstepInfo.duration,
                name: TVstepInfo.name
              };

              this.stepInfoVec.push(stepInfo);
            }

            $rootScope.$broadcast('lodedSeq', { name: this.name });
          },
          OnLoadIllustrationError: function (name) {
            $rootScope.$broadcast('lodedSeqErr', { name: this.name });
          },
          OnSequenceEvent: function (playstate, stepInfo, playpos) {
            var eventInfo = {
              stepName: stepInfo.name,
              duration: stepInfo.duration,
              acknowledge: stepInfo.acknowledge,
              acknowledgeMessage: "",
              totalSteps: stepInfo.totalSteps,
              nextStep: stepInfo.number + 1
            };

            if (playstate == Module.SequencePlayState.STOPPED)
            {
              if (playpos == Module.SequencePlayPosition.END) {
                if (stepInfo.number == stepInfo.totalSteps - 1)
                  eventInfo.nextStep = -1;
                else
                  eventInfo.nextStep = stepInfo.number + 1;
              }
              else {
                eventInfo.nextStep = stepInfo.number;
              }

              $rootScope.$broadcast('stepcompleted', this.name, 'twx-dt-model', JSON.stringify(eventInfo));
            }
            else if (playstate == Module.SequencePlayState.PLAYING)
              $rootScope.$broadcast('stepstarted', this.name, 'twx-dt-model', JSON.stringify(eventInfo));
          },
          _ApplyScale: function (obj) {
            this.SetScale(Number(obj.sx));
          },
          _ApplyOccludeOpacity: function (occlude, opacity) {
            if (occlude !== undefined && occlude === "true")
              this.SetRenderMode(Module.RenderMode.OCCLUDING, 0);
            else if (opacity !== undefined) {
              if (opacity < 1.0)
                this.SetRenderMode(Module.RenderMode.PHANTOM, Number(opacity));
              else
                this.SetRenderMode(Module.RenderMode.SHADED, 0);
            }
          },
          OnUserPick: function (userData) {
            if (userData.type === "click")
              window.twx.widgetClickCallback(this.name, userData.resolveFn, userData.rejectFn);
          }
        });
      }
      if (cvModelItem == undefined) {
        cvModelItem = Module.ModelItem.extend("ModelItem", {
          _ApplyScale: function (obj) {
            this.SetScale(Number(obj.sx));
          },
          _ApplyOccludeOpacity: function (occlude, opacity) {
            if (occlude !== undefined && occlude === "true")
              this.SetRenderMode(Module.RenderMode.OCCLUDING, 0);
            else if (opacity !== undefined) {
              if (opacity < 1.0)
                this.SetRenderMode(Module.RenderMode.PHANTOM, Number(opacity));
              else
                this.SetRenderMode(Module.RenderMode.SHADED, 0);
            }
          },
          OnUserPick: function (userData) {
            if (userData.type === "click")
              window.twx.modelItemClickCallback(this.idPath, this.parentModelId, userData.resolveFn, userData.rejectFn);
          }
        });
      }
      if (cvImageMarker == undefined) {
        cvImageMarker = Module.ImageMarker.extend("ImageMarker", {
          OnLoadComplete: function () {
            this.loaded = true;
            $rootScope.$broadcast('loaded3DObj', { name: this.name });
          },
          OnLoadError: function () {
            console.out("OnLoadError::LoadError");
          },
          OnUserPick: function (userData) {
            if (userData.type === "click")
              window.twx.widgetClickCallback(this.name, userData.resolveFn, userData.rejectFn);
          },
          _ApplyScale: function (obj) {
            if (Number(obj.width) > 0 && Number(obj.height) > 0) {
              this.LockAspectRatio(false);
              this.SetHeight(Number(obj.height));
              this.SetWidth(Number(obj.width));
            }
            else if (Number(obj.width) > 0) {
              this.LockAspectRatio(true);
              this.SetWidth(Number(obj.width));
            }
            else if (Number(obj.height) > 0) {
              this.LockAspectRatio(true);
              this.SetHeight(Number(obj.height));
            }
            else {
              this.LockAspectRatio(true);
              this.SetHeight(Number(this.GetNativeHeight()));
            }
            if (Number(obj.sx) > 0 && Number(obj.sy) > 0) {
              this.SetScaleWidth(Number(obj.sy));
              this.SetScaleHeight(Number(obj.sy));
            }
            else {
              this.SetScaleWidth(1.0);
              this.SetScaleHeight(1.0);
            }
          },
          _ApplyOccludeOpacity: function (occlude, opacity) {
            if (occlude !== undefined)
              this.SetOccluding(occlude === "true");
            if (opacity !== undefined)
              this.SetOpacity(Number(opacity));
          }
        });
      }
    }

    if (cvApi) {
    }
    else {
      ThingView.init("system_extensions", function () {
        cvApi = ThingView;
      });
    }

    var vrSession = {};
    var loadedObj, addedObj;

    var VrSessionObj = (function (me, name, widget, type) {
      var _this = me || {};

      var mName = name;
      var mWidget = widget;
      var mType = type;

      _this.SetType = function (type) {
        mType = type;
      };

      _this.GetType = function () {
        return mType;
      };

      _this.SetWidget = function (widget) {
        mWidget = widget;
      };

      _this.GetWidget = function () {
        return mWidget;
      };

      return _this;
    });


    $rootScope.$on('loaded3DObj', function (event, args) {
      //Set properties after loading:

      var name = args.name;
      var obj = vrSession[name];

      if (obj) {
        applyProperties(obj);
        applyTransform(obj);
        applyColor(obj);
        ++loadedObj;
      }

      if (obj.GetType() == 'Model') {
        for (var obj2 in vrSession) {
          if (vrSession[obj2].GetType() == 'Model Item') {
            if (vrSession[obj2].modelName == name) {
              var relativeidpath = vrSession[obj2].idpath.slice(vrSession[obj2].idpath.indexOf("/"));
              var modelItemWidget = vrSession[obj2].GetWidget();
              if (modelItemWidget) {
                modelItemWidget.SetModelAndIdPath(obj.GetWidget(), relativeidpath);
                modelItemWidget.loaded = true;
                ++loadedObj;
                applyProperties(vrSession[obj2]);
                applyTransform(vrSession[obj2]);
                applyColor(vrSession[obj2]);
              }
            }
          }
        }

        if (obj.sequenceData)
          loadSequence(obj);
      }

      if (loadedObj === addedObj)
        session.ZoomView(Module.ZoomMode.ZOOM_ALL, 300);
    });

    $rootScope.$on('lodedSeqErr', function (event, args) {
      var name = args.name;
      var obj  = vrSession[name];
      if (obj)
        setTimeout(obj.sequenceData.seqErrCB(), 0);
    });

    $rootScope.$on('lodedSeq', function (event, args) {
      var name = args.name;
      var obj = vrSession[name];
      if (obj)
        applySequence(obj);
    });

    function getResourceUrl(objName, isResource) {
      var origin = window.location.origin;
      var project = window.location.pathname.split('/')[1];
      var localPath = 'dist/phone';
      if (isResource !== undefined && isResource === true)
        localPath += '/app/resources';

      var url = [origin, project, localPath, objName].join('/');
      return url;
    }

    function addObj(name, widget, type) {
      var addition = VrSessionObj(undefined, name, widget, type);
      vrSession[name] = addition;
      ++addedObj;
      return addition;
    }

    function applyProperties(obj) {
      var widget = obj.GetWidget();
      if (widget !== undefined && widget.loaded && obj.properties !== undefined) {
        if (obj.properties.billboard !== undefined) {
          widget.SetBillboard(obj.properties.billboard === "true")
        }
        if (obj.properties.decal !== undefined) {
          widget.SetDecal(obj.properties.decal === "true");
        }
        if (obj.properties.hidden !== undefined) {
          widget.SetVisibility(obj.properties.hidden !== "true");
        }
        if (obj.properties.forceHidden !== undefined) {
          widget.SetForceHidden(obj.properties.forceHidden === "true");
        }
        if (obj.properties.shader !== undefined) {
          if (obj.properties.shader == "demo_highlight_on") {
            if (obj.GetType() == 'Image')
              session.SelectMarker(widget, true);
            else if (obj.GetType() == 'Model')
              session.SelectModel(widget, true);
            else if (obj.GetType() == 'Model Item')
              session.SelectModelItem(widget, true);
          }
          else if (obj.properties.shader == "demo_highlight_off") {
            if (obj.GetType() == 'Image')
              session.SelectMarker(widget, false);
            else if (obj.GetType() == 'Model')
              session.SelectModel(widget, false);
            else if (obj.GetType() == 'Model Item')
              session.SelectModelItem(widget, false);
          }
          else {
            // real shader stuff goes here
          }
        }
        widget._ApplyOccludeOpacity(obj.properties.occlude, obj.properties.opacity);
        resizeFloor(session, floorsize);
      }
    }

    function applyTransform(obj) {
      var widget = obj.GetWidget();
      if (widget !== undefined && widget.loaded) {
        widget.SetOrientation(Number(obj.rx), Number(obj.ry), Number(obj.rz));
        widget.SetPosition(Number(obj.x), Number(obj.y), Number(obj.z));
        widget._ApplyScale(obj);
        resizeFloor(session, floorsize);
      }
    }

    function applyColor(obj) {
      var widget = obj.GetWidget();
      if (widget !== undefined && widget.loaded) {
        if (obj.rgb !== undefined) {
          widget.SetColor(Number(obj.rgb[1]) / 255, Number(obj.rgb[2]) / 255, Number(obj.rgb[3]) / 255, 1.0);
        }
      }
    }

    function applySequence(obj) {
      var widget = obj.GetWidget();
      if (widget !== undefined && widget.loaded) {
        var stepInfoVec = widget.stepInfoVec;
        setTimeout(obj.sequenceData.seqSuccCB({stepVec: stepInfoVec}), 0);
      }
    }

    function loadSequence(obj) {
      if (obj.sequenceData.seqURL === "") {
        obj.GetWidget().LoadIllustration("");
      }
      else {
        var seqURL = decodeURI(obj.sequenceData.seqURL);
        seqURL = seqURL.slice(seqURL.lastIndexOf('/') + 1);
        var illustrations = obj.GetWidget().GetIllustrations();
        for (var i = 0; i < illustrations.size() ; i++) {
          var illustration = illustrations.get(i);
          if (illustration.filename === seqURL) {
            obj.GetWidget().LoadIllustration(illustration.name);
            break;
          }
        }
      }
    }

    this.GetObject = function (name) {
      var sessionObj = vrSession[name];
      if (sessionObj === undefined) {

        var arr = name.split("/", 1);
        if (arr[0].endsWith("-") && arr[0].length > 1) {
          this.addModelItem(name);
        }
        else {
          addObj(name, undefined, undefined);
        }
        sessionObj = vrSession[name];
      }
      return sessionObj;
    };

    this.addPVS = function (name, id, url, cull, parent, successCb, errorCb) {
      if (session) {
        if (url === undefined) {
          console.debug('Aborting addPVS: No resource specified');
          setTimeout(errorCb, 0);
          return;
        }
        if (!this.isResourceUrlFullyQualified(url)) {
          url = getResourceUrl(url);
        }
        getCvWidgetClasses_preview();
        var widget = new cvModel();
        widget.name = id;
        session.AddModel(widget);

        var obj = vrSession[id];
        if (obj == undefined) {
          obj = addObj(id, widget, 'Model');
        }
        else {
          obj.SetWidget(widget);
          obj.SetType('Model');
        }

        widget.LoadFromURL(url, true, false);

        setTimeout(successCb, 0);
        return widget;
      }
    };

    this.loadPVI = function (pviParams, successCb, errorCb) {
      if (session)
      {
        var sessionObj = this.GetObject(pviParams.modelID);
        if (sessionObj !== undefined && sessionObj.GetType() === 'Model') {
          var widget = sessionObj.GetWidget();
          if (widget !== undefined) {
            sessionObj.sequenceData = {
              seqSuccCB: successCb,
              seqErrCB:  errorCb,
              seqURL:    pviParams.url
            };

            if (widget.loaded)
              loadSequence(sessionObj);
          }
        }
      }
    };

    this.playStep = function (playParams, successCb, errorCb) {
      if (session)
      {
        var sessionObj = this.GetObject(playParams.modelID);
        if (sessionObj !== undefined && sessionObj.GetType() === 'Model') {
          var widget = sessionObj.GetWidget();
          if (widget !== undefined)
            if (playParams.stepNumber <= widget.stepInfoVec.length)
              widget.GoToSequenceStep(Number(playParams.stepNumber), Module.SequencePlayPosition.START, true);
        }
      }
    };

    this.gotoStep = function(gotoParams, successCb, errorCb) {
      if (session)
      {
        var sessionObj = this.GetObject(gotoParams.modelID);
        var widget = sessionObj.GetWidget();

        if (sessionObj !== undefined && sessionObj.GetType() === 'Model') {

          if ((gotoParams.stepNumber === 0) ||
            (gotoParams.stepNumber === 1 && !widget.stepInfoVec[0].acknowledge))
            widget.StopAnimation();

          var position = Module.SequencePlayPosition.START;
          if (gotoParams.position == 'end')
            position = Module.SequencePlayPosition.END;

          if (widget !== undefined)
            if (gotoParams.stepNumber <= widget.stepInfoVec.length)
              widget.GoToSequenceStep(Number(gotoParams.stepNumber), position, false);
        }
      }
    };

    this.add3DImage = function (trackerName, name, image, parent, lx, ly, anchor, width, height, pivot, successCb, errorCb) {
      if (session) {

        //Marker has already been added:
        var recognizer = image.split(' ');
        if (recognizer.length === 2) {
          if (recognizer[0].includes('recognised') && recognizer[1].includes('recognised2')) {
            return;
          }
        }
        getCvWidgetClasses_preview();
        var widget = new cvImageMarker();
        widget.name = name;
        session.AddImageMarker(widget);

        var obj = vrSession[name];
        if (obj == undefined) {
          obj = addObj(name, widget, 'Image');
        }
        else {
          obj.SetWidget(widget);
          obj.SetType('Image');
        }
        obj.width = width;
        obj.height = height;

        widget.LoadFromURL(image);

        if (pivot !== undefined) {
          var anchor = Module.AnchorType.MIDDLE_CENTER;
          switch (Number(pivot)) {
            case 1:
              anchor = Module.AnchorType.TOP_LEFT;
              break;
            case 2:
              anchor = Module.AnchorType.TOP_CENTER;
              break;
            case 3:
              anchor = Module.AnchorType.TOP_RIGHT;
              break;
            case 4:
              anchor = Module.AnchorType.MIDDLE_LEFT;
              break;
            case 5:
              anchor = Module.AnchorType.MIDDLE_CENTER;
              break;
            case 6:
              anchor = Module.AnchorType.MIDDLE_RIGHT;
              break;
            case 7:
              anchor = Module.AnchorType.BOTTOM_LEFT;
              break;
            case 8:
              anchor = Module.AnchorType.BOTTOM_CENTER;
              break;
            case 9:
              anchor = Module.AnchorType.BOTTOM_RIGHT;
              break;
          }
          widget.SetAnchor(anchor);
        }
      }
      else {
        setTimeout(errorCb, 0);
      }

      setTimeout(successCb, 0);
    };

    this.addModelItem = function (name) {
      if (session) {
        getCvWidgetClasses_preview();

        var arr = name.split("/", 1);
        if (arr[0].endsWith("-") && arr[0].length > 1) {
          var modelName = arr[0].slice(0, arr[0].length - 1);
          var widget = new cvModelItem();

          session.AddModelItem(widget);
          widget.name = name;
          widget.parentModelId = modelName;
          widget.idPath = name.slice(name.indexOf("/"));

          var obj = addObj(name, widget, 'Model Item');
          obj.idpath = name;
          obj.modelName = modelName;

          var modelObj = vrSession[modelName];
          if (modelObj !== undefined) {
            var modelWidget = modelObj.GetWidget();
            if (modelWidget !== undefined && modelWidget.loaded) {
              widget.SetModelAndIdPath(modelWidget, widget.idPath);
              widget.loaded = true;
            }
          }
        }
      }
    };

    this.addGroup = function (name, id, cull, parent, successCb, errorCb) {
      if (session) {
        var views = document.querySelectorAll('twx-dt-view');
        if (views && views.length) {
          var view = views[views.length - 1];
          var element = view.querySelector("#" + id);
          if (element !== undefined && element !== null) {
            var src = element.getAttribute('src');
            if (src !== undefined && src !== null)
              this.addPVS(name, id, src, cull, parent, successCb, errorCb);
          }
        }
      }
    };

    this.setupAREventsCommand = function () {
      if (session) {
      }
    };

    this.addEmitter = function () {
    };

    this.addMarker = function (name, id, src, width, successCb, errorCb) {
      if (session) {
        var image = getResourceUrl('Default/thing_code.png', true);
        this.add3DImage(name, id, image, undefined, undefined, undefined, undefined, width, undefined, undefined, successCb, errorCb);
      }
    };

    this.addTracker = function (name, successCb, errorCb) {
      setTimeout(successCb, 0);
    };

    this.loadTrackerDef = function (marker, successCb, errorCb) {
      if (session) {
        if (successCb) {
          setTimeout(successCb, 0);
        }
      }
      else {
        setTimeout(errorCb, 0);
      }
    };

    this.initializeAR = function (license, maxtrackers, extendedtracking, persistmap, near, far, successCb, errorCb) {
      cvApiReady();
      resizeFloor(session, floorsize);

      $timeout(successCb, 0, false);
    };

    this.cleanUpAndPause = function (successCallback, errorCallback) {
      if (session != undefined) {
        for (var sessionObj in vrSession) {
          var widget = vrSession[sessionObj].GetWidget();
          var type = vrSession[sessionObj].GetType();

          if (type == 'Model')
            session.RemoveModel(widget);
          else if (type == 'Model Item')
            session.RemoveModelItem(widget, true);
          else
            session.RemoveImageMarker(widget);

          widget = undefined;
          vrSession[sessionObj].SetWidget(widget);
          floorsize = { size: 0, pos: { x: 0, y: 0 } };
        }

        cvApi.DeleteSession(session);
        session = undefined;
      }

      for (var sessionObj in vrSession) delete vrSession[sessionObj];
    };

    this.isResourceUrlFullyQualified = function isResourceUrl(src) {
      if (!src) {
        return false;
      }
      return (src.startsWith("http://") ||
      src.startsWith("https://") ||
      src.startsWith("file://") ||
      src.startsWith("data:"));
    };

    this.setTexture = function (name, src) {
      if (session && src !== undefined) {
        if (!this.isResourceUrlFullyQualified(src)) {
          src = getResourceUrl(src);
        }
        var sessionObj = vrSession[name];
        if (sessionObj !== undefined && sessionObj.GetType() == 'Image') {
          var widget = sessionObj.GetWidget();
          if (widget !== undefined) {
            widget.LoadFromURL(src);
            resizeFloor(session, floorsize);
          }
        }
      }
    };

    this.setVertices = function () {
    };

    this.setColor = function (name, color) {
      if (session) {
        var sessionObj = this.GetObject(name);
        if (sessionObj !== undefined) {
          var rgb = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
          if (rgb) {
            sessionObj.rgb = rgb;
            applyColor(sessionObj);
          }
        }
      }
    };

    this.setRotation = function (name, rx, ry, rz) {
      if (session) {
        var sessionObj = this.GetObject(name);
        if (sessionObj !== undefined) {
          sessionObj.rx = rx;
          sessionObj.ry = ry;
          sessionObj.rz = rz;
          applyTransform(sessionObj);
        }
      }
    };

    this.setTranslation = function (name, x, y, z) {
      if (session) {
        var sessionObj = this.GetObject(name);
        if (sessionObj !== undefined) {
          sessionObj.x = x;
          sessionObj.y = y;
          sessionObj.z = z;
          applyTransform(sessionObj);
        }
      }
    };

    this.setScale = function (name, x, y, z) {
      if (session) {
        var sessionObj = this.GetObject(name);
        if (sessionObj !== undefined) {
          sessionObj.sx = x;
          sessionObj.sy = y;
          sessionObj.sz = z;
          applyTransform(sessionObj);
        }
      }
    };

    this.setProperties = function (name, props) {
      if (session) {
        var sessionObj = this.GetObject(name);
        if (sessionObj !== undefined) {
          sessionObj.properties = props;
          applyProperties(sessionObj);
        }
      }
    };

    this.setShader = function (name, vertex, fragment) {
    };

    this.getTracked = function (successCb) {
    };

    return this;
  }

  /*********************************************************************************/

  twxWidgets.directive('twxDt3dView', twxDt3dView);
  twxWidgets2.directive('twxDt3dView', twxDt3dView);

  if (window.twx) {
    window.twx.widgetClickCallback = function(widgetId, resolve, reject) {
      if (widgetId) {
        var widget = document.querySelector('[widget-id="' + widgetId + '"]');
        resolve(widget );
        window.twx.app.fn.triggerStudioEvent(widget, 'click');
      }
      else {
        reject('No widget-id found');
      }
    };

    window.twx.modelItemClickCallback = function (idpath, parentModelId, resolve, reject) {
      var widgetProp = document.querySelector('[original-widget="twx-dt-modelitem"]  twx-widget-property[name="idpath"][value="'+idpath+'"] ~ twx-widget-property[name="model"][value="'+parentModelId+'"]');
      if (idpath && widgetProp) {
          var widget = widgetProp.parentNode;
          resolve(widget);
          window.twx.app.fn.triggerStudioEvent(widget, 'click');
      }
      else {
        reject('No model-item widget found with properties idpath: ' + idpath + ', parentId: ' + parentModelId);
      }
    };
  }

  function twxDt3dView($compile, $rootScope, $timeout, $window) {
    var cvApi;

    var linker = function (scope, element, attrs) {

      var ctrl = scope.ctrl;
      element.data('ctrl', ctrl);

      var parent = element[0].parentElement;
      parent.setAttribute('style', 'position: absolute; width: 100%; height: 100vh; top: 0px; left: 0px;');

      var id = parent.getAttribute("widget-id") + "-controller";
      element.attr('id', id);
      element.attr('style', 'position: inherit; width: 100%; height: 100%;');

      if (cvApi) {
        ctrl.cvApiReady();
      }
      else {
        ThingView.init("system_extensions", function () {
          cvApi = ThingView;
          ctrl.cvApiReady();
        });
      }

      function clickListener(event) {
        // deselect any current active widgets
        var canvasContents = element.closest('#canvas-contents');
        canvasContents.find('[twx-widget]').removeClass('active');

        event.stopPropagation();
      }

      element.off('click', clickListener);
      element.on('click', clickListener);

      scope.$on('$destroy', function() {
        element.off('click', clickListener);
      });

      if ($window.twx) {
        $window.twx.widgetSelectCallback = function(widgetId, resolve, reject) {
          if (widgetId) {
            resolve( $('[widget-id="' + widgetId + '"]')[0]);

          }
          else {
            reject('No widget-id found');
          }
        };

        $window.twx.get3DWidgetIdAtPoint = function(x, y) {
          var selectPromise = new Promise(function (resolve, reject) {
            ctrl.mySession.DoUserPick(x, y, true, { type: "data-bind-drop", resolveFn: resolve, rejectFn: reject }, function () {
              $window.twx.widgetSelectCallback('', resolve, reject);
            });
          });
          return selectPromise;
        };

        /**
         * Set hover drag styling,
         * @param x mouse coordinate
         * @param y mouse coordinate
         * @param isDataBindHover:  Boolean:  true for databind drag, false for new widget drag
         */
        $window.twx.set3DDragHoverAt = function(x, y, isDataBindHover){
          if (isDataBindHover)
            ctrl.mySession.DoUserPick(x, y, true, { type: "data-bind-hover" }, function () {
              ctrl.mySession.DePreselectAll();
            });
        };

        $window.twx.clear3DDragHover = function(){
          ctrl.mySession.DePreselectAll();
        };
      }
    };

    return {
      scope: {},
      link: linker,
      controllerAs: 'ctrl',
      bindToController: true,
      controller: function ($scope, $element) {
        var ctrl = this;
        ctrl.element = $element[0];
        ctrl.myWidgets = {};
        ctrl.mySession = undefined;
        ctrl.currentMode = 'authoring';
        ctrl.hiddenComponents = [];
        ctrl.reposMode = 'none';
        ctrl.floorsize = { size: 0, pos: { x: 0, y: 0 } };
        ctrl.detachedModelItems  = [];
        ctrl.detachedHiddenItems = [];

        ctrl.init = function () {
        };

        ctrl.getWidgetFactory = function (widgetTag) {
          var ret = {
            'twx-dt-model': ctrl.addModel,
            'twx-dt-target': ctrl.addImageMarker,
            'twx-dt-image': ctrl.addImageMarker,
            'twx-dt-label': ctrl.addTextMarker,
            'twx-dt-sensor': ctrl.addComboMarker,
            'twx-dt-modelitem': ctrl.addModelItem
          };
          return ret[widgetTag];
        };

        ctrl.createObject = function (ctrlWidget, originalDropOffset) {
          var widgetTag = ctrlWidget.getWidgetTagName();
          if (ctrl.getWidgetFactory(widgetTag) !== undefined) {
            ctrl.myWidgets[ctrlWidget.widgetId] = ctrlWidget;
            if (ctrl.mySession) {
              ctrl.mySession.DeselectAll();
              ctrlWidget.cvWidget = ctrl.getWidgetFactory(widgetTag)(ctrlWidget, originalDropOffset);
            }
          }
        };

        ctrl.removeObject = function (ctrlWidget) {
          if (ctrlWidget) {
            selectedWidget = ctrlWidget;
            if (ctrl.mySession) {
              ctrl.mySession.DeselectAll();
            }
            var type = ctrlWidget.widgetType();
            if (type == 'Model') {
              if (ctrl.mySession) {
                ctrl.mySession.RemoveModel(ctrlWidget.cvWidget);
              }
              ctrl.removeHiddenParts(ctrlWidget); $scope.$applyAsync();
              if (ctrlWidget.cvWidget) {
                var i = ctrlWidget.cvWidget.modelItems.length - 1;
                for (; i >= 0; i--) {
                  ctrlWidget.cvWidget.modelItems[i].ctrlWidget.remove();
                }
              }
            }
            else if (type == 'Model Item') {
              if (ctrl.mySession) {
                ctrl.mySession.RemoveModelItem(ctrlWidget.cvWidget, true);
              }
              ctrl.removeHiddenParts(ctrlWidget); $scope.$applyAsync();
              var model = ctrl.myWidgets[ctrlWidget.designPropertyValues().model];
              if (model) {
                var index = model.cvWidget.modelItems.indexOf(ctrlWidget.cvWidget);
                if (index != -1) {
                  model.cvWidget.modelItems.splice(index, 1);
                }
              }
            }
            else if (ctrl.mySession) {
              ctrl.mySession.RemoveImageMarker(ctrlWidget.cvWidget);
            }

            delete ctrl.myWidgets[ctrlWidget.widgetId];
            if (ctrlWidget.cvWidget) {
              ctrlWidget.cvWidget.delete();
            }
            ctrlWidget.cvWidget = null;
            resizeFloor(ctrl.mySession, ctrl.floorsize);
          }
        };

        ctrl.detachChildModelItems = function (ctrlWidget) {
          ctrlWidget.cvWidget.modelItems.forEach(function(modelItem) {
            ctrl.detachedModelItems.push(modelItem.ctrlWidget);
            var hiddenItem = ctrl.hiddenComponents.find(function(item) {
              return modelItem.ctrlWidget.widgetId == item.ctrlWidget.widgetId;
            });
            if (hiddenItem)
              ctrl.detachedHiddenItems.push(hiddenItem);
            ctrl.removeObject(modelItem.ctrlWidget);
          });
        };

        ctrl.attachModelItems = function (ctrlWidget) {
          ctrl.detachedModelItems.forEach(function(item) {
            ctrl.createObject(item, false);
          });
          ctrl.detachedModelItems = [];
        };

        ctrl.removeHiddenParts = function (ctrlWidget) {
          ctrl.hiddenComponents = ctrl.hiddenComponents.filter(function(item) {
            return ctrlWidget.widgetId !== item.ctrlWidget.widgetId;
          })
        };

        ctrl.selectObject = function (ctrlWidget) {
          if (ctrlWidget) {
            if (ctrlWidget != selectedWidget) {
              selectedWidget = ctrlWidget;
              if (ctrl.mySession) {
                ctrl.mySession.DeselectAll();
              }
              if (ctrlWidget.cvWidget) {
                var type = ctrlWidget.widgetType();
                if (ctrl.mySession) {
                  ctrl.mySession.DeselectAll();
                }
                ctrlWidget.cvWidget.Select(true);
              }
            }
          } else {
            if (ctrl.mySession) {
              ctrl.mySession.DeselectAll();
            }
            selectedWidget = null;
          }
        };

        ctrl.deselectObject = function (ctrlWidget) {
          if (ctrlWidget == selectedWidget) {
            selectedWidget = null;
            if (ctrl.mySession) {
              ctrl.mySession.DeselectAll();
            }
          }
        };

        if (unRegSelect) {
          unRegSelect();
        }
        unRegSelect = $scope.$on('select3DObj', function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          if (ctrl.getCompHideMode()) {
            if (args.partId === "") {
              ctrlWidget.cvWidget.SetVisibility(false);
            }
            else {
              ctrlWidget.cvWidget.SetPartVisibility(args.partId, false, true);
            }
            if (ctrl.mySession) {
              ctrl.mySession.DeselectAll();
            }
            $scope.$applyAsync(
              ctrl.hiddenComponents.push({ ctrlWidget: ctrlWidget, partId: args.partId })
            );
          }
          else {
            if (selectedWidget != ctrlWidget) {
              selectedWidget = ctrlWidget;
              args.ctrlWidget.select();
            }
          }
          $scope.$applyAsync();
        });

        if (unRegDeselect) {
          unRegDeselect();
        }
        unRegDeselect = $scope.$on('deselect3DObj', function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          if (!ctrl.getCompHideMode()) {
            if (selectedWidget == ctrlWidget) {
              selectedWidget = null;
            }
          }
          $scope.$applyAsync();
        });

        if (unRegMove) {
          unRegMove();
        }
        unRegMove = $scope.$on('move3DObj', _.debounce(function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          if (selectedWidget === ctrlWidget && parent.document.activeElement.tagName === 'IFRAME') {
            var props = {};
            props.x = args.location.position.x.toFixed(4);
            props.y = args.location.position.y.toFixed(4);
            props.z = args.location.position.z.toFixed(4);
            props.rx = args.location.orientation.x.toFixed(2);
            props.ry = args.location.orientation.y.toFixed(2);
            props.rz = args.location.orientation.z.toFixed(2);
            props.scale = args.location.scale.x.toFixed(4);
            selectedWidget.setProps(props);
          }

          resizeFloor(ctrl.mySession, ctrl.floorsize);
        }, 150));

        if (unRegLoaded) {
          unRegLoaded();
        }
        unRegLoaded = $scope.$on('loaded3DObj', function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          if (ctrlWidget.cvWidget) {
            ctrl.updateObject(ctrlWidget, ctrlWidget.designPropertyValues(), ctrlWidget.designPropertyValues());
            ctrlWidget.cvWidget.AnimateTransitions(true);
            var type = ctrlWidget.widgetType();
            if (selectedWidget == ctrlWidget && ctrl.mySession) {
              ctrl.mySession.DeselectAll();
              ctrlWidget.cvWidget.Select(true);
            }

            if (type == 'Model')
              ctrl.attachModelItems(ctrlWidget);
            else if (type == 'Model Item')
            {
              var hiddenItem = ctrl.detachedHiddenItems.find(function(item) {
                return ctrlWidget.widgetId == item.ctrlWidget.widgetId;
              });

              if (hiddenItem != undefined)
              {
                hiddenItem.ctrlWidget.cvWidget.SetVisibility(false);
                ctrl.hiddenComponents.push(hiddenItem);
                ctrl.detachedHiddenItems = ctrl.detachedHiddenItems.filter(function(item) {
                  return hiddenItem.ctrlWidget.widgetId !== item.ctrlWidget.widgetId;
                })
              }
            }
            else if (type =='3D Image' || type =='3D Label' || type =='3D Gauge')
              ctrlWidget.cvWidget._ApplyHeightWidth();

            if (ctrlWidget.cvWidget.dropCoords)
              ctrl.doZoomSelectedIfNotInView();
            else
              ctrl.doZoomAll();

            if (ctrlWidget.widgetType() == 'ThingMark')
            {
              if (ctrl.reposMode != 'mate')
                ctrl.setReposMode('mate');
            }
            else
            {
              if (ctrl.reposMode != 'translate')
                ctrl.setReposMode('translate');
            }

            resizeFloor(ctrl.mySession, ctrl.floorsize);
          }
        });

        if (unRegReady) {
          unRegReady();
        }
        unRegReady = $scope.$on('readyForZoom3DObj', function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          if (ctrlWidget.cvWidget) {
            if (ctrlWidget.cvWidget.dropCoords)
              ctrl.doZoomSelectedIfNotInView();
            else
              ctrl.doZoomAll();
          }
        });

        if (unRegLoadErr) {
          unRegLoadErr();
        }
        unRegLoadErr = $scope.$on('loadEror3DObj', function (event, args) {
          var ctrlWidget = args.ctrlWidget;
          ctrl.removeObject(ctrlWidget);
        });

        ctrl.updateObject = function (ctrlWidget, props, changedProps) {
          var widgetType = ctrlWidget.widgetType();
          if (ctrlWidget && ctrlWidget.cvWidget && parent.document.activeElement.tagName !== 'IFRAME') {
            if ("url" in changedProps) {
              if (ctrlWidget.cvWidget.GetSourceURL() != props.url) {
                ctrlWidget.cvWidget.LoadFromURL(props.url);
              }
            }
            if ("src" in changedProps) {
              if (widgetType == 'Model') {
                if (ctrlWidget.cvWidget.GetSourceURL() != props.src) {
                  $timeout(function() {
                    ctrl.detachChildModelItems(ctrlWidget);
                  });
                  ctrl.removeHiddenParts(ctrlWidget); $scope.$applyAsync();
                  ctrlWidget.cvWidget.LoadModel(props.src);
                }
              }
              else if (widgetType == '3D Gauge') {
                GenerateMarkupImage(ctrlWidget.cvWidget, props);
              }
              else {
                if (ctrlWidget.cvWidget.GetSourceURL() != props.src)
                  ctrlWidget.cvWidget.LoadFromURL(props.src);
              }
            }
            if ("x" in changedProps || "y" in changedProps || "z" in changedProps) {
              if (!isNaN(Number(props.x)) && !isNaN(Number(props.y)) && !isNaN(Number(props.z))) {
                ctrlWidget.cvWidget.SetPosition(Number(props.x), Number(props.y), Number(props.z));
              }
            }
            if ("rx" in changedProps || "ry" in changedProps || "rz" in changedProps) {
              if (!isNaN(Number(props.rx)) && !isNaN(Number(props.ry)) && !isNaN(Number(props.rz))) {
                ctrlWidget.cvWidget.SetOrientation(Number(props.rx), Number(props.ry), Number(props.rz));
              }
            }
            if ("scale" in changedProps || "width" in changedProps || "height" in changedProps) {
              if (widgetType == 'Model' || widgetType == 'Model Item') {
                ctrlWidget.cvWidget.SetScale(Number(props.scale));
              }
              else {
                SetHeightWidth(ctrlWidget.cvWidget, props);
              }
            }
            if ("visible" in changedProps) {
              // Do not reflect visibility in the Edit Canvas
              // ctrlWidget.cvWidget.SetVisibility(Number(props.visible));
            }
            if ("color" in changedProps) {
              var rgb = changedProps.color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
              if (rgb) {
                ctrlWidget.cvWidget.SetColor(Number(rgb[1]) / 255, Number(rgb[2]) / 255, Number(rgb[3]) / 255, 1.0);
              }
            }
            if ("decal" in changedProps) {
              ctrlWidget.cvWidget.SetDecal(props.decal);
            }
            if ("opacity" in changedProps || "occlude" in changedProps) {
              if (widgetType == 'Model' || widgetType == 'Model Item') {
                if (props.occlude)
                  ctrlWidget.cvWidget.SetRenderMode(Module.RenderMode.OCCLUDING, 0);
                else if (ctrlWidget.cvWidget.isPlaceHolder) {
                  ctrlWidget.cvWidget.SetRenderMode(Module.RenderMode.PHANTOM, 0.2);
                }
                else {
                  if (props.opacity < 1.0)
                    ctrlWidget.cvWidget.SetRenderMode(Module.RenderMode.PHANTOM, Number(props.opacity));
                  else
                    ctrlWidget.cvWidget.SetRenderMode(Module.RenderMode.SHADED, 0);
                }
              }
              else {
                if ("opacity" in changedProps)
                  ctrlWidget.cvWidget.SetOpacity(Number(props.opacity));
                if ("occlude" in changedProps)
                  ctrlWidget.cvWidget.SetOccluding(props.occlude);
              }
            }
            if ("billboard" in changedProps) {
              ctrlWidget.cvWidget.SetBillboard(props.billboard);
            }
            if ("text" in changedProps || "textprops" in changedProps || "textattrs" in changedProps || "font" in changedProps ||
              "fontsize" in changedProps || "textx" in changedProps || "texty" in changedProps || "imagex" in changedProps ||
              "imagey" in changedProps || "canvasheight" in changedProps || "canvaswidth" in changedProps ||
              "canvasgrowthoverride" in changedProps) {
              GenerateMarkupImage(ctrlWidget.cvWidget, props);
            }
            if ("idpath" in changedProps) {
              if (ctrlWidget.cvWidget.GetIdPath() != props.idpath) {
                var model = ctrl.myWidgets[props.model].cvWidget;
                ctrlWidget.cvWidget.SetModelAndIdPath(model, props.idpath);
              }
            }
            if ("pivot" in changedProps) {
              var anchor = Module.AnchorType.MIDDLE_CENTER;
              switch (Number(props.pivot)) {
                case 1:
                  anchor = Module.AnchorType.TOP_LEFT;
                  break;
                case 2:
                  anchor = Module.AnchorType.TOP_CENTER;
                  break;
                case 3:
                  anchor = Module.AnchorType.TOP_RIGHT;
                  break;
                case 4:
                  anchor = Module.AnchorType.MIDDLE_LEFT;
                  break;
                case 5:
                  anchor = Module.AnchorType.MIDDLE_CENTER;
                  break;
                case 6:
                  anchor = Module.AnchorType.MIDDLE_RIGHT;
                  break;
                case 7:
                  anchor = Module.AnchorType.BOTTOM_LEFT;
                  break;
                case 8:
                  anchor = Module.AnchorType.BOTTOM_CENTER;
                  break;
                case 9:
                  anchor = Module.AnchorType.BOTTOM_RIGHT;
                  break;
              }
              ctrlWidget.cvWidget.SetAnchor(anchor);
            }

            resizeFloor(ctrl.mySession, ctrl.floorsize);
          }
        };

        ctrl.beforeDestroy = function () {
          if (ctrl.mySession != undefined) {
            cvApi.DeleteSession(ctrl.mySession);
            delete ctrl.mySession;
          }
        };

        ctrl.cvApiReady = function () {
          ctrl.mySession = cvApi.CreateSession(ctrl.element.id);
          ctrl.mySession.AllowPartSelection(false);
          ctrl.mySession.SetDragMode(Module.DragMode.NONE);
          ctrl.mySession.SetDragSnap(false);
          ctrl.mySession.SetBackgroundColor(0xEEEEEEFF);
          ctrl.mySession.ShowGnomon(true);
          ctrl.mySession.SetNavigationMode(Module.NavMode.VUFORIA);
          ctrl.mySession.SetZoomOnLoad(false);
          resizeFloor(ctrl.mySession, ctrl.floorsize);
          if ($rootScope.builderSettings.antiAliasingEnabled === false)
            ctrl.mySession.SetAntialiasingMode(Module.AntialiasingMode.NONE);
          else
            ctrl.mySession.SetAntialiasingMode(Module.AntialiasingMode.SS4X);

          if ($rootScope.builderSettings.viewMode === "orthographic")
            ctrl.mySession.SetOrthographicProjection(1.0);
          else
            ctrl.mySession.SetPerspectiveProjection(45);

          angular.forEach(ctrl.myWidgets, function (ctrlWidget, widgetId) {
            ctrlWidget.cvWidget = ctrl.getWidgetFactory(ctrlWidget.getWidgetTagName())(ctrlWidget);
            ctrlWidget.cvWidget.ctrlWidget = ctrlWidget;
            ctrl.updateObject(ctrlWidget, ctrlWidget.designPropertyValues(), ctrlWidget.designPropertyValues());
          });
        };

        ctrl.hasSelectedObject = function () {
          if (!ctrl.mySession) {
            return false;
          }
          if (ctrl.mySession.GetSelectionCount() > 0)
            return true;
          else
            return false;
        };

        // Various functions to handle the Component Hide mode
        ctrl.hasHiddenComponents = function () {
          return ctrl.hiddenComponents.length > 0;
        };
        ctrl.getCompHideMode = function () {
          return (ctrl.currentMode === 'compHide');
        };
        ctrl.toggleCompHideMode = function () {
          if (ctrl.getCompHideMode()) {
            ctrl.setAuthoringMode();
          } else {
            ctrl.setCompHideMode();
          }
        };
        ctrl.unhideAll = function () {
          ctrl.hiddenComponents.forEach(function (item) {
            if (item.partId === "") {
              item.ctrlWidget.cvWidget.SetVisibility(true);
            }
            else {
              item.ctrlWidget.cvWidget.SetPartVisibility(item.partId, true, true);
            }
          });
          ctrl.hiddenComponents = [];
        };
        ctrl.setAuthoringMode = function () {
          if (ctrl.mySession) {
            ctrl.mySession.DeselectAll();
            ctrl.mySession.AllowPartSelection(false);
          }
          ctrl.currentMode = 'authoring';
        };
        ctrl.setCompHideMode = function () {
          if (ctrl.mySession) {
            ctrl.mySession.DeselectAll();
            selectedWidget = null;
            ctrl.mySession.AllowPartSelection(true);
          }
          ctrl.currentMode = 'compHide';
        };

        // Get the Dragger Mode
        ctrl.getDraggerMode = function () {
          return ctrl.reposMode;
        };

        // Set the Dragger Mode
        ctrl.setReposMode = function (mode) {
          if (ctrl.reposMode === mode)
            mode = 'none';
          if (mode == 'translate' || mode == 'rotate') {
            ctrl.mySession.SetDragMode(Module.DragMode.DRAG);
          }
          else if (mode == 'mate') {
            ctrl.mySession.SetDragMode(Module.DragMode.MATE);
          }
          else {
            ctrl.mySession.SetDragMode(Module.DragMode.NONE);
          }
          ctrl.reposMode = mode;
        };

        // Zoom All
        ctrl.doZoomAll = function() {
          if (ctrl.mySession) {
            ctrl.mySession.ZoomView(Module.ZoomMode.ZOOM_ALL, 300);
          }
        };

        // Zoom Selected
        ctrl.doZoomSelected = function () {
          ctrl.mySession.ZoomView(Module.ZoomMode.ZOOM_SELECTED, 300);
        };

        // Zoom Selected if not already in the camera's view
        ctrl.doZoomSelectedIfNotInView = function () {
          ctrl.mySession.ZoomView(Module.ZoomMode.ZOOM_INCLUDE_SELECTED, 300);
        };

        // Add a Model to the Canvas
        ctrl.addModel = function (ctrlWidget, dropCoords) {
          getCvWidgetClasses();
          var widget = new cvModel();
          widget.ctrlWidget = ctrlWidget;
          widget.dropCoords = Boolean(dropCoords);
          widget.firstLoad = Boolean(dropCoords);
          ctrlWidget.cvWidget = widget;
          widget.modelItems = [];
          ctrl.mySession.AddModel(widget);
          widget.session = ctrl.mySession;
          if (dropCoords && Object.keys(ctrl.myWidgets).length > 1) {
            widget.dropCoords = dropCoords;
            ctrl.mySession.SetFloorPickable(true);
            widget.DoPick(dropCoords.x, dropCoords.y, true);
          }
          else {
            widget.LoadModel(ctrlWidget.designPropertyValues().src);
          }
          return widget;
        };

        // Add a Model Item to the Canvas
        ctrl.addModelItem = function (ctrlWidget, dropCoords) {
          getCvWidgetClasses();
          var widget = new cvModelItem();
          widget.ctrlWidget = ctrlWidget;
          widget.dropCoords = Boolean(dropCoords);
          ctrlWidget.cvWidget = widget;
          ctrl.mySession.AddModelItem(widget);
          widget.session = ctrl.mySession;
          if (dropCoords) {
            widget.DoPick(dropCoords.x, dropCoords.y, true);
          }
          else {
            var props = ctrlWidget.designPropertyValues();
            if (props.model) {
              if (ctrl.myWidgets[props.model]) {
                var cvModel = ctrl.myWidgets[props.model].cvWidget;
                cvModel.modelItems.push(widget);
                if (ctrl.myWidgets[props.model].loaded) {
                  ctrlWidget.cvWidget.SetModelAndIdPath(cvModel, props.idpath);
                  $rootScope.$broadcast('loaded3DObj', { ctrlWidget: ctrlWidget });
                }
              }
            }
          }
          return widget;
        };

        // Add an Image Marker to the Canvas
        ctrl.addImageMarker = function (ctrlWidget, dropCoords) {
          getCvWidgetClasses();
          var widget = new cvImageMarker();
          widget.ctrlWidget = ctrlWidget;
          widget.firstload = true;
          widget.dropCoords = Boolean(dropCoords);
          ctrlWidget.cvWidget = widget;
          ctrl.mySession.AddImageMarker(widget);
          widget.session = ctrl.mySession;
          if (dropCoords && Object.keys(ctrl.myWidgets).length > 1) {
            widget.dropCoords = dropCoords;
            ctrl.mySession.SetFloorPickable(true);
            widget.DoPick(dropCoords.x, dropCoords.y, true);
          }
          else {
            var props = ctrlWidget.designPropertyValues();
            if (props.url)
              widget.LoadFromURL(props.url);
            else if (props.src)
              widget.LoadFromURL(props.src);

            widget.size = { height: props.height, width: props.width ,scale:props.scale };
          }
          return widget;
        };

        // Add a Text Marker to the Canvas
        ctrl.addTextMarker = function (ctrlWidget, dropCoords) {
          getCvWidgetClasses();
          var widget = new cvImageMarker();
          widget.ctrlWidget = ctrlWidget;
          widget.firstload = true;
          widget.dropCoords = Boolean(dropCoords);
          ctrlWidget.cvWidget = widget;
          ctrl.mySession.AddImageMarker(widget);
          widget.session = ctrl.mySession;
          if (dropCoords && Object.keys(ctrl.myWidgets).length > 1) {
            widget.dropCoords = dropCoords;
            ctrl.mySession.SetFloorPickable(true);
            widget.DoPick(dropCoords.x, dropCoords.y, true);
          }
          else {
            var props = ctrlWidget.designPropertyValues();
            GenerateMarkupImage(widget, props);
          }
          return widget;
        };

        // Add a Combo Marker to the Canvas
        ctrl.addComboMarker = function (ctrlWidget, dropCoords) {
          getCvWidgetClasses();
          var widget = new cvImageMarker();
          widget.ctrlWidget = ctrlWidget;
          widget.firstload = true;
          widget.dropCoords = Boolean(dropCoords);
          ctrlWidget.cvWidget = widget;
          ctrl.mySession.AddImageMarker(widget);
          widget.session = ctrl.mySession;
          if (dropCoords && Object.keys(ctrl.myWidgets).length > 1) {
            widget.dropCoords = dropCoords;
            ctrl.mySession.SetFloorPickable(true);
            widget.DoPick(dropCoords.x, dropCoords.y, true);
          }
          else {
            var props = ctrlWidget.designPropertyValues();
            GenerateMarkupImage(widget, props);
          }
          return widget;
        };

      }
    };

    function getCvWidgetClasses() {
      // cvModel Class
      if (cvModel == undefined) {
        cvModel = Module.Model.extend("Model", {
          LoadModel: function (src) {
            this.AnimateTransitions(false);
            if (src && src.slice(-1) == "/") {
              if (!this.isPlaceHolder) {
                this.isPlaceHolder = true;
                this.LoadFromURL("images/vse-3d-model.ol", true, false);
              }
            }
            else {
              this.isPlaceHolder = false;
              this.LoadFromURL(src, true, false);
            }
          },
          OnLocationChanged: function () {
            $rootScope.$broadcast('move3DObj', { ctrlWidget: this.ctrlWidget, location: this.GetLocation() });
          },
          OnPartSelection: function (idPath, selected, type) {
            if (type == Module.SelectType.SELECT) {
              if (selected) {
                $rootScope.$broadcast('select3DObj', { ctrlWidget: this.ctrlWidget, partId: idPath });
              }
              else {
                $rootScope.$broadcast('deselect3DObj', { ctrlWidget: this.ctrlWidget, partId: idPath });
              }
            }
          },
          OnShapeInstanceSelection: function (shapeInstance, selected, type) {
            if (type == Module.SelectType.SELECT && selectedWidget != this.ctrlWidget) {
              if (selected) {
                $rootScope.$broadcast('select3DObj', { ctrlWidget: this.ctrlWidget, partId: "" });
              }
              else {
                $rootScope.$broadcast('deselect3DObj', { ctrlWidget: this.ctrlWidget, partId: "" });
              }
            }
          },
          OnAutoloadStructureLoaded: function () {
            this.loaded = true;
            this.AnimateTransitions(false);
            $rootScope.$broadcast('loaded3DObj', { ctrlWidget: this.ctrlWidget });
            if (this.firstLoad && !this.isPlaceHolder) {
              this.PlaceOnFloor();
            }
            var numItems = this.modelItems.length;
            for (var i = 0; i < numItems; i++) {
              var modelItemProps = this.modelItems[i].ctrlWidget.designPropertyValues();
              this.modelItems[i].SetModelAndIdPath(this, modelItemProps.idpath);
              this.modelItems[i].ctrlWidget.cvWidget = this.modelItems[i];
              $rootScope.$broadcast('loaded3DObj', { ctrlWidget: this.modelItems[i].ctrlWidget });
            }
          },
          OnLoadComplete: function () {
            if (this.firstLoad && !this.isPlaceHolder) {
              this.AnimateTransitions(false);
              this.PlaceOnFloor();
              $rootScope.$broadcast('loaded3DObj', { ctrlWidget: this.ctrlWidget });
            }
            $rootScope.$broadcast('readyForZoom3DObj', { ctrlWidget: this.ctrlWidget });
          },
          GetModelItemFromIdPath: function (idPath) {
            var numItems = this.modelItems.length;
            for (var i = 0; i < numItems; i++) {
              var modelItemProps = this.modelItems[i].ctrlWidget.designPropertyValues();
              if (modelItemProps.idpath == idPath)
                return this.modelItems[i];
            }
            return null;
          },
          OnPickComplete: function (position) {
            this.session.SetFloorPickable(false);
            var props = {};
            props.x = position.x.toFixed(4);
            props.y = position.y.toFixed(4);
            props.z = position.z.toFixed(4);
            if (props.y < 0.002 && props.y > -0.002)
              props.y = 0;
            this.ctrlWidget.setProps(props);
            this.LoadModel(this.ctrlWidget.designPropertyValues().src);
          },
          OnPickError: function () {
            this.session.SetFloorPickable(false);
            var loc = this.session.DoPickPlanes(this.dropCoords.x, this.dropCoords.y, true);
            if (loc.valid) {
              var props = {};
              props.x = loc.position.x.toFixed(4);
              props.y = loc.position.y.toFixed(4);
              props.z = loc.position.z.toFixed(4);
              this.ctrlWidget.setProps(props);
            }
            this.LoadModel(this.ctrlWidget.designPropertyValues().src);
          },
          OnUserPick: function (userData) {
            if (userData.type === "data-bind-hover") {
              this.session.DePreselectAll();
              this.session.PreSelectModel(this, true);
            }
            else if (userData.type === "data-bind-drop") {
              window.twx.widgetSelectCallback(this.ctrlWidget.widgetId, userData.resolveFn, userData.rejectFn);
            }
          },
          Select: function (sel) {
            this.session.SelectModel(this, true);
          },
          PlaceOnFloor: function () {
            var box = this.CalculateBoundingBox(new Module.VectorString());
            if (box.valid) {
              this.firstLoad = false;
              var location = this.GetLocation();
              var props = {};
              props.x = (2 * location.position.x) - ((box.min.x + box.max.x) / 2);
              props.y = (2 * location.position.y) - box.min.y;
              props.z = (2 * location.position.z) - ((box.min.z + box.max.z) / 2);
              this.ctrlWidget.setProps(props);
            }
          }
        });
      }
      // cvModelItem Class
      if (cvModelItem == undefined) {
        cvModelItem = Module.ModelItem.extend("ModelItem", {
          OnLocationChanged: function () {
            $rootScope.$broadcast('move3DObj', { ctrlWidget: this.ctrlWidget, location: this.GetLocation() });
          },
          OnSelection: function (selected, type) {
            if (type == Module.SelectType.SELECT && selectedWidget != this.ctrlWidget) {
              if (selected) {
                $rootScope.$broadcast('select3DObj', { ctrlWidget: this.ctrlWidget, partId: "" });
              }
              else {
                $rootScope.$broadcast('deselect3DObj', { ctrlWidget: this.ctrlWidget, partId: "" });
              }
            }
          },
          OnPickComplete: function (model, idPath) {
            if (idPath == "") {
              idPath = "/";
            }
            if (model.isPlaceHolder) {
              // Can't create a Model Item from a placeholder
              window.alert('You must drag and drop the Model Item onto a Model.');
              this.session.RemoveModelItem(this, false);
              this.ctrlWidget.remove();
              delete this.ctrlWidget;
            }
            else if (model.GetModelItemFromIdPath(idPath) != null) {
              // Can't create a Model Item on a pre-exisiting Model Item
              window.alert('A Model Item for this part already exists.');
              this.session.RemoveModelItem(this, false);
              this.ctrlWidget.remove();
              delete this.ctrlWidget;
            }
            else {
              model.modelItems.push(this);
              var location = this.GetLocation();
              var props = {};
              props.model = model.ctrlWidget.widgetId;
              props.idpath = idPath;
              props.x = location.position.x.toFixed(4);
              props.y = location.position.y.toFixed(4);
              props.z = location.position.z.toFixed(4);
              props.rx = location.orientation.x.toFixed(2);
              props.ry = location.orientation.y.toFixed(2);
              props.rz = location.orientation.z.toFixed(2);
              props.scale = location.scale.x.toFixed(4);
              props.visible = true;
              props.occlude = false;
              props.decal = false;
              props.opacity = 1;
              this.ctrlWidget.setProps(props);
              $rootScope.$broadcast('loaded3DObj', { ctrlWidget: this.ctrlWidget });
            }
          },
          OnPickError: function () {
            window.alert('You must drag and drop the Model Item onto a Model.');
            $rootScope.$broadcast('loadError3DObj', { ctrlWidget: this.ctrlWidget });
            this.ctrlWidget.remove();
            delete this.ctrlWidget;
          },
          OnUserPick: function (userData) {
            if (userData.type === "data-bind-hover") {
              this.session.DePreselectAll();
              this.session.PreSelectModelItem(this, true);
            }
            else if (userData.type === "data-bind-drop") {
              window.twx.widgetSelectCallback(this.ctrlWidget.widgetId, userData.resolveFn, userData.rejectFn);
            }
          },
          Select: function (sel) {
            this.session.SelectModelItem(this, true);
          }
        });
      }
      // cvImageMarker Class
      if (cvImageMarker == undefined) {
        cvImageMarker = Module.ImageMarker.extend("ImageMarker", {
          OnLocationChanged: function () {
            $rootScope.$broadcast('move3DObj', { ctrlWidget: this.ctrlWidget, location: this.GetLocation() });
          },
          OnSelect: function () {
            $rootScope.$broadcast('select3DObj', { ctrlWidget: this.ctrlWidget });
          },
          OnLoadComplete: function () {
            if (this.firstload) {
              this.LockAspectRatio(true);
              this.firstload = false;
              $rootScope.$broadcast('loaded3DObj', { ctrlWidget: this.ctrlWidget });
            }
          },
          OnPickComplete: function (loc, realGeometry) {
            this.session.SetFloorPickable(false);

            // hack - push marker forward a fraction to avoid z-fighting
            if (realGeometry) {
              loc.position.x += loc.orientation.x * 0.0002;
              loc.position.y += loc.orientation.y * 0.0002;
              loc.position.z += loc.orientation.z * 0.0002;
            }

            var props = {};
            props.x = loc.position.x.toFixed(4);
            props.y = loc.position.y.toFixed(4);
            props.z = loc.position.z.toFixed(4);

            var o = this.GetOrientationFromNormal(loc.orientation);
            props.rx = o.x.toFixed(2);
            props.ry = o.y.toFixed(2);
            props.rz = o.z.toFixed(2);
            if (props.y < 0.002 && props.y > -0.002)
              props.y = 0;
            if (realGeometry)
              props.billboard = false;
            this.ctrlWidget.setProps(props);
            this.FinishHandlingPick();
          },
          OnPickError: function () {
            this.session.SetFloorPickable(false);
            var loc = this.session.DoPickPlanes(this.dropCoords.x, this.dropCoords.y, true);
            if (loc.valid) {
              var props = {};
              props.x = loc.position.x.toFixed(4);
              props.y = loc.position.y.toFixed(4);
              props.z = loc.position.z.toFixed(4);
              var o = this.GetOrientationFromNormal(loc.orientation);
              props.rx = o.x.toFixed(2);
              props.ry = o.y.toFixed(2);
              props.rz = o.z.toFixed(2);
              this.ctrlWidget.setProps(props);
            }
            this.FinishHandlingPick();
          },
          FinishHandlingPick: function () {
            var props = this.ctrlWidget.designPropertyValues();
            if (this.ctrlWidget.widgetType() == '3D Image' ||
              this.ctrlWidget.widgetType() == 'ThingMark') {
              if (props.url)
                this.LoadFromURL(props.url);
              else if (props.src)
                this.LoadFromURL(props.src);
            }
            else
              GenerateMarkupImage(this, props);
          },
          OnUserPick: function (userData) {
            if (userData.type === "data-bind-hover") {
              this.session.DePreselectAll();
              this.session.PreSelectMarker(this, true);
            }
            else if (userData.type === "data-bind-drop") {
              window.twx.widgetSelectCallback(this.ctrlWidget.widgetId, userData.resolveFn, userData.rejectFn);
            }
          },
          Select: function (sel) {
            this.session.SelectMarker(this, true);
          },
          /**
           * DT-6223 Override LoadFromURL to handle "normal" images that are not in a native format (e.g. svg)
           * Let the parent class handle anything else. (e.g. bmp, png, jpeg)
           *
           * @param {string} url of an image, it could be bmp, png, jpeg, svg, etc.
           */
          LoadFromURL: function (url) {
            if (url.match(/.*\.svg$/)) {
              GenerateMarkupImage(this, { src: url });
            } else {
              // call LoadFromURL on the superclass
              this.__parent.LoadFromURL.apply(this, arguments);
            }
          },
          _ApplyHeightWidth: function () {
            if (this.size)
              SetHeightWidth(this, this.size);
          }
        });
      }
    }

  }

  function GetTextStyle(textAttrs) {

    var fallbackTextAttrs = {
      "font": "36px Arial",
      "fill": "rgba(120, 255, 200 , 1)",
      "stroke": "rgba(0, 0, 255, 1)"
    };

    var textStyle = {};

    if (textAttrs === undefined) {
      textStyle = fallbackTextAttrs;
    }
    else {
      var tmp = textAttrs.split(";");
      for (var i = 0; i < tmp.length; i++) {
        if (tmp[i]) {
          var inds = tmp[i].split(':');
          textStyle[inds[0].toLowerCase().trim()] = inds[1].trim();
        }
      }
    }

    if (textStyle.linewidth == undefined)
      textStyle.linewidth = 1;

    return textStyle;
  }

  function SetHeightWidth(widget, props) {
    if (Number(props.width) > 0 && Number(props.height) > 0) {
      widget.LockAspectRatio(false);
      widget.SetWidth(Number(props.width));
      widget.SetHeight(Number(props.height));
    }
    else if (Number(props.width) > 0) {
      widget.LockAspectRatio(true);
      widget.SetWidth(Number(props.width));
    }
    else if (Number(props.height) > 0) {
      widget.LockAspectRatio(true);
      widget.SetHeight(Number(props.height));
    }
    else {
      widget.LockAspectRatio(true);
      widget.SetHeight(Number(widget.GetNativeHeight()));
    }
    if (Number(props.scale) > 0) {
      widget.SetScaleWidth(Number(props.scale));
      widget.SetScaleHeight(Number(props.scale));
    }
    else {
      widget.SetScaleWidth(1.0);
      widget.SetScaleHeight(1.0);
    }
  }

  function GenerateMarkupImage(widget, props) {
    if (props.src == undefined || props.src.slice(-1) === '/') // Label or no image Gauge
      RenderImageAndText(widget, props, null);
    else {
      var image = new Image();
      image.onload = function () {
        RenderImageAndText(widget, props, image);
      }
      image.src = props.src;
    }
    widget.size = { height: props.height, width: props.width ,scale:props.scale };
  }

  function RenderImageAndText(widget, props, image) {

    var textStyle;
    if ("textprops" in props)
      textStyle = GetTextStyle(props.textprops);
    else
      textStyle = GetTextStyle(props.textattrs);

    if ("fontsize" in props && "font" in props) {
      textStyle.font = props.fontsize + " " + props.font;
    }

    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');

    // Set widget specific properties
    var textx = 0, texty = 0;
    var imagex = 0, imagey = 0;

    if (image && props.text) //Gauge
    {
      context.textBaseline = textStyle.textbaseline;
      context.textAlign = textStyle.textalign;
      adjustCanvasSize(props, canvas, context, image);
      textx = Number(props.textx);
      texty = Number(props.texty);
      imagex = Number(props.imagex);
      imagey = Number(props.imagey);
    }
    else if (props.text) { //Label
      context.font = textStyle.font;
      canvas.width = context.measureText(props.text).width;
      context.font = textStyle.font; // Setting width and height resets the font to default

      //Span as opposed to canvas gives out text height:
      var dummy = document.createElement("span");
      dummy.textContent = props.text;
      dummy.style = props.textprops;
      document.body.appendChild(dummy);
      canvas.height = dummy.offsetHeight;
      document.body.removeChild(dummy);

      textx = 0;
      texty = Number(canvas.height) / 2;
      textStyle.textalign = "start";
      textStyle.textbaseline = "middle";
    }
    else if (image) { //Image
      canvas.height = image.height;
      canvas.width = image.width;
      imagex = 0;
      imagey = 0;
    }

    // Draw image on canvas
    if (image) {
      context.drawImage(image, imagex, imagey);
    }

    // Draw text on canvas
    if (props.text) {
      context.font = textStyle.font;
      context.textAlign = textStyle.textalign;
      context.textBaseline = textStyle.textbaseline;

      if (textStyle.fill !== undefined) {
        context.fillStyle = textStyle.fill;
        context.fillText(props.text, textx, texty);
      }
      if (textStyle.stroke !== undefined) {
        context.strokeStyle = textStyle.stroke;
        context.lineWidth = textStyle.linewidth;
        context.strokeText(props.text, textx, texty);
      }
    }

    // Grab the imageData from the canvas
    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);

    // Send the imageData to the App
    var nDataBytes = imageData.data.length * imageData.data.BYTES_PER_ELEMENT;
    var dataPtr = Module._malloc(nDataBytes);
    var dataHeap = new Uint8Array(Module.HEAPU8.buffer, dataPtr, nDataBytes);
    dataHeap.set(new Uint8Array(imageData.data.buffer));
    widget.SetImage(dataHeap.byteOffset, imageData.width, imageData.height);


    // Free the imageData memory
    Module._free(dataHeap.byteOffset);
  }

  function adjustCanvasSize(props, canvas, context, image) {
    var width = 0;
    var height = 0;

    function adjustToImage() {
      var imagex = Number(props.imagex);
      if (width < image.width + imagex) {
        width = image.width + imagex;
      }
      var imagey = Number(props.imagey);
      if (height < image.height + imagey) {
        height = image.height + imagey;
      }
    }

    function adjustToText() {
      context.font = props.fontsize + ' ' + props.font;
      var textBasedWidth = Number(props.textx) + context.measureText(props.text).width + 3;
      if (width < textBasedWidth) {
        width = textBasedWidth;
      }

      var textBasedHeight = Number(props.texty) + context.measureText('MI').width;
      if (height < textBasedHeight) {
        height = textBasedHeight;
      }
    }

    switch (props.canvasgrowthoverride) {
      case 'canvas':
      {
        width = props.canvaswidth;
        height = props.canvasheight;
        break;
      }
      case 'image':
      {
        adjustToImage();
        break;
      }
      case 'text':
      {
        adjustToText();
        break;
      }
      case 'image+text':
      {
        adjustToImage();
        adjustToText();
        break;
      }
      default:
        break;
    }

    props.canvaswidth = width;
    props.canvasheight = height;

    canvas.height = height;
    canvas.width = width;
  }

  function resizeFloor(session, floorsize) {
    if (session && floorsize)
    {
      var size = 1.0;
      var pos = { x: 0, y: -0.0001, z: 0 };
      var bbPos = pos;
      var bounds = session.GetWorldBoundingBox();
      if (bounds.valid) {
        var x = bounds.max.x - bounds.min.x;
        var y = bounds.max.y - bounds.min.y;
        var z = bounds.max.z - bounds.min.z;

        bbPos.x = bounds.min.x + (x / 2);
        bbPos.y = bounds.min.y - y / 4.0;
        bbPos.z = bounds.min.z + (z / 2);

        var margin = Math.sqrt((x * x) + (y * y) + (z * z)) * 4;
        size = Math.sqrt((bbPos.x * bbPos.x) + (bbPos.y * bbPos.y) + (bbPos.z * bbPos.z)) * 2 + margin;

        //        pos.y = bbPos.y > -0.0001 ? -0.0001 : bbPos.y;
        // PJM just lock the height of the floor, for now
        pos.y = -0.0001;

        // PJM set a minimum floor size, otherwise it shrinks on adding a thingmark to an empty view
        if (size < 1.0)
          size = 1.0;
      }
      if ((Math.abs(bbPos.x - floorsize.pos.x) > floorsize.size / 4.0) ||
          //     (Math.abs(bbPos.y - floorsize.pos.y) > floorsize.size / 4.0) ||
        (Math.abs(bbPos.z - floorsize.pos.z) > floorsize.size / 4.0) ||
        (Math.abs(size - floorsize.size)  > floorsize.size / 4.0)) {
        floorsize.size = size;
        floorsize.pos = pos;
        session.ShowFloorWithSize(true, size, size, pos, 0x80808080, 0x80808080, "Y");
      }
    }
  }

}());
