'use strict';

const debug = require('debug')('ar-extension:upgrade');
const fs = require('fs-extra');
const path = require('path');
const semver = require('semver');

/**
 * Converts the given version, which could be a number (i.e. 1.4) or a string ('1.4.0'), to a semantic version string.
 * 1.4, '1.4', and '1.4.0' would all be returned as '1.4.0' .
 * @param version
 */
function toSemanticVersion(version) {

    /**
     * Converts the given version, which could be a number (i.e. 1.4) or a string ('1.4.0'), to an array (i.e. [1, 4, 1])
     *
     * @param version
     * @returns {Array}
     */
    function toArray (ver) {
        const v =  (ver || "0.0.0").toString().split(".");

        // if it's not a 3 digit version number, fill in the remaining digits with zero's
        while(v.length < 3) {
            v.push('0');
        }

        // convert the array to be an array of Numbers since the given version might be a number or it might be a string
        // we'll convert all the items in the array to Numbers
        return v.map(Number);
    }

    /**
     * @param vArray An array where each part of the version is in it's own element in the array, 1.4 would be [1,4,0]
     * @returns {string} A string that represents the values in the given array, [1,4,0] would be returned as '1.4.0'.
     */
    function toString(vArray) {
        var v = "";
        Object.keys(vArray).forEach(function (index) {
            v += (v.length > 0) ? ("." + vArray[index]) : vArray[index];
        });

        return v;
    }

    return toString(toArray(version));
}

/**
 * @returns {string} The version of this package. On a dev env when the package is linked in, the version in the
 *                     package.json will be 0.0.0, in this case the latest version that's published will be returned.
 */
function getPackageVersion() {
    // read-in the package.json for this extension
    const packageJson = require(path.join('../..', 'package.json'));
    var pkgVersion = packageJson.version || '0.0.0';
    if(pkgVersion === '0.0.0') {
        // in a dev env the version will be set to 0.0.0 when the package is linked in, in this case
        // check for env variable or the latest version of this package that's published
        debug('Version was \''+packageJson.version+'\'. Assume dev env.');
        if(process.env.AR_EXTENSION_VERSION_OVERRIDE) {
            pkgVersion = process.env.AR_EXTENSION_VERSION_OVERRIDE;
            debug('Using process.env.AR_EXTENSION_VERSION_OVERRIDE', pkgVersion);
        } else {
            const shell = require("shelljs");
            const cmd = 'npm show ' + packageJson.name + ' version';
            debug('Check for latest published version with command: \'' + cmd + '\'');
            if(debug.enabled) {console.time('shell.exec time');}
            const execResult = shell.exec(cmd, {silent:true});
            if(debug.enabled) {console.timeEnd('shell.exec time');}
            pkgVersion = execResult.stdout.replace(/\n/g, "");
        }
    }

    return pkgVersion;
}

const currentVersion = getPackageVersion();
console.log('ar-extension version', currentVersion);

/**
 * Sort the version handlers by version
 * @param upgradeHandlers Array of file names with version info
 */
function sortHandlers(upgradeHandlers) {
  upgradeHandlers.sort(function(a,b) {
    const a_handler = require('./upgradeHandlers/' + a);
    const b_handler = require('./upgradeHandlers/' + b);
    if(semver.lt(a_handler.version, b_handler.version)) {
      return -1;
    }
    return 1;
  });
}
/**
 * @param {object} params - config object that is expected to have
 *        path - path to the project
 *        settings - the project settings
 *        alwaysUpgrade - flag that might have been set in project settings or in builder settings
 * @return true if an upgrade is needed for the given project, false otherwise
 */
function isUpgradeNeeded(params) {
    const settings = params.settings;
    const validProjectTypes = ['ar', 'AR', '2D', 'desktop', 'eyewear'];
    const isExpectedProjectType = (validProjectTypes.includes(settings.projectType));
    if(!isExpectedProjectType) {
        debug('Project type was not one of the expected types. Assume no upgrade needed.', settings.projectType);
        return false;
    }
    const version = toSemanticVersion(settings.version);  // convert the project's version to a semantic version (i.e. '1.4.0')
    if(params.alwaysUpgrade || semver.lt(version, currentVersion)) {
        debug('Upgrade needed. Current version', currentVersion, ', new version', version);
        if(params.alwaysUpgrade) {debug('alwaysUpgrade=true');}
        return true;
    }
    else {
        debug('No upgrade needed per version check: ', version, currentVersion);
    }
    // using the OOTB .gitignore, only the src/ & appConfig.json would be checked in, so if other dirs are missing,
    // assume this project is a git repo that needs an upgrade to restore all the necessary OOTB files
    if(!fs.existsSync(params.path + '/css') || !fs.existsSync(params.path + '/theme') || !fs.existsSync(params.path + '/extensions')) {
        debug('Required artifacts are missing, upgrade to restore them.');
        return true;
    }

    return false;
}

/**
 * Creates a promise to upgrade project to latest version.
 *
 * The version sequence for this project is: undefined, 1, 1.3, 1.4, 1.5, 1.6.2, 1.7.<build_number_from_go>
 *
 * @param params
 * @returns {promise} a promise resolved when all upgrade work is complete, or rejected if there is any error during upgrade
 */
function onupgrade(params) {
    const promise = new Promise(function(resolve, reject) {
        if (isUpgradeNeeded(params)) {
            const log = params.logger;
            const settings = params.settings;
            const version = toSemanticVersion(settings.version);  // convert the project's version to a semantic version (i.e. '1.4.0')
            log.info('Upgrading project', settings.name, params.path, 'from', version, 'to', currentVersion);

            /**
             * Removes the given file synchronously and logs message to upgrade.log
             * @param {string} relativePath path relative to project dir such as '/.gitignore'
             */
            params.removeSync = function(relativePath) {
                const filePath = params.path + relativePath;
                if(fs.existsSync(filePath)) {
                    log.debug('Removing ', filePath);
                    fs.removeSync(filePath);
                }
            };

            // Call each handler's onupgrade func if current project version is less than handler's version (or if alwaysUpgrade=true)
            const upgradeHandlers = fs.readdirSync(__dirname + '/upgradeHandlers/');
            sortHandlers(upgradeHandlers);

            upgradeHandlers.forEach(function(upgradeHandler) {
                const handler = require('./upgradeHandlers/' + upgradeHandler);
                if(semver.satisfies(version, handler.range) || params.alwaysUpgrade) {
                    handler.onupgrade(params, log);
                }
            });

            log.debug('Make sure there are not any stale files lying around');
            ['/css/',
                '/dist/',
                '/extensions/',
                '/preview3d/',
                '/preview3d-old/',
                '/src-scaffold/',
                '/stage/',
                // always remove Default resources so defaultProjectCopyScaffold will copy over the latest
                '/src/phone/resources/Default/',
                '/theme/'].forEach(params.removeSync);

            params.defaultProjectCopyScaffold().then(function() {
                log.debug('Updating version to ', currentVersion);
                settings.version = currentVersion;
                if (params && params.projectConfig && params.projectConfig.defaultResourcesPath) {
                    log.debug('Copying project specific default resources.');
                    fs.copySync(path.join(params.projectConfig.defaultResourcesPath, 'src'), path.join(params.path, 'src'), {preserveTimestamps: true, overwrite: true});
                }
                resolve(settings);
            }, reject);
        } else {
            resolve(params.settings);
        }
    });
    return promise;
}

module.exports = {
    isUpgradeNeeded: isUpgradeNeeded,
    onupgrade: onupgrade,
    currentVersion: currentVersion,
    _sortHandlers: sortHandlers
};
