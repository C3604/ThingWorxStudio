# ThingBrowser Reference Sheet

This document outlines the current implementation of TML, and includes the next set of actions to clean the spec up and to head towards the complete TML spec, this is defined [here](https://pds.ptc.com/Windchill/app/#ptc1/tcomp/infoPage?oid=VR%3Awt.doc.WTDocument%3A1242116634)

All the data on the AR view is to be declared in the DOM.  Here is an example:

```
<twx-dt-view>
  <twx-dt-tracker>
    <twx-dt-target id="target1" src="vuforia-image:///DB2?id=T1" size="0.05">
      <twx-dt-3dobject id="static"
             vertices="TEAPOT.teapotVertices"
             normals="TEAPOT.teapotNormals"
             texcoords="TEAPOT.teapotTexCoords"
             indexes="TEAPOT.teapotIndices"
             color="[0.5,0.5,0.5,1]"
             x="0" y="0" z="0"
             rx="0" ry="0" rz="0"
             sx="3" sy="3" sz="3"></twx-dt-3dobject>
    </twx-dt-target>
  <twx-dt-tracker>
</twx-dt-view>
```

# HTML5 DOM
The player (browser) is comprised of four primary layers. At the base is a native application which has access to native device capabilities such as 3d graphics, sensors etc..
A javascript API exposes the device capabilities to the application layer, which runs html5 and AngularJS in the browser control.  In between the app (js) and the native service we have two rendering layers - a 3d layer and above that a transparent html (2d) layer. When AR tracking is enabled, the device layer will display the view from the device camera.  The 3d content is displayed above this, and the 2d html is displayed on top.

Building an AR application is as easy as declaring the scene in HTML.  Starting with an <twx-dt-view> container, we define the characteristics of the AR tracking (the ID of the tag to be tracked etc.) and then we define the computer-generated content that is to be inserted in the scene. This content can be positioned relative to a tracking object.  The player supports multiple trackers, each of which can contain multiple targets - a useful feature for larger items or items where you would like the tracking experience to continue when the object changes aspect to the camera e.g. you walk around the other side of a vehicle.  Separate trackers allows separately tracked items within the same scene.

The runtime emits events that can be used to interact with the scene; tracking targets emit events defining which is being tracked - in future revisions, 'click' events are emitted if the user taps on a visual element - the model is the same as any standard 2d web app development experience, but extended into the 3d realm via the extension API.


# The AR View
The AR View is the main workspace of the AR author.  This area will combine the current 2D TWX experience with 3D support.
The AR View in the editor aims to represent the device space although it is not required to have WYSIWYG support in this view (a preview mode will be implemented as future requirement).

## `<twx-dt-view>`
The AR View is represented in the DOM with the tag `<twx-dt-view>`.  Its attributes will also be reflected in the DOM

### Attributes:
* _maxtracking_: how many image-based targets can be tracked concurrently (as per Vuforia functionality)
* _extendedtracking_: when set to true (the default), the Vuforia toolkit will use the extended tracking (SLAM) algorithm based on image trackers, i.e. it tracks the camera background surrounding the targets in addition to the targets.  Extended tracking assumes the targets are fixed wrt to the background, so set this to false if your Xperience intends to be supporting moving objects
* _persistmap_: if true, cache the SLAM map
* _near_: distance to the near clipping plane, in model units (meters, by default)
* _far_: distance to the far clipping plane.

## `<twx-dt-tracker>`
A tracker is effectively a tracked space / coordinate system, the location of which is defined by the marker elements within e.g. if you wanted to track an object from the left and right, you could use two markers, one facing left, one facing right.  Items declared within the scope of the tracker are positioned relative to the markers within that same scope.  For example:

```
  <twx-dt-tracker id="track1">
    <twx-dt-target id="m1"></twx-dt-target>
    <twx-dt-target id="m2"> </twx-dt-target>
    <!-stuff attached to m1,m2 -->
  </twx-dt-tracker>
  <twx-dt-tracker id="track2">
    <twx-dt-target id="m3"></twx-dt-target>
    <!-stuff attached to m3-->
  </twx-dt-tracker>
```

In this example, track1 and track2 are independently trackable items; within track1, there are two tracking targets that can be used to lock onto the object.

### Attributes
* _id_: unique identifier of the tracker
* _enabletrackingevents_: flag, when set initially as "true", to enable a "tracking" event fired on this element
* _stationary_: a hint that is passed down to the view client to optimize tracking. This attribute defaults to true. When true it means that the tracker will not move in real space. When false it means that the tracker could move in real space.

### Events
* _tracking_:  the system is tracking any target of this tracker. targetName, position, up, and gaze properties in the event data, where targetName is the name of the target being tracked within this tracker and the rest are arrays of eye position, up vector, and gaze factor.


## `<twx-dt-target>`
An AR target can be an image, VuMark (thingcode), frame marker.  The target can be positioned in 3D space and is used by the ThingBrowser to position the 3D Camera relative to the scene.  A Target is placed at a known specific location on a Reference Model.

The Target acts as a container for a collection of assets.  When the system can _see_ (i.e., track the target), it will render the assets it contains on the device's screen.   The Player fires events on the `<twx-dt-target>` allowing the application to know whether a target is tracked or lost tracking.

A target is represented in the DOM with the tag `<twx-dt-target>`.  Its attributes will also be reflected in the DOM.

### Attributes
* _id_: unique identifier of the target
* _src_: source of the target in a URL in these formats:
  * Image Target: vuforia-image://[path to data set]?id=[name], where name is the image target name in the data set. If path to the data set is relative to the base URL of the enclosing TML, it should start with "/".  The path should not have any extension. For example: src="vuforia-image:///DB2?id=T1" or src="vuforia-image://www.ptc.com/datasets/DB2?id=T1".
  * Thing Code: vuforia-vumark://[path to the data set]?id=[domain id]:[instance id], where both ids are in decimal without leading 0. Path to the data set is the same as for image targets.
* _x, y, z_: positional offset of the target in this trackers coordinate frame
* _rx, ry, rz_: rotations offset (Euler angles, in degrees) of the target
* _size_: size (width) of the target in model units (meters)
* _istracked_: Indicates the target is either being or not being tracked. The value of this property is set by the infrastructure and is not to be modified by the user.

### Events
* _trackingacquired_: the system sees and begins to track the target's location. Metadata of the target in the cloud database may be included as json in 'detail' attribute of the event data.
* _trackinglost_: the system can no longer track the target's location. Metadata of the target in the cloud database may be included as json in 'detail' attribute of the event data.

## `<twx-dt-model>`
The Model Widget is a 3D geometry that represents an Asset or part in the AR view.

### Attributes
* _id_: unique identifier of the asset
* _src_: source of the model definition (a pvs/ol/pzv file)
* _x, y, z_: position
* _rx, ry, rz_: orientation (degrees) about x,y,z axes
* _sx, sy, sz_: scale
* _cull_: set to false if you have model data that includes non-manifold/quilt surfaces that need to be renderer double sided. default (if omitted) is true i.e. backfacing polygons are automatically culled
* _sequence_: a url reference to a creo illustrate sequence (.pvi) file.
* _play_: if true, specified sequence will play the next step
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _phantom_: when set to true, the model will mask the other 3D assets that appear behind it, and will display its inner parts semi-transparently as per the _opacity_ attribute
* _force-hidden_: when set to true, the model and its children will not be rendered, this implies that any child of the model with a value of false does not get rendered.
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

### Events
* _modelloaded_: triggered when the specified model as successfully been downloaded, parsed, and loaded into the scene graph

### Todo:
* change _hidden_ to _style.visibility=hidden|visible|initial|disabled_
* change _modelloaded_ to _ModelLoaded_
* add _ModelLoadFailed_ event

### Example
Example 8

## `<twx-dt-modelitem>`
The Model Item Widget is a 3D geometry that represents an component of an `<twx-dt-model>`.

### Attributes
* _occurrence_: unique identifier of the model item as defined in the PVS structure
* _for_: specify the id of the model to which this item belongs. If ommitted, the parent id is assumed.
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation (degrees) about x,y,z axes
* _sx, sy, sz_: scale in xyz
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _phantom_: when set to true, the model item will mask the other 3D assets that appear behind it, and will display its inner parts semi-transparently as per the _opacity_ attribute
* _force-hidden_: when set to true, the model item and its children will not be rendered, this implies that any child of the model item with a value of false does not get rendered.
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"
* _color_: RGBA color to be applied to specified component in format of "rbga(r, g, b, a);", where r, g, b are integers within [0, 255] and a is a float number within [0, 1].

### Example
Example 8

## `<twx-dt-label>`
The Text Widget renders a text string in 3D.

### Attributes
* _id_: unique identifier of the asset
* _text_: text to be rendered
* _textattrs_: rendering properties of the text in the format [property:value;] e.g. "font:46px Arial;stroke:#0000FF;fill:yellow", where:
  * _font_: font property in CSS style (default: "36px Arial")
  * _stroke_: color of the text outline (default: "rgba(0, 0, 255, 0)")
  * _linewidth_: width of the text outline (default: 1)
  * _fill_: color of the text fill
  * _background-color_: rgb color to fill in the background behind the text.
  * _opacity_: applies to background.  0..1 (0 = fully transparent)
  * _textalign_: horizontal position of the reference point relative to the text block e.g. left, right, center
  * _textbaseline_: vertical position of the reference point relative to the text block e.g. hanging, middle, etc.
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation (degrees) about x,y,z axes
* _sx, sy, sz_: scale in xyz
* _width_ : physical width of the text in meters; if not specified and height is, will be calculated according to canvaswidth/canvasheight aspect ratio of the underlaying canvas. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _height_ : physical height of the text in meters; if not specified and width is, will be calculated according to canvaswidth/canvasheight aspect ratio of the underlaying canvas. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _pivot_  : enum defining the pivot point for the text block. 1=top left,2 top center,3 top right. Default is 5 (center,middle)
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

### Example
Examples 5,6,7,9

### Todo:
* add _align=left|right|centre_ to define anchor point/center of rotation

## `<twx-dt-image>`
The Image Widget renders a PNG or JPEG image in 3D.

### Attributes
* _id_: unique identifier of the asset
* _src_: link to the image to be rendered. if a leadline is required, a second image can be specified (see section on multi-texturing)
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation in x,y,z
* _sx, sy, sz_: scale in xyz
* _width_ : physical width of the image in meters; if not specified and height is, will be calculated according to image's aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _height_ : physical height of the image in meters; if not specified and width is, will be calculated according to image's aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _pivot_  : enum defining the pivot point for the text block. 1=top left,2 top center,3 top right. Default is 5 (center,middle)
* _leaderx, leadery_: position of (optional) leaderline endpoint. Endpoint is assumed to be second texture.
* _anchorType_: specifies the quadrant in which the leg of the leaderline is placed.  If not specified, the quadrant is computed dynamically.
* _endpoint_ : if specified, the texture/image to use as the endpoint of the leaderline
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

### Todo:
* change from _anchorType_ to _quadrant_
* change from using lowlevel texture to having specific _endpoint_ attribute which, if specified, draws endpoint

### Example
Examples 5,6,7,9

## `<twx-dt-sensor>`
The Sensor Widget formats an image and a text block on a rectangle and renders it in 3D.

### Attributes
* _id_: unique identifier of the asset
* _canvaswidth_: width in pixels of the rectangle to use as canvas
* _canvasheight_: height in pixels of the rectangle to use as canvas
* _text_: text to be rendered
* _textattrs_: rendering properties of the text in the format [property:value;] e.g. "x:0;y:0;font:46px Arial;stroke:#0000FF;fill:yellow", where:
  * _x_: horizontal position of the text in the 2D rectangle
  * _y_: vertical position of the text in the 2D rectangle
  * _font_: font property in CSS style (default: "36px Arial")
  * _stroke_: color of the text outline (default: "rgba(0, 0, 255, 0)")
  * _linewidth_: width of the text outline (default: 1)
  * _fill_: color of the text fill
  * _textalign_: horizontal position of the reference point relative to the text block e.g. left, right, center
  * _textbaseline_: vertical position of the reference point relative to the text block e.g. hanging, middle, etc.
* _src_: image to be rendered (png, jpeg, or svg)
* _imageattrs_: rendering properties of the text in the format [property:value;] e.g. imageattrs="x:0;y:0;width:128;height:128", where:
  * _x_: horizontal position of the image in the 2D rectangle
  * _y_: vertical position of the image in the 2D rectangle
  * _width_: horizontal size of the image in the 2D rectangle
  * _height_: vertical size of the image in the 2D rectangle
* _canvasgrowthoverride_: specifies how the display element behaves; options are canvas|image|text|image+text.  e.g. if set to 'text', the width of the canvas is defined by the width of the text string. If set to 'image', the width would be defined by an image component - any text component could be clipped if wider than the image. the default is canvas, using the width,height attributes.
* _leaderx, leadery_: position of (optional) leaderline endpoint.
* _anchorType_: specifies the quadrant in which the leg of the leaderline is placed.  If not specified, the quadrant is computed dynamically.
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation in x,y,z
* _sx, sy, sz_: scale in xyz
* _width_ : physical width of the sensor in meters; if not specified and height is, will be calculated according to canvaswidth/canvasheight aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _height_ : physical height of the sensor in meters; if not specified and width is, will be calculated according to canvaswidth/canvasheight aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _width_ (height being proportional) or _height_ (width being proportional) : physical size of the image
* _pivot_  : enum defining the pivot point for the text block. 1=top left,2 top center,3 top right. Default is 5 (center,middle)
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

### Todo:
* change from _anchorType_ to _quadrant_
* add leaderx,y and quadrant (see '<twx-dt-image>' )

### Example
Example 7

## `<twx-dt-svg>`
The ARSVG Widget renders the  SVG element it contains on a rectangle and renders it in 3D.
SVG restrictions: In order to be able to render the SVG onto a canvas, the following restrictions generally apply:

* Image elements are not supported
* Animations are not supported
* Any foreignitem sub-element e.g. html blocks are not supported
* any external references e.g. to style sheets, are not supported.  Styling will have to be applied inline

### Attributes
* _id_: unique identifier of the asset
* _canvaswidth_: width in pixels of the rectangle to use as canvas
* _canvasheight_: height in pixels of the rectangle to use as canvas
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation in x,y,z
* _sx, sy, sz_: scale in xyz
* _width_ : physical width of the sensor in meters; if not specified and height is, will be calculated according to canvaswidth/canvasheight aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _height_ : physical height of the sensor in meters; if not specified and width is, will be calculated according to canvaswidth/canvasheight aspect ratio. If neither width nor height is specified a default 1px = 1mm phsyical size conversion will be used.
* _pivot_  : enum defining the pivot point for the text block. 1=top left,2 top center,3 top right. Default is 5 (center,middle)
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

#Advanced functionality

## Shaders
Shaders are defined in `<script>` nodes.  The syntax of the shader is standard GLSL.
Shaders are built up from two scripts, the vertex shader and fragment shader, both which are specified in html `<script>` elements in the page.

```
    <script name="fractal" type="x-shader/x-vertex">
  // shader code goes here
    </script>
    <script name="fractal" type="x-shader/x-fragment">
  // shader code goes here
    </script>
```

Along with a set of standard parameters, attributes can defined in the html DOM and are passed to the shaders.  The standard parameters include:

```
  uniform vec3 worldMin, worldMax;
  uniform vec3 boundsMin, boundsMax;
  uniform mat4 modelViewProjectionMatrix;
  uniform mat4 modelViewMatrix;
  uniform int primitiveType;
  uniform int tick;
```

and from the 3d data:

```
  attribute vec4 vertexPosition;
  attribute vec4 vertexNormal;
  attribute vec2 vertexTexCoord;
  uniform vec4 surfaceColor;
  uniform float transparency;
```

and any property defined in the HTML.

## Multi-texturing
Textures must be square powers of 2 e.g. 128, 512 for the edge clamping and filtering options to work. Texture options (edge and filter) are described in the declaration, e.g.:

```
texture = "marble.png?edge=clamp&filter=nearest&name=marble"
```

the properties described after the ? are used to refine how the images are presented:

* _edge_: clamp|repeat|mirror - defines what happens once the edge of an image is readed; if a small image is applied to a large surface, setting edge=repeat would see the image repeated again and again across the surface.
* _filter_: linear|nearest - defines how the image is sampled; if image is square and a power-of-2 in sizes along the edges, texture filtering (MIP-MAPPING) is supported, and the filter setting will use  the MIP MAP to attempt to smooth out any aliasing / fringing artifacts.
* _name_: the name of the texture sampler that is passed to the shader. The default, if omitted, is texSampler2D, textSampler2D1 etc.

Multiple textures can be supplied as a space-separated list:

```
  <twx-dt-3dobject id = "big marble teapot"
               vertices = "TEAPOT.teapotVertices"
              texcoords = "TEAPOT.teapotTexCoords"
                indices = "TEAPOT.teapotIndices"
                 shader = "fractal;steps i 60"
                texture = "marble.png?edge=repeat&name=marble
                           normals.png&name=normalmap
                           palette.png?filter=nearest&name=palette">
  </twx-dt-3dobject>
```

where marble, normalmap and palette are 3 texture definitions which are delivered to that shader.
`<twx-dt-image>` follows the same model for the image attribute.

The shader would look like this:

```
  uniform sampler2d  palette;
  uniform sampler2d normalmap;
  uniform sampler2d marble;
  uniform float steps;
```

# Not for public release at this time

## `<twx-dt-3dobject>`
A means of defining inline functional graphical definition, either declaratively or through javscriot.

### Attributes
* _id_: unique identifier of the asset
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation in x,y,z
* _sx, sy, sz_: scale in xyz
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"
* _vertices_ - an array of {xyz} values that forms the 3d coordinates of the shape
* _normals_ - an array of {uvw} values that forms the vertex normals of the shape
* _texcoords_ - an array of {st} values that forms the texture coordinates of the shape
* _indexes_ - an array of index offsets that reference values in the vertex/normal/texture buffers.
* _color_ - "r,g,b,a" color, values specified in the range 0..1
* _texture_ - name of texture/image map to apply.  This is a file reference. Textures must be square powers of 2 e.g. 128, 512 for the edge clamping and filtering options to work. Texture options (edge and filter) are described in the declaration, e.g.:

```
texture = "marble.png?edge=clamp&filter=nearest&name=marble"
```

the properties described after the ? are used to refine how the images are presented:

  * _edge_: clamp|repeat|mirror - defines what happens once the edge of an image is readed; if a small image is applied to a large surface, setting edge=repeat would see the image repeated again and again across the surface.
  * _filter_ : linear|nearest - defines how the image is sampled; if image is square and a power-of-2 in sizes along the edges, texture filtering (MIP-MAPPING) is supported, and the filter setting will use  the MIP MAP to attempt to smooth out any aliasing / fringing artifacts.
  * _name_: the name of the texture sampler that is passed to the shader. The default, if omitted, is texSampler2D, textSampler2D1 etc.

### Todo
* change from _image_ to _src_
* change _vertices_ etc. to child block

### Example
bikedemo

## `<twx-dt-emitter>`
A source of particles that follow a standard Newtonian physics model, the position of a particle being a function of mass and velocity under the influence of gravitational and environmental forces.  The source of the particle emitter is a unit radius circle positioned at the position {x,y,z} coordinate, rotated and scaled accordingly.  Gravity is limited to being a vertical acceleration, but the constant 'wind' force can be defined in any direction.

### Attributes
* _id_: unique identifier of the asset
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation (degrees) about x,y,z axes
* _sx, sy, sz_: scale in xyz
* _particles_ - the number of particles in the system. Default is 1000
* _velocity_ - the initial speed (metres/second at unit scale). Particles are assigned a random velocity between 0 and this value.
* _spread_ - (0..180) the angular spread of the conic emitter - launch vectors are randomised based on this value.
* _decay_ - the cycle time for the particle system; all particles will fade and are renewed within this time.
* _rate_ - the rate of emission [note, its not technically a rate, more the launch window].  For example, if decay=10, rate=2, the particles will appear to pulse from the emitter within 2 seconds, and will decay for 10 seconds total lifetime (per particle)
* _blend_ - if true, particle values accumulate instead of overwrite.  Useful for "glowing" effects e.g. fire
* _gravity_ - default is -9.8m/s2, this is the gravitational acceleration that all particles undergo.  Setting gravity to a positive number is a great way to have particles float e.g. smoke effects.
* _wind_ - a vector declaring wind speed (m/s) in x,y,z components.  Default is [0,0,0]
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"

### Example
Example 19

## `<twx-dt-leaderline>`
The leaderline construct allows a line to have 1 end positioned in 2d screen space and the other positioned in 3d space.

### Attributes
* _id_: unique identifier of the asset
* _x, y, z_: position in xyz
* _rx, ry, rz_: orientation in x,y,z
* _sx, sy, sz_: scale in xyz
* _hidden_: when set to true, the object will be hidden
* _opacity_: sets the asset's opacity factor for rendering (1 = opaque, 0 = fully transparent)
* _decal_: when set to true, the asset will appear on top of other 3D assets in the scene
* _occlude_: when set to true, the asset will mask the other 3D assets that appear behind it, and show the camera feed instead
* _billboard_: when set to true, the object will rotate to face the user while remaining aligned with the target's horizontal baseline
* _shader_: controls the appearance of the object.  if ommited, objects use a default lighting & appearance model
* _class_: specifies the class to used for CSS styling
* _style_: local override of style settings e.g. style="opacity:0.5;shader:fractal"
* _color_ : "r,g,b,a" color, values specified in the range 0..1
* _nbScreenCoord_ - number of coordinates that are positioned on the 2d screen. The remaining vertices are positioned in 3d space
* _vertices_ : list of vertices.  The first N are 2d {x,y} vertices as defined by nbScreenCoord.  The remainder are {xyz} 3space coordinates.
* _texture_ : the image to be projected at the 3d end of the leaderline.  The size of the image is defined by the pointsize attribute.
* _endpoint_ : if specified, the texture/image to use as the endpoint of the leaderline
* _pointSize_ size (in pixels) of the endpoint of the leaderline
* _linewidth_ - width (in pixels) of the leaderline

### Todo:
* change from using lowlevel texture to having specific _endpoint_ attribute which, if specified, draws endpoint

### Example
Example 20


---
# Reference
The origin of this document can be found in [PDS](https://pds.ptc.com/Windchill/app/#ptc1/tcomp/infoPage?oid=VR%3Awt.doc.WTDocument%3A1252470150)
