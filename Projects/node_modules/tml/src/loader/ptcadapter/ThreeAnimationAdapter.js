/* begin copyright text
 *
 * Copyright Â© 2016 PTC Inc., Its Subsidiary Companies, and /or its Partners. All Rights Reserved.
 *
 * end copyright text
 */
/* globals: PTC, THREE */
PTC.ThreeAnimationAdapter = function (aScene) {
    "use strict";
    var SCENE = aScene;

    /*
    function getScene()
                returns the active Scene or group
    */
    function getScene()
    {
        return SCENE;
    }

    // UTILITIES:  used when acting on selected

    /*
    function getSelectedObjects(idpath)
                    var idpath the CV idpath to the specific instance of a part or assembly
                    returns = an array of the parts, which may be group
    */
    function getSelectedObjects(idpath) {
        return getObjectsByName(getScene(), 'name', idpath);
    }

    /*
    function getSelectedObject(idpath)
                    var idpath the CV idpath to the specific instance of a part or assembly
                    returns = the part, which may be group
    */
    function getSelectedObject(idpath) {
        return getObjectByName(getScene(), idpath);
    }

    /*
    function getGeometryByPath(idpath)
                    var idpath the CV idpath to the specific instance of a part or assembly
                    returns = the mesh(es) that graphically constitute the part or parts of the path is a parent assembly
    Note: as this may be an assembly, we need to traverse all children recursively
    */
    function getGeometryByPath(idpath) {
        var meshes = [];
        var match = getObjectByName(getScene(), idpath);
        getChildMeshes(match, meshes);
        return meshes;
    }

    function getChildMeshes(obj, meshes) {
        for ( var i=0; i < obj.children.length; i++) {
            var object = obj.children[i];
            if ( object instanceof THREE.Mesh ) {
                meshes.push(object);
            }
            else if ( object.children !== undefined && object.children.length !== 0 ) {
                getChildMeshes(object, meshes);
            }
        }
    }

    /*
    function getObjectByName (obj, idpath )
        var obj is the Scene
        idpath the path of an assembly or component
        returns: matching object
    */
    function getObjectByName( obj, idpath ) {
        if ( obj.name === idpath ) {
            return obj;
        }
        for ( var i = 0; i < obj.children.length; i ++ ) {
            var found = getObjectByName( obj.children[ i ], idpath);
            if ( found !== null && found !== undefined)  {
                return found;
            }
        }
        return null;
    }

    /*
    function getObjectsByName (obj, name, idpath )
        var obj is the Scene
        var name is the property, usually 'name'
        idpath the path of an assembly or component
        returns: Array of matching objects
    */
    function getObjectsByName( obj, name, idpath ) {
        var matches = [];
        if ( obj.name === idpath || obj.name.indexOf(idpath + "/") === 0 ) {
            matches.push(obj);
            // Dont go to its children as the meshes also get added
            return matches;
        }
        for ( var i = 0, l = obj.children.length; i < l; i ++ ) {
            var child = obj.children[ i ];
            var childmatches = getObjectsByName( child, name, idpath );
            if ( childmatches !== undefined ) {
                for ( var j=0; j < childmatches.length; j++ ) {
                    matches.push(childmatches[j]);
                }
            }
        }
        return matches;
    }

    // Utility interpolation functions
    function linearInterpolate(start, end, value) {
        return (end - start) * value + start;
    }

    function linearArrayInterpolation(start, end, value) {
        var i;
        var result = [];
        for ( i = 0; i < start.length; i++ ) {
            result[i] = linearInterpolate(start[i], end[i], value);
        }
        return result;
    }

    // Color
    function colorInitialization(start) {
        var i;
        for ( i = 0 ; i < start.object.length; i++ ) {
            start.object[i].material.color.r = start.color[0];
            start.object[i].material.color.g = start.color[1];
            start.object[i].material.color.b = start.color[2];
        }
    }

    function colorInterpolation( start, end, value ) {
        var i;
        var newvalue = linearArrayInterpolation( start.color, end.color, value);
        for ( i = 0; i < start.object.length; i++ ) {
            start.object[i].material.color.r = newvalue[0];
            start.object[i].material.color.g = newvalue[1];
            start.object[i].material.color.b = newvalue[2];
        }
    }

    // Transparency
    function transparencyInitialization(start) {
        var i;
        for ( i = 0 ; i < start.object.length; i++ ) {
            start.object[i].material.transparent = true;
            start.object[i].material.opacity = start.transparency;
        }
    }

    function transparencyInterpolation( start, end, value ) {
        var i;
        var newvalue = linearInterpolate(start.transparency, end.transparency, value);
        for ( i = 0; i < start.object.length; i++ ) {
            start.object[i].material.transparent = true;
            start.object[i].material.opacity = newvalue;
        }
    }

    // Visibility
    function visibilityInitialization(start) {
        transparencyInitialization(start);
    }

    function visibilityInterpolation( start, end, value ) {
        // Can't really interpolate visibility, so we fade it and change visibility state at the end
        transparencyInterpolation( start, end, value );
    }

    //Location
    function locationInitialization(start, end) {
        /* Yes do nothing !! */
    }

    function seqLocationInterpolation( start, end, value ) {

        // Update the quaternion by slerping between start and end quaternion and then applying it to the original quaternion of the object
        // This does not take into account changes in pivot center, but for the moment gets things moving
        if ( !start.quaternion.equals(end.quaternion) ) {
            var q1 = (new THREE.Quaternion()).copy(start.quaternion);
            var newq = q1.slerp(end.quaternion, value);
            if ( start.global ) {
                start.object.quaternion.copy(newq);
            }
            else {
                start.object.quaternion.copy(newq);
            }
        }

        // Interpolate between start & end position and apply to original.
        // not strictly correct, but gets things moving
        if ( start.position !== undefined && start.position.length !== 0 ) {
            start.object.position.x = linearInterpolate(start.position.x, end.position.x, value);
            start.object.position.y = linearInterpolate(start.position.y, end.position.y, value);
            start.object.position.z = linearInterpolate(start.position.z, end.position.z, value);
        }

        if ( end.scale !== undefined ) {
            var scale_interp = linearInterpolate(start.object.scale.x, end.scale, value);
            start.object.scale.x = scale_interp;
            start.object.scale.y = scale_interp;
            start.object.scale.z = scale_interp;
        }
    }

    function locationMoveByInterpolation( start, end, value ) {
        start.object.position.x = start.startPosition.x + linearInterpolate(start.position.x, end.position.x, value);
        start.object.position.y = start.startPosition.y + linearInterpolate(start.position.y, end.position.y, value);
        start.object.position.z = start.startPosition.z + linearInterpolate(start.position.z, end.position.z, value);
    }

    // Camera
    function cameraInitialization(start) {

        var fov;
        if ( start.fov.top == -start.fov.bottom ) {
            fov = (2 * Math.atan(Math.abs(start.fov.top), start.fov.depth))*180/Math.PI;
        }
        else {
            fov = (Math.abs(Math.atan(-start.fov.bottom, start.fov.depth) + Math.atan(start.fov.top, start.fov.depth)))*180/Math.PI;
        }

        // MPH Need to get container to calculate aspect ratio !
        var aspect = container.offsetWidth / container.offsetHeight;

        // Note the object is the camera
        start.object.fov = fov;
        start.object.aspect = aspect;
        start.object.near = 0.125;
        start.object.far = 32;

        start.object.up = new THREE.Vector3( 0, 1, 0 );
        start.object.position.copy(start.position);
        start.object.lookAt(start.center);
        if ( start.event_callback !== null && start.event_callback.type == "onLookAt") {
            // jshint -W040
            // (`this` really is valid in the line below)
            start.event_callback.callback(this, start.center);
            // jshint +W040
        }
        start.object.quaternion.copy(start.quaternion);

        start.object.updateProjectionMatrix();
    }

    function cameraInterpolation( start, end, value ) {

        //FOV
        var top = linearInterpolate(start.fov.top, end.fov.top, value);
        var bottom = linearInterpolate(start.fov.bottom, end.fov.bottom, value);
        var depth = linearInterpolate(start.fov.depth, end.fov.depth, value);
        var fov;
        if ( top == -bottom ) {
            fov = (2 * Math.atan(Math.abs(top), depth))*180/Math.PI;
        }
        else {
            fov = (Math.abs(Math.atan(-bottom, depth) + Math.atan(top, depth)))*180/Math.PI;
        }
        start.object.fov = fov;

        //Quaternion
        if ( !start.quaternion.equals(end.quaternion) ) {
            var q1 = (new THREE.Quaternion()).copy(start.quaternion);
            var newq = q1.slerp(end.quaternion, value);
            start.object.quaternion.copy( newq );
        }

        //Position
        start.object.position.x = linearInterpolate(start.position.x, end.position.x, value);
        start.object.position.y = linearInterpolate(start.position.y, end.position.y, value);
        start.object.position.z = linearInterpolate(start.position.z, end.position.z, value);

        // LookAt
        var lookat = new THREE.Vector3();
        lookat.x = linearInterpolate(start.center.x, end.center.x, value);
        lookat.y = linearInterpolate(start.center.y, end.center.y, value);
        lookat.z = linearInterpolate(start.center.z, end.center.z, value);
        start.object.lookAt( lookat );

        start.object.updateProjectionMatrix();
    }

    /*
    function getPosition(object)
                    var object a mesh or group
                    returns = Vector3 x,y,z of the object
    */
    function getPosition(object) {
        return new THREE.Vector3().copy(object.position);
    }

    /*
    function getQuaternion(object)
                    var object a mesh or group
                    returns = Quaternion (x,y,z,w) of the object
    */
    function getQuaternion(object) {
        return new THREE.Quaternion().copy(object.quaternion);
    }

    /*
    function getScale(object)
                    var object a mesh or group
                    returns = single value of the objects scale (assumes x,y,z are equal)
    */
    function getScale(object) {
        return object.scale.x;
    }

    /*
    function getLocalMatrix(object)
                    var object a mesh or group
                    returns = 4X4 Matrix
    */
    function getLocalMatrix(object) {
        return object.matrix.clone();
    }

    /*
    function getWorldMatrix(object)
                    var object a mesh or group
                    returns = 4X4 Matrix
    */
    function getWorldMatrix(object) {
        return object.matrixWorld.clone();
    }

    /*
    function getOpacity(object)
                    var object a mesh or group
                    returns = opacity (0.0 - 1.0)
    */
    function getOpacity(object) {
        return object.material.opacity;
    }

    /*
    function getColorArray(object)
                    var object a mesh or group
                    returns an Array [r,g,b] where color is 0.0 to 1.0
    */
    function getColorArray(object) {
        return [object.material.color.r, object.material.color.g, object.material.color.b];
    }

    function insertPivot(name, center, position, quaternion) {
        // get the node based on the idpath (name)
        var group = getSelectedObject(name);
        // Get a copy of the location of the group
        var position_orig = getPosition(group);
        var quaternion_orig = getQuaternion(group);
        //Create the pivot node
        var pivot = new THREE.Object3D();
        pivot.name = "PIVOT_" + group.name;
        pivot.visible = true;
        // Add the Pivot to the group part parent and set the location to the center
        group.parent.add(pivot);
        setPosition(pivot, center);
        // Remove the group from its parent
        group.parent.remove(group);
        // Add the group to the pivot and set its location
        pivot.add(group);
        setPosition(group, position);
        setQuaternion(group, quaternion);
    }

    function removePivot(name, position, quaternion) {
        // get the node based on the idpath (name)
        var group = getSelectedObject(name);
        var pivot_node = group.parent;
        // Add the group to the pivots parent
        pivot_node.parent.add(group);
        setPosition(group, position);
        setQuaternion(group, quaternion);
        // Remove the pivot from its parent
        pivot_node = null;
    }

    function setPosition(object, position){
        object.position.x = position.x;
        object.position.y = position.y;
        object.position.z = position.z;
    }

    function setQuaternion(object, quaternion) {
        object.quaternion.x = quaternion.x;
        object.quaternion.y = quaternion.y;
        object.quaternion.z = quaternion.z;
        object.quaternion.w = quaternion.w;
    }


    /*
    function getFlyScalar(object)
                    var object a mesh or group
                    returns a float specifying the distance to fly to/from. Can be any formula
    */
    function getFlyScalar(object) {
        var sphere = new THREE.Box3().setFromObject( object ).getBoundingSphere();
        var scalar = sphere.radius * 5;
        return scalar;
    }

    return {
        colorInterpolation: colorInterpolation,
        colorInitialization: colorInitialization,
        transparencyInterpolation: transparencyInterpolation,
        transparencyInitialization: transparencyInitialization,
        visibilityInterpolation: visibilityInterpolation,
        visibilityInitialization: visibilityInitialization,
        cameraInterpolation: cameraInterpolation,
        cameraInitialization: cameraInitialization,
        seqLocationInterpolation: seqLocationInterpolation,
        locationMoveByInterpolation: locationMoveByInterpolation,
        locationInitialization: locationInitialization,
        getGeometryByPath: getGeometryByPath,
        getSelectedObjects: getSelectedObjects,
        getSelectedObject: getSelectedObject,
        getPosition: getPosition,
        getQuaternion: getQuaternion,
        getScale: getScale,
        getLocalMatrix: getLocalMatrix,
        getWorldMatrix: getWorldMatrix,
        getOpacity: getOpacity,
        getColorArray: getColorArray,
        insertPivot: insertPivot,
        removePivot: removePivot,
        getFlyScalar: getFlyScalar
        //addState: addState,
        //getLatestState: getLatestState
    };
};
