var TW = TW || {};

/**
 * The SubscriptionManager is a lightweight API that allows clients to easily create subscriptions to events on the
 * Thingworx Platform. The SubscriptionManager can optionally use a pre-made Client object, allowing it to coexist with
 * other bound entities, or can create and manage its own client instance internally.
 *
 * Note that when supplying an instance of Client, the client must have been created with the gatewayName and gatewayType
 * parameters specified.  Alternatively, the name to a VirtualThing can be specified and, optionally, the name of an event
 * handler service.  The VirtualThing must already be created and bound to the Client.  If a customized event handler service
 * is used, it is required that the event handler invoke the event handlers registered against the events (this can be
 * retrieved using the getEventListeners() function).
 *
 * When used in a browser, it is recommended to get an application key for the client by making a REST call to the service
 * GetClientApplicationKey against the EntityServices resource entity.
 * @param config - a configuration object defined as follows:
 * {
 *    client: <an instance of TW.SDK.Client>,
 *    thingName: [optional; String: the name of an existing bound VirtualThing on the client that will handle subscriptions],
 *    eventHandlerName: [optional; String: the name of the service to invoke on the VirtualThing when an event is received]
 * }
 * ... or ...
 * {
 *    host: <String: the host to connect to>,
 *    port: <Number: the port>,
 *    ssl: <Boolean: whether to connect over SSL>,
 *    appKey: <String: the application key to authenticate against>
 * }
 */
TW.SubscriptionManager = function(config) {
    var subscriptionDescriptors = [];
    var eventHandlers = {};
    var boundThing = null;
    var bindDelay = false;
    var client = null;
    var genAuthToken = null;
    var gatewayName = "PersistentSession" + uuid.v4();
    var eventHandlerName = "HandleSubscribedEvent";

    TW.SDK.HelperFunctions.validateParameter(config, 'config', 'object');

    /**
     * Validates an event descriptor object such that: it only contains the keys 'sourceType', 'source', 'sourceProperty',
     * and 'eventName'; and each value is a string (except for 'sourceProperty', which may accept a null value).
     * @param eventDescriptor - the event descriptor object to validate
     * @throws if an invalid key is detected, a required key is missing, or a value has an illegal type
     */
    var validateEventDescriptor = function(eventDescriptor) {
        var accepted = ['sourceType', 'source', 'sourceProperty', 'eventName'];
        var diff = _.difference(_.keys(eventDescriptor), accepted);

        if (diff.length > 0) {
            throw "eventDescriptor contains invalid keys: " + diff;
        }

        var missingKeys = _.omit(_.keys(eventDescriptor), accepted);

        if (missingKeys.length > 0) {
            throw "eventDescriptor is missing the required keys: " + missingKeys;
        }

        _.each(eventDescriptor, function(value, key) {
            TW.SDK.HelperFunctions.validateParameter(value, 'eventDescriptor.' + key, 'string', key === 'sourceProperty');
        });
    };

    /**
     * Converts an event descriptor object to an event descriptor string.
     * @param eventDescriptor - an event descriptor object
     * @returns {String} the string representation of the event descriptor
     */
    var convertDescriptorToString = function(eventDescriptor) {
        var result = "";

        if (!eventDescriptor.sourceType) {
            result += "Things:";
        } else {
            result += eventDescriptor.sourceType + ":";
        }

        result += eventDescriptor.source + ":";

        if (eventDescriptor.sourceProperty) {
            result += eventDescriptor.sourceProperty + "." + eventDescriptor.eventName;
        } else {
            result += eventDescriptor.eventName;
        }

        return result;
    };

    var sendSubscribeRequest = function(eventDescriptor, callback) {
        var service = {
            entityName: gatewayName,
            target: "AddDynamicRemoteSubscription",
            parameters: {
                rows: [{
                    thingName: eventDescriptor.source,
                    eventName: eventDescriptor.eventName,
                    propertyName: eventDescriptor.sourceProperty || null,
                    serviceName: eventHandlerName
                }],
                dataShape: {
                    fieldDefinitions: {
                        thingName: {
                            name: "thingName",
                            description: "",
                            ordinal: 0,
                            baseType: "THINGNAME",
                            aspects: {}
                        },
                        eventName: {
                            name: "eventName",
                            description: "",
                            ordinal: 1,
                            baseType: "STRING",
                            aspects: {}
                        },
                        propertyName: {
                            name: "propertyName",
                            description: "",
                            ordinal: 2,
                            baseType: "STRING",
                            aspects: {}
                        },
                        serviceName: {
                            name: "serviceName",
                            description: "",
                            ordinal: 3,
                            baseType: "STRING",
                            aspects: {}
                        }
                    }
                }
            }
        };

        client.invokeService(service, callback);
    };

    var sendUnsubscribeRequest = function(eventDescriptor, callback) {
        var service = {
            entityName: gatewayName,
            target: "RemoveDynamicRemoteSubscription",
            parameters: {
                rows: [{
                    thingName: eventDescriptor.source,
                    eventName: eventDescriptor.eventName,
                    propertyName: eventDescriptor.sourceProperty || null
                }],
                dataShape: {
                    fieldDefinitions: {
                        thingName: {
                            name: "thingName",
                            description: "",
                            ordinal: 0,
                            baseType: "THINGNAME",
                            aspects: {}
                        },
                        eventName: {
                            name: "eventName",
                            description: "",
                            ordinal: 1,
                            baseType: "STRING",
                            aspects: {}
                        },
                        propertyName: {
                            name: "propertyName",
                            description: "",
                            ordinal: 2,
                            baseType: "STRING",
                            aspects: {}
                        },
                        serviceName: {
                            name: "serviceName",
                            description: "",
                            ordinal: 3,
                            baseType: "STRING",
                            aspects: {}
                        }
                    }
                }
            }
        };

        client.invokeService(service, callback);
    };

    var rebind = function() {
        client.bind();
    };

    /**
     * A handler that is triggered whenever an event payload is received. The handler will utilize the handlers lookup
     * table and trigger each registered handler in succession.
     *
     * @param payload - the event payload from the Platform
     */
    var eventCallback = function(payload) {
        var descriptorString = convertDescriptorToString(payload);
        var handlers = eventHandlers[descriptorString].slice();

        _.each(handlers, function(handler) {
            handler(payload);
        });
    };

    /**
     * Automatically called whenever the underlying connection is reestablished.  Iterates through all existing
     * subscriptions and sends new subscription requests to the Platform.  In the event that the server refuses to
     * permit an old subscription from being restored, an exception is thrown.
     */
    var resubscribe = function() {
        _.each(subscriptionDescriptors, function(descriptor) {
            var checkForError = function(error, result) {
                if (error) {
                    throw "Could not restore subscription on " + convertDescriptorToString(descriptor) + ": " +
                    error.response.getResultMessage();
                }
            };

            if (bindDelay) {
                boundThing.on(descriptor.eventName, eventCallback);
            }

            sendSubscribeRequest(descriptor, checkForError);
        });

        bindDelay = false;
    };

    var regenerateToken = function() {
        try {
            genAuthToken(client.setApplicationKey);
        } catch (err) {
            // Ignore errors and allow execution to continue
        }
    };

    // Perform configuration after our internal methods have been defined.
    if (config.client) {
        TW.SDK.HelperFunctions.validateParameter(config.client, 'config.client', 'object');
        TW.SDK.HelperFunctions.validateParameter(config.thingName, 'config.thingName', 'string', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.eventHandlerName, 'config.eventHandlerName', 'string', true, true);

        client = config.client;

        if (config.eventHandlerName) {
            eventHandlerName = config.eventHandlerName;
        }

        if (config.thingName) {
            boundThing = client.getThing(config.thingName);

            if (!boundThing) {
                throw "thingName must refer to a bound VirtualThing on the provided Client instance.";
            }
        }

        client.on("connect", rebind);
        client.on("bind", resubscribe);

        if (!client.isConnected()) {
            client.connect();
        } else {
            resubscribe();
        }
    } else {
        TW.SDK.HelperFunctions.validateParameter(config.host, 'config.host', 'string');
        TW.SDK.HelperFunctions.validateParameter(config.port, 'config.port', 'number');
        TW.SDK.HelperFunctions.validateParameter(config.ssl, 'config.ssl', 'boolean');
        TW.SDK.HelperFunctions.validateParameter(config.gatewayType, 'config.gatewayType', 'string', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.authTokenFunction, 'config.authTokenFunction', 'function', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.appKey, 'config.appKey', 'string', true, true);

        var host = config.host;
        var port = config.port;
        var ssl = config.ssl;
        var type = config.gatewayType || 'SDKGateway';

        if (!config.authTokenFunction && !config.appKey) {
            throw "At least one of appKey or authTokenFunction must be specified.";
        }

        genAuthToken = config.authTokenFunction;

        var callback = function(appKey) {
            client = new TW.SDK.Client({
                host: host,
                port: port,
                ssl: ssl,
                appKey: appKey,
                gatewayName: gatewayName,
                gatewayType: type
            });

            if (genAuthToken) {
                client.on("disconnect", regenerateToken);
            }

            if (!boundThing) {
                boundThing = client.getThing(client.getGatewayName());
            }

            if (!boundThing) {
                throw "Provided Client must be created with gatewayName and gatewayType specified.";
            }

            client.on("connect", rebind);
            client.on("bind", resubscribe);

            if (!client.isConnected()) {
                client.connect();
            } else {
                resubscribe();
            }
        };

        if (genAuthToken) {
            genAuthToken(callback);
            bindDelay = true;
        } else {
            callback(config.appKey);
        }
    }

    return {
        /**
         * Subscribes to an event based on the descriptor object provided. Event handlers should define one parameter
         * which will contain the event payload's InfoTable. Error handlers should define one parameter which will
         * contain the error message as received from the server (either a string, or an object containing the request
         * and response contexts). Success handlers do not need to define any parameters.
         * Subscribing to a non-existent event or entity will result in undefined behavior.
         *
         * @param eventDescriptor - an object describing the event to subscribe to, in the following format:
         * {
         *    sourceType: <String: a value from ThingworxAPIConstants.EntityTypes>,
         *    source: <String: the name of the entity>,
         *    sourceProperty: <String: the name of the property, or null>,
         *    eventName: <String: the name of the event>
         * }
         * @param eventHandler - a function that will be invoked whenever event data from the subscription is received
         * @param successHandler - optional; a function that will be invoked if the subscription was successfully made
         * @param errorHandler - optional; a function that will be invoked if an error occurred
         */
        subscribe: function(eventDescriptor, eventHandler, successHandler, errorHandler) {
            TW.SDK.HelperFunctions.validateParameter(eventDescriptor, 'eventDescriptor', 'object');
            TW.SDK.HelperFunctions.validateParameter(eventHandler, 'eventHandler', 'function');
            TW.SDK.HelperFunctions.validateParameter(successHandler, 'successHandler', 'function', true, true);
            TW.SDK.HelperFunctions.validateParameter(errorHandler, 'errorHandler', 'function', true, true);
            validateEventDescriptor(eventDescriptor);

            // Check if the subscription duplicates an existing one
            var descString = convertDescriptorToString(eventDescriptor);

            if (eventHandlers[descString]) {
                eventHandlers[descString].push(eventHandler);

                if ((typeof successHandler) === 'function') {
                    successHandler();
                }

                return;
            }

            var handler = function(error, result) {
                if (error) {
                    if ((typeof errorHandler) === 'function') {
                        errorHandler(error.response);
                    }
                } else {
                    subscriptionDescriptors.push(eventDescriptor);
                    eventHandlers[descString] = [eventHandler];

                    if ((typeof successHandler) === 'function') {
                        successHandler();
                    }

                    if (boundThing) {
                        boundThing.on(eventDescriptor.eventName, eventCallback);
                    }
                }
            };

            if (client && client.isConnected()) {
                sendSubscribeRequest(eventDescriptor, handler);
            } else {
                handler(null, true); // Let resubscribe() handle sending the request on connect, assume success
            }
        },

        /**
         * Unsubscribes from an event. The event descriptor provided must match the event descriptor that was passed
         * into the subscribe() function (they do not need to be the same instance, however). See the subscribe()
         * documentation for details on the format of the event descriptor. The event handler provided must equal one
         * of the event handlers passed to the subscribe() function previously. Attempting to unsubscribe from an event
         * you are not subscribed to or with an event handler that never had been passed to subscribe() will result in
         * an error.
         *
         * @param eventDescriptor - an event descriptor object
         * @param eventHandler - the event handler that should no longer be invoked
         * @param successHandler - optional; a function that will be invoked if successfully unsubscribed
         * @param errorHandler - optional; a function that will be invoked if an error occurred
         */
        unsubscribe: function(eventDescriptor, eventHandler, successHandler, errorHandler) {
            TW.SDK.HelperFunctions.validateParameter(eventDescriptor, 'eventDescriptor', 'object');
            TW.SDK.HelperFunctions.validateParameter(successHandler, 'successHandler', 'function', true, true);
            TW.SDK.HelperFunctions.validateParameter(errorHandler, 'errorHandler', 'function', true, true);
            validateEventDescriptor(eventDescriptor);

            var descString = convertDescriptorToString(eventDescriptor);

            var handlers = eventHandlers[descString];

            if (_.isUndefined(handlers)) {
                if ((typeof errorHandler) === 'function') {
                    errorHandler('Event has not been subscribed to.');
                }
                return;
            }

            var handlerIndex = handlers.indexOf(eventHandler);

            // In the event the event descriptor was never subscribed to...
            if (handlerIndex === -1) {
                if ((typeof errorHandler) === 'function') {
                    errorHandler('Handler not subscribed to requested event.');
                }
                return;
            }

            handlers.splice(handlerIndex, 1);

            if (handlers.length === 0) {
                var handler = function(error, result) {
                    if (error) {
                        handlers.push(eventHandler);

                        if ((typeof errorHandler) === 'function') {
                            errorHandler(error.response);
                        }
                    } else {
                        delete eventHandlers[descString];

                        var index = _.findIndex(subscriptionDescriptors, function(descriptor) {
                            var allMatched = true;
                            Object.keys(eventDescriptor).forEach(function(akey) {
                                if (descriptor[akey] !== eventDescriptor[akey]) {
                                    allMatched = false;
                                }
                            });
                            return allMatched;
                        });

                        subscriptionDescriptors.splice(index, 1);

                        if ((typeof successHandler) === 'function') {
                            successHandler();
                        }
                    }
                };

                if (client && client.isConnected()) {
                    sendUnsubscribeRequest(eventDescriptor, handler);
                } else {
                    handler(null, true);
                }
            } else {
                if ((typeof successHandler) === 'function') {
                    successHandler();
                }
            }
        },

        /**
         * Returns the Client instance associated to this SubscriptionManager.  Note that modifications to the client could cause the SubscriptionManager to subsequently fail.
         */
        getClient: function() {
            return client;
        }
    };
};