// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.Channel = function(config) {
    var setupUrl = function(ssl, host, port) {
        TW.SDK.HelperFunctions.validateParameter(host, 'config.host', 'string');
        TW.SDK.HelperFunctions.validateParameter(port, 'config.port', 'number');
        TW.SDK.HelperFunctions.validateParameter(ssl, 'config.ssl', 'boolean', true, true);

        if (_.isNull(ssl) || _.isUndefined(ssl)) {
            ssl = true;
        }

        var protocol = ssl ? "wss" : "ws";
        return protocol + "://" + host + ":" + port + "/Thingworx/WS";
    };

    var url = setupUrl(config.ssl, config.host, config.port);
    var reconnect = config.reconnect ? config.reconnect : 5;
    var socket = null;
    var callbacks = {
        open: [],
        close: [],
        message: []
    };
    var waitingRequests = {};
    var successCallbacks = {};
    var failureCallbacks = {};
    var firstSession = null;
    var pingTimeout = 10000;
    var requestID = 0;

    var validateParameter = TW.SDK.HelperFunctions.validateParameter;

    var autoReconnect = function(interval, callback) {
        var afterDelay = function() {
            api.connect(callback);
        };

        setTimeout(afterDelay, interval * 1000);
    };

    var pseudoPing = function() {
        if (firstSession !== null && api.isConnected()) {
            var payload = new TW.SDK.APIContext({
                requestId: -1,
                endpointId: firstSession.endpointID,
                sessionId: firstSession.sessionID,
                contextType: TW.SDK.ContextTypes.GET
            });

            api.send(payload, _.noop, _.noop);
        }

        // TODO: Make ping timeout configurable
        setTimeout(pseudoPing, pingTimeout);
    };

    var triggerEvent = function(event, content) {
        var relevantCallbacks = callbacks[event];

        if (_.isUndefined(relevantCallbacks)) {
            throw 'Cannot trigger invalid event "' + event + '".';
        }

        relevantCallbacks = relevantCallbacks.slice();

        _.each(relevantCallbacks, function(callback) {
            if (content) {
                callback(content);
            } else {
                callback();
            }
        });
    };

    var api = {
        isConnected: function() {
            return socket !== null && socket.readyState === WebSocket.OPEN;
        },

        isClosed: function() {
            return socket === null || socket.readyState === WebSocket.CLOSED;
        },

        connect: function(callback) {
            validateParameter(callback, 'callback', 'function', true, true);

            var called = false;
            var callbackFunction = callback || _.noop;

            var handleOpen = function(event) {
                requestID = 0;

                if (!called) {
                    called = true;
                    callbackFunction(true);
                }

                triggerEvent("open");
            };

            var handleClose = function(event) {
                if (!called) {
                    called = true;
                    callbackFunction(false);
                } else {
                    autoReconnect(reconnect, callback);
                }
                waitingRequests = {};

                triggerEvent("close");
            };

            var handleMessage = function(event) {
                var message = TW.SDK.ContextFactory(event.data);
                var id = message.getRequestId();

                triggerEvent("message", message);

                if (firstSession === null) {
                    if (message.getSessionId() !== -1) {
                        firstSession = {
                            endpointID: message.getEndpointId(),
                            sessionID: message.getSessionId()
                        };
                    }
                }

                if (message.isResponse()) {
                    var request = waitingRequests[id];
                    var callback;

                    if (message.getStatusCode() < 300) {
                        callback = successCallbacks[id];
                        delete waitingRequests[id];
                        delete successCallbacks[id];
                        delete failureCallbacks[id];

                        if (callback) {
                            callback({
                                "request": request,
                                "response": message
                            });
                        }
                    } else {
                        callback = failureCallbacks[id];
                        delete waitingRequests[id];
                        delete successCallbacks[id];
                        delete failureCallbacks[id];

                        if (callback) {
                            callback({
                                "request": request,
                                "response": message
                            });
                        }
                    }
                }
            };

            var handleError = function(event) {
            };

            socket = new WebSocket(url);
            socket.addEventListener('close', handleClose);
            socket.addEventListener('error', handleError);

            socket.binaryType = 'arraybuffer';

            socket.addEventListener('open', handleOpen);
            socket.addEventListener('message', handleMessage);
        },

        send: function(message, success, error) {
            validateParameter(message, 'message', 'object');
            validateParameter(success, 'success', 'function', true, true);
            validateParameter(error, 'error', 'function', true, true);

            var messageID = message.getRequestId();

            if (message.isRequest()) {
                waitingRequests[messageID] = message;
            }

            successCallbacks[messageID] = success;
            failureCallbacks[messageID] = error;

            socket.send(message.toBinary());
        },

        startPseudoPing: function(timeout) {
            if (timeout) {
                pingTimeout = timeout;
            }
            setTimeout(pseudoPing, pingTimeout);
        },

        getURL: function() {
            return url;
        },

        getProtocolContext: function() {
            // TODO: Does this make sense for JS?
        },

        // Effectively serves an identical purpose to the ChannelListener, ChannelListenerAdapter and RequestHandler
        // classes from the Java SDK and simpler from a JavaScript perspective.
        /**
         * Binds a callback function to an event. Valid events are 'open', 'close', and 'message'.
         *
         * @param event - the name of the event to bind against
         * @param callback - the function to be invoked when the event is triggered
         */
        addEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function');

            if (!callbacks[event]) {
                throw 'Cannot add listener to invalid event "' + event + '".';
            }

            callbacks[event].push(callback);
        },

        /**
         * Removes an existing event binding. Valid events are 'open', 'close', and 'message'.
         *
         * @param event - the name of the event to remove the binding from
         * @param callback - the bound function to remove
         */
        removeEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function');

            if (_.isUndefined(callbacks[event])) {
                throw 'Cannot remove listener from invalid event "' + event + '".';
            }

            var idx = callbacks[event].indexOf(callback);

            if (idx > -1) {
                callbacks[event].splice(idx, 1);
            }
        },

        /**
         * If callback is not provided, then returns true if at least one callback has been defined for the specified
         * event. Otherwise, returns true if the provided callback has been bound to the specified event.
         *
         * @param event - the name of the event
         * @param callback - optional; the function to check if it has been bound to the event
         */
        hasEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function', true, true);

            if (!callback) {
                return callbacks[event].length > 0;
            } else {
                return callbacks[event].indexOf(callback) > -1;
            }
        },

        /**
         * Returns the next unused valid request ID.
         */
        getNextRequestID: function() {
            return requestID++;
        }
    };

    return api;
};
