// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.Client = function (config) {
    var host = '';
    var port = '';
    var appKey = '';
    var ssl = true;
    var connected = false;
    var pingTimeout = 10000;
    var gatewayName = '';
    var gatewayType = '';
    var eventListeners = {};
    var channel = null;
    var endpointId = -1;
    var sessionId = -1;
    var boundThings = {};

    if (config) {
        host = config.host;
        port = config.port;
        appKey = config.appKey;
        ssl = config.ssl;
        if (config.pingTimeout) {
            pingTimeout = config.pingTimeout;
        }
        gatewayName = config.gatewayName;
        gatewayType = config.gatewayType;
        if (gatewayName && gatewayType) {
            var gatewayThing = new TW.SDK.VirtualThing({
                name: gatewayName
            });
            boundThings[gatewayName] = gatewayThing;
        }
    }

    var handleRequest = function (message) {
        if (message.isRequest()) {
            var response;

            try {
                if (message.isApiRequest()) {
                    var result = new TW.SDK.Types.InfoTable();
                    var thing = boundThings[message.getEntityName()];
                    if (thing) {
                        switch (message.getCharacteristic()) {
                            case TW.SDK.Characteristics.Properties:
                            {
                                if (message.getContextType() === TW.SDK.ContextTypes.GET) {
                                    result = thing.readProperty({}); // details TBD
                                }
                                break;
                            }
                            case TW.SDK.Characteristics.Services:
                            {
                                if (message.getContextType() === TW.SDK.ContextTypes.POST) {
                                    result = thing.invokeService(message.getTarget(), message.getParameters());
                                }
                                break;
                            }
                        }
                    }
                    response = new TW.SDK.ResponseContext({
                        requestId: message.getRequestId(),
                        endpointId: message.getEndpointId(),
                        sessionId: message.getSessionId(),
                        result: result
                    });
                    channel.send(response, function (data) {
                        // response is OK
                    }, function (error) {
                        // do something
                    });
                }
            } catch (err) {
                response = new TW.SDK.ResponseContext({
                    requestId: message.getRequestId(),
                    endpointId: message.getEndpointId(),
                    sessionId: message.getSessionId(),
                    contextType: TW.SDK.StatusCodes.encode(500),
                    result: TW.SDK.Types.NothingPrimitive.getDefaultValue(),
                    resultType: TW.SDK.BaseTypes.NOTHING,
                    resultMessage: err.toString()
                });
                channel.send(response);
            }
        }
    };

    var api = {
        connect: function () {
            var channelConfig = {
                host: host,
                port: port,
                ssl: ssl
            };
            channel = new TW.SDK.Channel(channelConfig);
            channel.addEventListener('close', function() {
                _.each(eventListeners.disconnect, function(callback) {
                    callback();
                });
            });
            channel.addEventListener('message', handleRequest);
            var onConnect = function (isConnected) {
                if (isConnected) {
                    // send auth message
                    var authConfig = {
                        requestId: channel.getNextRequestID(),
                        securityClaims: {
                            appKey: appKey
                        }
                    };
                    var authContext = new TW.SDK.AuthContext(authConfig);
                    channel.send(authContext, function (result) {
                            endpointId = result.response.getEndpointId();
                            sessionId = result.response.getSessionId();
                            connected = true;
                            channel.startPseudoPing();

                            _.each(eventListeners.connect, function(callback) {
                                callback();
                            });
                        },
                        function (error) {
                            connected = false;
                        });
                }
            };
            channel.connect(onConnect);
        },
        disconnect: function () {
            // calls TwxChannel disconnect
        },
        isConnected: function () {
            return connected;
        },
        bind: function (things) {
            var bindThings = [];
            if (_.isArray(things)) {
                _.each(things, function (value) {
                    bindThings.push(value.getName());
                });
            }
            if (gatewayName) {
                bindThings.push(gatewayName);
            }
            var bindConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                gatewayName: gatewayName,
                gatewayType: gatewayType,
                names: bindThings
            };
            var bindMessage = new TW.SDK.BindContext(bindConfig);
            var bindCallback = eventListeners.bind;
            channel.send(bindMessage, function (response) {
                if (_.isArray(things)) {
                    _.each(things, function (thing) {
                        if (!boundThings[thing.getName()]) {
                            boundThings[thing.getName()] = thing;
                        }
                    });
                }
                if (bindCallback) {
                    _.each(bindCallback.slice(), function(callback) {
                        callback();
                    });
                }
            }, function (error) {
                // do something
            });
        },
        unbind: function (things) {
            // things is an array of VirtualThings, creates TW.SDK.UnbindContext (TBD)
            if (_.isArray(things)) {
                _.each(things, function (thing) {
                    boundThings[thing.getName()] = undefined;
                });
            }
        },
        invokeService: function (serviceConfig, callback) {
            var apiConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                contextType: TW.SDK.ContextTypes.POST,
                entityTypeCode: TW.SDK.EntityTypes.Things,
                entityName: serviceConfig.entityName,
                characteristic: TW.SDK.Characteristics.Services,
                target: serviceConfig.target,
                parameters: serviceConfig.parameters
            };
            var message = new TW.SDK.APIContext(apiConfig);

            channel.send(message, function (data) {
                if (callback) {
                    callback(null, data.response.getResult());
                }
            }, function (error) {
                if (callback) {
                    callback(error, null);
                }
            });
        },
        readProperty: function (propertyConfig, callback) {
            var apiConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                contextType: TW.SDK.ContextTypes.GET,
                entityTypeCode: TW.SDK.EntityTypes.Things,
                entityName: propertyConfig.entityName,
                characteristic: TW.SDK.Characteristics.Properties,
                target: propertyConfig.property
            };

            var message = new TW.SDK.APIContext(apiConfig);

            channel.send(message, function(data) {
                if (callback) {
                    callback(null, data.response.getResult());
                }
            }, function (error) {
                if (callback) {
                    callback(error, null);
                }
            });
        },
        writeProperty: function (propertyConfig) {
            // creates an APIContext from propertyConfig and executes a callback?
            // Do we have a path from here to a bound thing?
        },
        fireEvent: function (eventConfig) {
            // creates an APIContext from eventConfig and executes a callback?
            // Do we have a path from here to a bound thing?
        },
        on: function (event, callback) {
            eventListeners[event] = eventListeners[event] || [];

            eventListeners[event].push(callback);
        },
        getThing: function(thingName) {
            return boundThings[thingName];
        },
        getGatewayName: function() {
            return gatewayName;
        },
        getGatewayType: function() {
            return gatewayType;
        },
        getApplicationKey: function() {
            return appKey;
        },
        setApplicationKey: function(key) {
            TW.SDK.HelperFunctions.validateParameter(key, 'key', 'string');
            appKey = key;
        }
    };

    return api;
};
