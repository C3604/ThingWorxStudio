var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    var bitwise32 = 4294967296; // 2^32

    TW.SDK.Types.LongPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);
            var view = new DataView(data);

            // Since value may be over 32-bits, we can't use bitwise operators since that
            // will cause JavaScript to truncate the upper 32 bits.
            var value = view.getInt32(0);
            value *= bitwise32; // Same as start << 32

            value += view.getUint32(4); // Close equivalent to: start | view.getUint32(4)

            return {
                length: 8,
                content: value
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'number');

            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            var highBits = content / bitwise32;

            // Since we aren't actually doing a byte-shift, we run into an edge case where
            // the final bit is represented by the fractional value.  This can be ignored if
            // the number is positive, but if it's negative we need to take the floor to set
            // the last high bit properly.
            if (highBits < 0) {
                highBits = Math.floor(highBits);
            }

            /*jslint bitwise: true */
            view.setInt32(0, ~~highBits); // Should be negative-safe
            view.setUint32(4, content & 0xFFFFFFFF);
            /*jslint bitwise: false */

            return buffer;
        },

        getDefaultValue: function() {
            return 0;
        }
    };
})();
