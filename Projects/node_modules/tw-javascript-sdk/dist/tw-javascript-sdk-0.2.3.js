// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.HelperFunctions = {
    getType: function(value) {
        if (value === null || value === undefined) {
            return '' + value;
        }

        if (typeof value === 'object' || typeof value === 'function') {
            return ({}).toString.call(value).match(/\[\S+\s(\w+)\]/)[1].toLowerCase();
        } else {
            return typeof value;
        }
    },

    validateParameter: function(parameter, parameterName, expectedType, allowNull, allowUndefined) {
        if (allowNull && _.isNull(parameter)) {
            return;
        }

        if (allowUndefined && _.isUndefined(parameter)) {
            return;
        }

        if ((typeof expectedType) !== 'string') {
            if (parameter instanceof expectedType) {
                return;
            }

            throw 'Parameter ' + parameterName + ' does not implement expected type ' + expectedType + '.';
        }

        var type = TW.SDK.HelperFunctions.getType(parameter);

        if (type !== expectedType) {
            throw 'Expected ' + expectedType + ' for parameter ' + parameterName + ', received ' + type + ' instead.';
        }
    },

    convertByteArrayToBuffer: function(array) {
        this.validateParameter(array, 'array', 'array');
        array = new Int8Array(array);

        var buffer = new ArrayBuffer(array.length);
        var view = new DataView(buffer);

        for (var i = 0; i < array.length; i++) {
            view.setInt8(i, array[i]);
        }

        return buffer;
    },

    convertInt8ToBuffer: function(content) {
        this.validateParameter(content, 'content', 'number');

        var buffer = new ArrayBuffer(1);
        var view = new DataView(buffer);

        view.setInt8(0, content);

        return buffer;
    },

    convertInt16ToBuffer: function(content) {
        this.validateParameter(content, 'content', 'number');

        var buffer = new ArrayBuffer(2);
        var view = new DataView(buffer);

        view.setInt16(0, content);

        return buffer;
    },

    convertInt32ToBuffer: function(content) {
        this.validateParameter(content, 'content', 'number');

        var buffer = new ArrayBuffer(4);
        var view = new DataView(buffer);

        view.setInt32(0, content);

        return buffer;
    },

    combineArrayBuffers: function(buffersArray) {
        this.validateParameter(buffersArray, 'buffersArray', 'array');

        var totalLength = 0;

        for (var i = 0; i < buffersArray.length; i++) {
            totalLength += buffersArray[i].byteLength;
        }

        var combinedBuffer = new ArrayBuffer(totalLength);
        var combinedView = new DataView(combinedBuffer);
        var currentOffset = 0;

        for (i = 0; i < buffersArray.length; i++) {
            var view = new Int8Array(buffersArray[i]);

            for (var j = 0; j < view.byteLength; j++) {
                combinedView.setInt8(currentOffset++, view[j]);
            }
        }

        return combinedBuffer;
    }
};

var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.BaseTypes = {
    NOTHING: -1,
    STRING: 0,
    NUMBER: 1,
    BOOLEAN: 2,
    DATETIME: 3,
    TIMESPAN: 4,
    INFOTABLE: 5,
    LOCATION: 6,
    XML: 7,
    JSON: 8,
    QUERY: 9,
    IMAGE: 10,
    HYPERLINK: 11,
    IMAGELINK: 12,
    PASSWORD: 13,
    HTML: 14,
    TEXT: 15,
    TAGS: 16,
    SCHEDULE: 17,
    VARIANT: 18,
    GUID: 20,
    BLOB: 21,
    INTEGER: 22,
    LONG: 23,
    PROPERTYNAME: 50,
    SERVICENAME: 51,
    EVENTNAME: 52,
    THINGNAME: 100,
    THINGSHAPENAME: 101,
    THINGTEMPLATENAME: 102,
    DATASHAPENAME: 104,
    MASHUPNAME: 105,
    MENUNAME: 106,
    BASETYPENAME: 107,
    USERNAME: 108,
    GROUPNAME: 109,
    CATEGORYNAME: 110,
    STATEDEFINITIONNAME: 111,
    STYLEDEFINITIONNAME: 112,
    MODELTAGVOCABULARYNAME: 113,
    DATATAGVOCABULARYNAME: 114,
    NETWORKNAME: 115,
    MEDIAENTITYNAME: 116,
    APPLICATIONKEYNAME: 117,
    LOCALIZATIONTABLENAME: 118,
    ORGANIZATIONNAME: 119,
    DASHBOARDNAME: 120,
    PERSISTENCEPROVIDERPACKAGENAME: 121,
    PERSISTENCEPROVIDERNAME: 122,
    PROJECTNAME: 123,
    VEC2: 124,
    VEC3: 125,
    VEC4: 126,
    THINGCODE: 127,

    fromCode: function(code) {
        TW.SDK.HelperFunctions.validateParameter(code, 'code', 'number');

        var value = _.findKey(TW.SDK.BaseTypes, function (value) {
            return code === value;
        });

        if (_.isUndefined(value)) {
            throw "Primitive code " + code + " not supported";
        }

        return value;
    },

    infer: function(content) {
        content = content || "";

        if ((typeof content) === 'string') {
            return this.STRING;
        } else if ((typeof content) === 'number') {
            return this.NUMBER;
        } else if ((typeof content) === 'boolean') {
            return this.BOOLEAN;
        } else if ((typeof content) === 'object') {
            if (content instanceof Date) {
                return this.DATETIME;
            } else if (content.dataShape) {
                return this.INFOTABLE;
            } else {
                return this.JSON;
            }
        }
    }
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.BlobPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var view = new DataView(data);
            var length = view.getInt32(0);
            var offset = 4;

            var unsignedView = new Uint8Array(data, offset, length);
            var result = String.fromCharCode.apply(null, unsignedView);

            return {
                length: length + offset,
                content: btoa(result) // Base64-encoded binary
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'string');

            var str = content;

            str = atob(content);
            var size = str.length + 4;
            var offset = 0;

            var buffer = new ArrayBuffer(size);
            var view = new DataView(buffer);

            view.setInt32(offset, str.length);
            offset += 4;

            for (var i = 0; i < str.length; i++) {
                view.setInt8(offset++, str.charCodeAt(i));
            }

            return buffer;
        },

        getDefaultValue: function() {
            return "";
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.BooleanPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var view = new DataView(data);

            return {
                length: 1,
                content: (view.getInt8(0) === 1)
            };
        },

        encode: function(content) {
            return TW.SDK.HelperFunctions.convertInt8ToBuffer(content ? 1 : 0);
        },

        getDefaultValue: function() {
            return false;
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

TW.SDK.Types.DataShape = function (config) {
    var fieldDefinitions = {};
    if (config) {
        if (config.fieldDefinitions) {
            fieldDefinitions = config.fieldDefinitions;
        }
    }
    var api = {
        fieldDefinitions: fieldDefinitions
    };
    return api;
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

TW.SDK.Types.DataShapeHelper = {
    addField: function (datashape, name, description, baseType, aspects) {
        if (datashape && datashape.fieldDefinitions && name) {
            datashape.fieldDefinitions[name] = {
                name: name,
                aspects: aspects ? aspects : {},
                description: description,
                baseType: baseType,
                ordinal: 0
            };
        }
    },
    getField: function (datashape, fieldName) {
        if (datashape && datashape.fieldDefinitions) {
            return datashape.fieldDefinitions[fieldName];
        } else {
            return null;
        }
    }
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.DateTimePrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var timestamp = TW.SDK.Types.LongPrimitive.decode(data);

            return {
                length: 8,
                content: new Date(timestamp.content)
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', Date);

            return TW.SDK.Types.LongPrimitive.encode(content.getTime());
        },

        getDefaultValue: function() {
            return new Date();
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

TW.SDK.Types.InfoTable = function (config) {
    var dataShape = new TW.SDK.Types.DataShape();
    var rows = [];
    if (config) {
        if (config.dataShape) {
            dataShape = config.dataShape;
        }
        if (config.rows) {
            rows = config.rows;
        }
    }
    var api = {
        rows: rows,
        dataShape: dataShape
    };
    return api;
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

TW.SDK.Types.InfoTableHelper = {

    addRow: function (infotable, row) {
        if (row && infotable && infotable.rows) {
            infotable.rows.push(row);
        }
    },
    getRow: function (infotable, rowNum) {
        if (infotable && infotable.rows && (rowNum >= 0) && (rowNum < infotable.rows.length)) {
            return infotable.rows[rowNum];
        } else {
            return null;
        }
    },
    getRowCount: function (infotable) {
        if (infotable && infotable.rows) {
            return infotable.rows.length;
        } else {
            return -1;
        }
    }
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    var decodeAspect = function (data, aspect) {
        var view = new DataView(data);
        var offset = 0;

        var namePrimitive = TW.SDK.Types.StringPrimitive.decode(data);
        var name = namePrimitive.content;
        offset += namePrimitive.length;

        var type = view.getInt8(offset++);

        var valuePrimitive = TW.SDK.Primitives.fromCode(type).decode(data.slice(offset));
        var value = valuePrimitive.content;
        offset += valuePrimitive.length;

        aspect[name] = value;
        return offset;
    };

    var decodeDataShapeField = function (data, dataShape) {
        var view = new DataView(data);
        var offset = 0;

        var namePrimitive = TW.SDK.Types.StringPrimitive.decode(data);
        var name = namePrimitive.content;
        offset += namePrimitive.length;

        var descriptionPrimitive = TW.SDK.Types.StringPrimitive.decode(data.slice(offset));
        var description = descriptionPrimitive.content;
        offset += descriptionPrimitive.length;

        var type = TW.SDK.BaseTypes.fromCode(view.getInt8(offset++));

        var aspectCount = view.getInt16(offset);
        var aspects = {};
        offset += 2;

        for (var i = 0; i < aspectCount; i++) {
            offset += decodeAspect(data.slice(offset), aspects);
        }

        TW.SDK.Types.DataShapeHelper.addField(dataShape, name, description, type, aspects);

        return offset;
    };

    var decodeRow = function (data, fieldDefs, row) {
        var view = new DataView(data);
        var offset = 0;

        var fieldKeys = _.keys(fieldDefs);

        var fieldCount = view.getInt16(offset);
        offset += 2;

        for (var i = 0; i < fieldCount; i++) {
            var type = view.getInt8(offset++);
            var valuePrimitive = TW.SDK.Primitives.fromCode(type).decode(data.slice(offset));
            var value = valuePrimitive.content;
            offset += valuePrimitive.length;

            if (value !== null) {
                row[fieldKeys[i]] = value;
            }
        }

        return offset;
    };

    var encodeDataShapeField = function (fieldDefinition) {
        var buffers = [];

        buffers.push(TW.SDK.Types.StringPrimitive.encode(fieldDefinition.name));
        buffers.push(TW.SDK.Types.StringPrimitive.encode(fieldDefinition.description));
        buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(TW.SDK.BaseTypes[fieldDefinition.baseType]));
        buffers.push(TW.SDK.HelperFunctions.convertInt16ToBuffer(_.size(fieldDefinition.aspects)));

        _.each(fieldDefinition.aspects, function (value, key) {
            var type = TW.SDK.BaseTypes.infer(value);
            buffers.push(TW.SDK.Types.StringPrimitive.encode(key));
            buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(type));
            buffers.push(TW.SDK.Primitives.fromCode(type).encode(value));
        });

        return buffers;
    };

    var encodeRow = function (fieldDefinitions, row) {
        var buffers = [];

        buffers.push(TW.SDK.HelperFunctions.convertInt16ToBuffer(_.size(fieldDefinitions)));

        _.each(fieldDefinitions, function (field) {
            var value = row[field.name];
            var type;
            if (_.isUndefined(value) || _.isNull(value)) {
                type = TW.SDK.BaseTypes.NOTHING;
                buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(type));
                buffers.push(TW.SDK.Primitives.fromCode(type).encode());
            } else {
                type = TW.SDK.BaseTypes[field.baseType];
                buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(type));
                buffers.push(TW.SDK.Primitives.fromCode(type).encode(value));
            }
        });

        return buffers;
    };

    TW.SDK.Types.InfoTablePrimitive = {};

    TW.SDK.Types.InfoTablePrimitive.decodeView = function (view, offset, data) {
        var result = new TW.SDK.Types.InfoTable();
        var datashapeMarker = view.getInt8(offset++);
        while (datashapeMarker === 1) {
            offset += decodeDataShapeField(data.slice(offset), result.dataShape);
            datashapeMarker = view.getInt8(offset++);
        }

        var rowMarker = view.getInt8(offset++);

        while (rowMarker === 1) {
            var row = {};
            offset += decodeRow(data.slice(offset), result.dataShape.fieldDefinitions, row);
            TW.SDK.Types.InfoTableHelper.addRow(result, row);
            rowMarker = view.getInt8(offset++);
        }

        return {offset: offset, result: result};
    };

    TW.SDK.Types.InfoTablePrimitive.decode = function (data) {
        TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

        var view = new DataView(data);
        var offset = 0;
        var infoTable = TW.SDK.Types.InfoTablePrimitive.decodeView(view, offset, data);
        offset = infoTable.offset;
        var result = infoTable.result;

        return {
            content: result,
            length: offset
        };
    };

    TW.SDK.Types.InfoTablePrimitive.encode = function (content) {
        TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

        var buffers = [];

        var fieldDefinitions = content.dataShape.fieldDefinitions;
        var rows = content.rows;
        var sortedFieldDefs = _.sortBy(fieldDefinitions, 'ordinal');

        _.each(sortedFieldDefs, function (fieldDef) {
            buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(1)); // Add Datashape Field marker byte
            buffers.push(encodeDataShapeField(fieldDef));
        });

        buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(0)); // Add Datashape Field marker byte (set to Not Present)

        _.each(rows, function (row) {
            buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(1)); // Add Row marker byte
            buffers.push(encodeRow(sortedFieldDefs, row));
        });

        buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(0)); // Add Row marker byte (set to Not Present)

        buffers = _.flatten(buffers);

        return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
    };

    TW.SDK.Types.InfoTablePrimitive.getDefaultValue = function () {
        return new TW.SDK.Types.InfoTable();
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.IntegerPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var view = new DataView(data);

            return {
                length: 4,
                content: view.getInt32(0)
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'number');

            return TW.SDK.HelperFunctions.convertInt32ToBuffer(content);
        },

        getDefaultValue: function() {
            return 0;
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.JSONPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var decodedString = TW.SDK.Types.StringPrimitive.decode(data);

            return {
                length: decodedString.length,
                content: JSON.parse(decodedString.content)
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var jsonString = JSON.stringify(content);

            return TW.SDK.Types.StringPrimitive.encode(jsonString);
        },

        getDefaultValue: function() {
            return {};
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.LocationPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var longitude = TW.SDK.Types.NumberPrimitive.decode(data.slice(0, 8));
            var latitude = TW.SDK.Types.NumberPrimitive.decode(data.slice(8, 16));
            var elevation = TW.SDK.Types.NumberPrimitive.decode(data.slice(16));

            return {
                length: 24,
                content: {
                    latitude: latitude.content,
                    longitude: longitude.content,
                    elevation: elevation.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.longitude));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.latitude));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.elevation));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                latitude: 0,
                longitude: 0,
                elevation: 0
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    var bitwise32 = 4294967296; // 2^32

    TW.SDK.Types.LongPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);
            var view = new DataView(data);

            // Since value may be over 32-bits, we can't use bitwise operators since that
            // will cause JavaScript to truncate the upper 32 bits.
            var value = view.getInt32(0);
            value *= bitwise32; // Same as start << 32

            value += view.getUint32(4); // Close equivalent to: start | view.getUint32(4)

            return {
                length: 8,
                content: value
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'number');

            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            var highBits = content / bitwise32;

            // Since we aren't actually doing a byte-shift, we run into an edge case where
            // the final bit is represented by the fractional value.  This can be ignored if
            // the number is positive, but if it's negative we need to take the floor to set
            // the last high bit properly.
            if (highBits < 0) {
                highBits = Math.floor(highBits);
            }

            /*jslint bitwise: true */
            view.setInt32(0, ~~highBits); // Should be negative-safe
            view.setUint32(4, content & 0xFFFFFFFF);
            /*jslint bitwise: false */

            return buffer;
        },

        getDefaultValue: function() {
            return 0;
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.NothingPrimitive = {
        encode: function(content) {
            return new ArrayBuffer(0);
        },

        decode: function(data) {
            return {
                length: 0,
                content: null
            };
        },

        getDefaultValue: function() {
            return null;
        }
    };
})();
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.NumberPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var view = new DataView(data);

            return {
                length: 8,
                content: view.getFloat64(0)
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'number');

            var buffer = new ArrayBuffer(8);
            var view = new DataView(buffer);
            view.setFloat64(0, content);

            return buffer;
        },

        getDefaultValue: function() {
            return 0.0;
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};

(function () {
    var BaseTypes = TW.SDK.BaseTypes;

    TW.SDK.Primitives = {
        fromCode: function(code) {
            TW.SDK.HelperFunctions.validateParameter(code, 'code', 'number');

            if (code === BaseTypes.NOTHING) {
                return TW.SDK.Types.NothingPrimitive;
            } else if (code === BaseTypes.STRING || code === BaseTypes.XML ||
                    code === BaseTypes.HYPERLINK || code === BaseTypes.PASSWORD ||
                    code === BaseTypes.HTML || code === BaseTypes.TEXT ||
                    code === BaseTypes.GUID ||
                    (code >= BaseTypes.PROPERTYNAME && code <= BaseTypes.EVENTNAME) ||
                    (code >= BaseTypes.THINGNAME && code <= BaseTypes.PROJECTNAME)) {
                return TW.SDK.Types.StringPrimitive;
            } else if (code === BaseTypes.JSON || code === BaseTypes.QUERY) {
                return TW.SDK.Types.JSONPrimitive;
            } else if (code === BaseTypes.BOOLEAN) {
                return TW.SDK.Types.BooleanPrimitive;
            } else if (code === BaseTypes.NUMBER) {
                return TW.SDK.Types.NumberPrimitive;
            } else if (code === BaseTypes.INTEGER) {
                return TW.SDK.Types.IntegerPrimitive;
            } else if (code === BaseTypes.LONG) {
                return TW.SDK.Types.LongPrimitive;
            } else if (code === BaseTypes.DATETIME) {
                return TW.SDK.Types.DateTimePrimitive;
            } else if (code === BaseTypes.LOCATION) {
                return TW.SDK.Types.LocationPrimitive;
            } else if (code === BaseTypes.BLOB || code === BaseTypes.IMAGE) {
                return TW.SDK.Types.BlobPrimitive;
            } else if (code === BaseTypes.INFOTABLE) {
                return TW.SDK.Types.InfoTablePrimitive;
            } else if (code === BaseTypes.TIMESPAN) {
                return TW.SDK.Types.TimespanPrimitive;
            } else if (code === BaseTypes.TAGS) {
                return TW.SDK.Types.TagCollectionPrimitive;
            } else if (code === BaseTypes.VARIANT) {
                return TW.SDK.Types.VariantPrimitive;
            } else if (code === BaseTypes.VEC2) {
                return TW.SDK.Types.Vec2Primitive;
            } else if (code === BaseTypes.VEC3) {
                return TW.SDK.Types.Vec3Primitive;
            } else if (code === BaseTypes.VEC4) {
                return TW.SDK.Types.Vec4Primitive;
            } else if (code === BaseTypes.THINGCODE) {
                return TW.SDK.Types.ThingCodePrimitive;
            } else {
                var codeName = BaseTypes.fromCode(code);

                if (codeName) {
                    throw "Primitive code " + codeName + " not supported";
                } else {
                    throw "Primitive code ID " + code + " not supported";
                }
            }
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.StringPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var view = new DataView(data);
            var length = view.getInt8(0);
            var offset = 1;

            /*jslint bitwise: true */
            if (length & 0x80) {
                length = view.getUint32(0) - 0x80000000;
                offset = 4;
            }
            /*jslint bitwise: false */

            var unsignedView = new Uint8Array(data, offset, length);
            var result = "";

            result = String.fromCharCode.apply(null, unsignedView);

            return {
                length: length + offset,
                content: decodeURIComponent(escape(result)) // Handle UTF8->UTF16 conversion
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'string');

            var str = content;

            str = unescape(encodeURIComponent(str)); // Convert from UTF16->UTF8
            var length = str.length; // Length should be correct even if non-ASCII characters are used
            var size = length;
            var offset = 0;

            // Determine the number of bytes needed to indicate string length
            if (str.length > 127) {
                size += 4;

                if (length < 0x80000000) {
                    /*jslint bitwise: true */
                    length = length | 0x80000000; // Equivalent to changing the highest bit
                    /*jslint bitwise: false */
                } else {
                    throw "String too long to be encoded, length is " + length;
                }
            } else {
                size += 1;
            }

            var buffer = new ArrayBuffer(size);
            var view = new DataView(buffer);

            if (str.length > 127) {
                view.setInt32(offset, length);
                offset += 4;
            } else {
                view.setInt8(offset++, length);
            }

            for (var i = 0; i < str.length; i++) {
                view.setInt8(offset++, str.charCodeAt(i));
            }

            return buffer;
        },

        getDefaultValue: function() {
            return "";
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.TagCollectionPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var collection = TW.SDK.Types.StringPrimitive.decode(data);

            var tags = collection.content.split(';');
            var result = [];

            _.each(tags, function(tag) {
                var splitTag = tag.split(':');

                result.push({
                    vocabulary: splitTag[0],
                    vocabularyTerm: splitTag[1]
                });
            });

            return {
                length: collection.length,
                content: result
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'array');

            var convertedTags = "";
            var lastTag = _.last(content);

            _.each(content, function(tag) {
                var vocabulary = tag.vocabulary || "";
                var term = tag.vocabularyTerm || "";

                convertedTags += vocabulary + ":" + term;

                if (tag !== lastTag) {
                    convertedTags += ";";
                }
            });

            return TW.SDK.Types.StringPrimitive.encode(convertedTags);
        },

        getDefaultValue: function() {
            return [];
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.ThingCodePrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var domain = TW.SDK.Types.IntegerPrimitive.decode(data.slice(0, 4));
            var instance = TW.SDK.Types.LongPrimitive.decode(data.slice(4));

            return {
                length: 12,
                content: {
                    domainId: domain.content,
                    instanceId: instance.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.IntegerPrimitive.encode(content.domainId));
            buffers.push(TW.SDK.Types.LongPrimitive.encode(content.instanceId));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                domainId: 0,
                instanceId: 0
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.TimespanPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var start = TW.SDK.Types.LongPrimitive.decode(data.slice(0, 8));
            var end = TW.SDK.Types.LongPrimitive.decode(data.slice(8, 16));
            var period = TW.SDK.Types.StringPrimitive.decode(data.slice(16));

            return {
                length: start.length + end.length + period.length,
                content: {
                    start: start.content,
                    end: end.content,
                    period: period.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.LongPrimitive.encode(content.start));
            buffers.push(TW.SDK.Types.LongPrimitive.encode(content.end));
            buffers.push(TW.SDK.Types.StringPrimitive.encode(content.period));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                start: 0,
                end: 0,
                period: "00:00:00:00:01:00"
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.VariantPrimitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);
            var view = new DataView(data);

            var type = view.getInt8(0);
            var value = TW.SDK.Primitives.fromCode(type).decode(data.slice(1));

            return {
                length: value.length + 1,
                content: {
                    baseType: TW.SDK.BaseTypes.fromCode(type),
                    value: value.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            var type = TW.SDK.BaseTypes[content.baseType];
            buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(type));
            buffers.push(TW.SDK.Primitives.fromCode(type).encode(content.value));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                baseType: "STRING",
                value: ""
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.Vec2Primitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var x = TW.SDK.Types.NumberPrimitive.decode(data.slice(0, 8));
            var y = TW.SDK.Types.NumberPrimitive.decode(data.slice(8));

            return {
                length: 16,
                content: {
                    x: x.content,
                    y: y.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.x));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.y));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                x: 0,
                y: 0
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.Vec3Primitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var x = TW.SDK.Types.NumberPrimitive.decode(data.slice(0, 8));
            var y = TW.SDK.Types.NumberPrimitive.decode(data.slice(8, 16));
            var z = TW.SDK.Types.NumberPrimitive.decode(data.slice(16));

            return {
                length: 24,
                content: {
                    x: x.content,
                    y: y.content,
                    z: z.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.x));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.y));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.z));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                x: 0,
                y: 0,
                z: 0
            };
        }
    };
})();

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Types = TW.SDK.Types || {};

(function () {
    TW.SDK.Types.Vec4Primitive = {
        decode: function(data) {
            TW.SDK.HelperFunctions.validateParameter(data, 'data', ArrayBuffer);

            var x = TW.SDK.Types.NumberPrimitive.decode(data.slice(0, 8));
            var y = TW.SDK.Types.NumberPrimitive.decode(data.slice(8, 16));
            var z = TW.SDK.Types.NumberPrimitive.decode(data.slice(16, 24));
            var w = TW.SDK.Types.NumberPrimitive.decode(data.slice(24));

            return {
                length: 32,
                content: {
                    x: x.content,
                    y: y.content,
                    z: z.content,
                    w: w.content
                }
            };
        },

        encode: function(content) {
            TW.SDK.HelperFunctions.validateParameter(content, 'content', 'object');

            var buffers = [];

            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.x));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.y));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.z));
            buffers.push(TW.SDK.Types.NumberPrimitive.encode(content.w));

            _.flatten(buffers);

            return TW.SDK.HelperFunctions.combineArrayBuffers(buffers);
        },

        getDefaultValue: function() {
            return {
                x: 0,
                y: 0,
                z: 0,
                w: 1
            };
        }
    };
})();

// See the Characteristic enum in RESTAPIConstants.java
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.Characteristics = {
    Unknown: -1,
    Custom: 0,
    Properties: 1,
    Services: 2,
    Events: 3,
    PropertiesVTQ: 4
};

// See the Method enum in RESTAPIConstants.java
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.ContextTypes = {
    UNKNOWN: 0,
    GET: 1,
    PUT: 2,
    POST: 3,
    DELETE: 4,
    BINDREQUEST: 10,
    UNBINDREQUEST: 11,
    AUTHREQUEST: 20,
    CLEARAUTHREQUEST: 21,
    RESPONSE: 64
};

// See the ThingworxEntityTypes enum in RelationshipTypes.java
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.EntityTypes = {
    Unknown: -1,
    Things: 10,
    ThingShapes: 11,
    ThingTemplates: 12,
    ThingPackages: 13,
    Networks: 14,
    DataShapes: 15,
    ModelTags: 20,
    DataTags: 21,
    Mashups: 30,
    Widgets: 31,
    StyleDefinitions: 32,
    StateDefinitions: 33,
    Menus: 34,
    MediaEntities: 35,
    LocalizationTables: 36,
    Dashboards: 39,
    Logs: 40,
    Users: 50,
    Groups: 51,
    Organizations: 52,
    ApplicationKeys: 53,
    DirectoryServices: 54,
    Authenticators: 55,
    Resources: 60,
    ScriptFunctionLibraries: 61,
    ExtensionPackages: 70,
    Subsystems: 80,
    PersistenceProviderPackages: 90,
    PersistenceProviders: 100,
    Projects: 110
};

var TW = TW || {};
TW.SDK = TW.SDK || {};

/**
 * BaseContext is the base context object for APIContext, AuthContext, BindContext and ResponseContext.
 * It is not intended to be used as is, but provides common properties and functions for its sub objects.
 * The properties are set via a configuration object sent to the constructor. The configuration object for a BaseContext
 * should have 3 properties: requestId, endpointId and sessionId.
 * Properties _version and _multipart should not be changed. Property _contextType should be set by its sub objects.
 */
TW.SDK.BaseContext = function (config) {
    var version = 1;
    var contextType = TW.SDK.ContextTypes.UNKNOWN;
    var requestId = 0;
    var endpointId = -1;
    var sessionId = -1;
    var multipart = 0;

    if (config) {
        // version and multipart should keep default values
        // contextType set by sub objects
        if (!_.isUndefined(config.requestId)) {
            requestId = config.requestId;
        }
        if (!_.isUndefined(config.endpointId)) {
            endpointId = config.endpointId;
        }
        if (!_.isUndefined(config.sessionId)) {
            sessionId = config.sessionId;
        }
        if (config.contextType) {
            contextType = config.contextType;
        }
    }

    var api = {
        getVersion: function () {
            return version;
        },
        getContextType: function () {
            return contextType;
        },
        getRequestId: function () {
            return requestId;
        },
        getEndpointId: function () {
            return endpointId;
        },
        getSessionId: function () {
            return sessionId;
        },
        isMultipart: function () {
            return multipart;
        },
        getBaseSize: function () {
            // Size of the base portion of any message
            return 15;
        },
        /**
         * Set the BaseContext properties from a DataView message
         * @param {DataView} message
         */
        readBaseContext: function (message) {
            version = message.getInt8(0);
            contextType = message.getInt8(1);
            requestId = message.getInt32(2);
            endpointId = message.getInt32(6);
            sessionId = message.getInt32(10);
            multipart = message.getInt8(14);
        },
        /**
         * Write the BaseContext properties to a DataView message
         * @param {DataView} message
         */
        writeBaseContext: function (message) {
            // Assumes an allocated buffer and DataView passed into it from sub objects
            message.setInt8(0, version);
            message.setInt8(1, contextType);
            message.setInt32(2, requestId);
            message.setInt32(6, endpointId);
            message.setInt32(10, sessionId);
            message.setInt8(14, multipart);
        },
        /**
         * Read a UTF8 string from a DataView message
         * @param message - an object with a DataView buffer and an int offset
         * @returns {string}
         */
        readUtf8: function (message) {
            var buffer = message.buffer;
            var length = buffer.getInt8(message.offset++);
            var result = "";
            for (var i = 0; i < length; i++) {
                var character = String.fromCharCode(buffer.getInt8(message.offset++));
                result += character;
            }
            return result;
        },
        /**
         * Write a UTF8 string to a DataView message
         * @param {string} str - the string to write
         * @param {DataView} message - the message buffer
         * @param {int} offset - the offset in the message to start writing
         * @returns {int} - the new value of the offset
         */
        writeUtf8: function (str, message, offset) {
            message.setInt8(offset++, str.length);
            for (var i = 0; i < str.length; i++) {
                message.setInt8(offset++, str[i].charCodeAt(0));
            }
            return offset;
        },
        fromBinary: function (data) {
            var buffer = new DataView(data);
            this.readBaseContext(buffer);
        },
        toBinary: function () {
            var bufferSize = this.getBaseSize();
            var buffer = new ArrayBuffer(bufferSize);

            var message = new DataView(buffer, 0);
            this.writeBaseContext(message);
            return buffer;
        },
        isApiRequest: function () {
            return (contextType >= TW.SDK.ContextTypes.GET && contextType <= TW.SDK.ContextTypes.DELETE);
        },
        isBindRequest: function () {
            return (contextType === TW.SDK.ContextTypes.BINDREQUEST || contextType === TW.SDK.ContextTypes.UNBINDREQUEST);
        },
        isAuthRequest: function () {
            return contextType === TW.SDK.ContextTypes.AUTHREQUEST;
        },
        isClearAuthRequest: function () {
            return contextType === TW.SDK.ContextTypes.CLEARAUTHREQUEST;
        },
        isRequest: function () {
            return (contextType >= TW.SDK.ContextTypes.GET && contextType <= TW.SDK.ContextTypes.CLEARAUTHREQUEST);
        },
        isResponse: function () {
            return ((contextType !== TW.SDK.ContextTypes.UNKNOWN) && !this.isRequest());
        }
    };

    return api;
};


// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

/**
 * APIContext is a message for API methods: GET, PUT, POST, DELETE.
 * It contains the entity type and name, the characteristic and target.
 * The configuration object for the constructor should contain the properties for a BaseContext
 * and contextType (GET, PUT, POST or DELETE), entityTypeCode, entityName, characteristic and target.
 */
TW.SDK.APIContext = function (config) {
    var entityTypeCode = TW.SDK.EntityTypes.UNKNOWN;
    var entityName = "";
    var characteristic = TW.SDK.Characteristics.UNKNOWN;
    var target = "";
    var headers = {};
    var parameters = new TW.SDK.Types.InfoTable();

    if (config) {
        if (config.entityTypeCode) {
            entityTypeCode = config.entityTypeCode;
        }
        if (config.entityName) {
            entityName = config.entityName;
        }
        if (config.characteristic) {
            characteristic = config.characteristic;
        }
        if (config.target) {
            target = config.target;
        }
        if (config.headers) {
            headers = config.headers;
        }
        if (config.parameters) {
            parameters = config.parameters;
        }
    }

    var api = _.extend({}, new TW.SDK.BaseContext(config), {
        getEntityTypeCode: function () {
            return entityTypeCode;
        },
        getEntityName: function () {
            return entityName;
        },
        getCharacteristic: function () {
            return characteristic;
        },
        getTarget: function () {
            return target;
        },
        getHeaders: function () {
            return headers;
        },
        getParameters: function () {
            return parameters;
        },
        /**
         * Read an APIContext from an ArrayBuffer. It will also read the BaseContext.
         * @param {ArrayBuffer} data
         */
        fromBinary: function (data) {
            var buffer = new DataView(data);
            this.readBaseContext(buffer);
            var offset = this.getBaseSize();
            entityTypeCode = buffer.getInt8(offset++);
            var message = {
                buffer: buffer,
                offset: offset
            };
            entityName = this.readUtf8(message);
            characteristic = buffer.getInt8(message.offset++);
            target = this.readUtf8(message);
            var numHeaders = buffer.getInt8(message.offset++);
            for (var i = 0; i < numHeaders; i++) {
                var key = this.readUtf8(message);
                var value = this.readUtf8(message);
                headers[key] = value;
            }
            var parameterType = buffer.getInt8(message.offset++);
            if (parameterType === TW.SDK.BaseTypes.INFOTABLE) {
                var infoTable = TW.SDK.Types.InfoTablePrimitive.decodeView(buffer, message.offset, data);
                parameters = infoTable.result;
            }
        },
        /**
         * Write the APIContext to an ArrayBuffer. It will write the BaseContext
         * @returns {ArrayBuffer}
         */
        toBinary: function () {
            var bufferSize = this.getBaseSize() + 4;
            bufferSize += entityName.length + 1;
            bufferSize += target.length + 1;
            var numHeaders = _.size(headers);
            _.each(headers, function (value, key) {
                bufferSize += key.length + 1;
                bufferSize += value.length + 1;
            });
            var buffer = new ArrayBuffer(bufferSize);

            var message = new DataView(buffer, 0);
            this.writeBaseContext(message);
            var offset = this.getBaseSize();
            message.setInt8(offset++, entityTypeCode);
            offset = this.writeUtf8(entityName, message, offset);
            message.setInt8(offset++, characteristic);
            offset = this.writeUtf8(target, message, offset);
            message.setInt8(offset++, numHeaders);
            var apiContext = this;
            _.each(headers, function (value, key) {
                offset = apiContext.writeUtf8(key, message, offset);
                offset = apiContext.writeUtf8(value, message, offset);
            });
            message.setInt8(offset++, TW.SDK.BaseTypes.INFOTABLE);
            var parametersBuffer = TW.SDK.Types.InfoTablePrimitive.encode(parameters);
            return TW.SDK.HelperFunctions.combineArrayBuffers([buffer, parametersBuffer]);
        }
    });

    return api;
};

// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

/**
 * AuthContext is a message for Authentication.
 * It contains the security claims for the auth. SecurityClaims could be appKey with the key, or userid and password.
 * The configuration object for the constructor should contain the properties for a BaseContext
 * and a securityClaims object.
 */
TW.SDK.AuthContext = function (config) {
    var securityClaims = {};
    if (config) {
        if (config.securityClaims) {
            securityClaims = config.securityClaims;
        }
    }

    var authConfig = _.extend({
        contextType: TW.SDK.ContextTypes.AUTHREQUEST
    }, config);
    var api = _.extend({}, new TW.SDK.BaseContext(authConfig), {
        getSecurityClaims: function () {
            return securityClaims;
        },
        /**
         * Read an AuthContext from an ArrayBuffer. It will also read the BaseContext.
         * @param {ArrayBuffer} data
         */
        fromBinary: function (data) {
            var buffer = new DataView(data);
            this.readBaseContext(buffer);
            var offset = this.getBaseSize();
            var numClaims = buffer.getInt8(offset++);
            var message = {
                buffer: buffer,
                offset: offset
            };
            for (var i = 0; i < numClaims; i++) {
                var key = this.readUtf8(message);
                var value = this.readUtf8(message);
                securityClaims[key] = value;
            }
        },
        /**
         * Write the AuthContext to an ArrayBuffer. It will write the BaseContext
         * @returns {ArrayBuffer}
         */
        toBinary: function () {
            var bufferSize = this.getBaseSize() + 1;
            var numClaims = _.size(securityClaims);
            _.each(securityClaims, function (value, key) {
                bufferSize += key.length + 1;
                bufferSize += value.length + 1;
            });
            var buffer = new ArrayBuffer(bufferSize);

            var message = new DataView(buffer, 0);
            this.writeBaseContext(message);
            var offset = 15;
            message.setInt8(offset++, numClaims);
            var authContext = this;
            _.each(securityClaims, function (value, key) {
                offset = authContext.writeUtf8(key, message, offset);
                offset = authContext.writeUtf8(value, message, offset);
            });
            return buffer;
        }
    });

    return api;
};

// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

/**
 * BindContext is a message for binding remote Things.
 * It may contain a gateway type and name, and an array of Thing names.
 * The configuration object for the constructor should contain the properties for a BaseContext
 * and a names array, and optionally gatewayName and gatewayType.
 */
TW.SDK.BindContext = function (config) {
    var names = [];
    var gatewayName = '';
    var gatewayType = '';

    if (config) {
        if (config.gatewayName) {
            gatewayName = config.gatewayName;
        }
        if (config.gatewayType) {
            gatewayType = config.gatewayType;
        }
        if (config.names) {
            names = config.names;
        }
    }

    var bindConfig = _.extend({
        contextType: TW.SDK.ContextTypes.BINDREQUEST
    }, config);
    var api = _.extend({}, new TW.SDK.BaseContext(bindConfig), {
        getNames: function () {
            return names;
        },
        getGatewayName: function () {
            return gatewayName;
        },
        getGatewayType: function () {
            return gatewayType;
        },
        /**
         * Read a BindContext from an ArrayBuffer. It will also read the BaseContext.
         * @param {ArrayBuffer} data
         */
        fromBinary: function (data) {
            var buffer = new DataView(data);
            this.readBaseContext(buffer);
            var offset = this.getBaseSize();
            var isGateway = buffer.getInt8(offset++);
            var message = {
                buffer: buffer,
                offset: offset
            };
            if (isGateway) {
                gatewayName = this.readUtf8(message);
                gatewayType = this.readUtf8(message);
            }
            var numNames = buffer.getInt16(message.offset);
            message.offset += 2;
            for (var i = 0; i < numNames; i++) {
                var name = this.readUtf8(message);
                names.push(name);
            }
        },
        /**
         * Write the BindContext to an ArrayBuffer. It will write the BaseContext
         * @returns {ArrayBuffer}
         */
        toBinary: function () {
            var bufferSize = this.getBaseSize() + 3;
            if (gatewayName && gatewayType) {
                bufferSize += gatewayName.length + 1;
                bufferSize += gatewayType.length + 1;
            }
            var numNames = names.length;
            var i;
            for (i = 0; i < numNames; i++) {
                bufferSize += names[i].length + 1;
            }
            var buffer = new ArrayBuffer(bufferSize);

            var message = new DataView(buffer, 0);
            this.writeBaseContext(message);
            var offset = this.getBaseSize();
            if (gatewayName && gatewayType) {
                message.setInt8(offset++, 1);
                offset = this.writeUtf8(gatewayName, message, offset);
                offset = this.writeUtf8(gatewayType, message, offset);
            } else {
                message.setInt8(offset++, 0);
            }
            message.setInt16(offset, numNames);
            offset += 2;
            for (i = 0; i < numNames; i++) {
                offset = this.writeUtf8(names[i], message, offset);
            }
            return buffer;
        }
    });

    return api;
};

// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

/**
 * ResponseContext is a message for a response to an APIContext from the server.
 * It contains an InfoTable result and optional resultMessage.
 * The configuration object for the constructor should contain the properties for a BaseContext
 * and result (an InfoTable) and optional resultMessage.
 */
TW.SDK.ResponseContext = function (config) {
    var result = null;
    var resultMessage = "";
    var resultType = TW.SDK.BaseTypes.NOTHING;

    if (config) {
        if (config.resultMessage) {
            resultMessage = config.resultMessage;
        }
        if (config.result) {
            result = config.result;
        }
        if (config.resultType) {
            resultType = config.resultType;
        }
    }

    var responseConfig = _.extend({
        contextType: TW.SDK.ContextTypes.RESPONSE
    }, config);
    var api = _.extend({}, new TW.SDK.BaseContext(responseConfig), {
        getResult: function () {
            return result;
        },
        getResultType: function () {
            return resultType;
        },
        getResultMessage: function () {
            return resultMessage;
        },
        getStatusCode: function () {
            return TW.SDK.StatusCodes.unencode(this.getContextType());
        },
        /**
         * Read a ResponseContext from an ArrayBuffer. It will also read the BaseContext.
         * @param {ArrayBuffer} data
         */
        fromBinary: function (data) {
            var buffer = new DataView(data);
            this.readBaseContext(buffer);
            var offset = this.getBaseSize();
            var message = TW.SDK.Types.StringPrimitive.decode(data.slice(offset));
            resultMessage = message.content;
            offset += message.length;
            resultType = buffer.getInt8(offset++);
            result = TW.SDK.Primitives.fromCode(resultType).decode(data.slice(offset));
        },
        /**
         * Write the ResponseContext to an ArrayBuffer. It will write the BaseContext
         * @returns {ArrayBuffer}
         */
        toBinary: function () {
            var buffers = [];

            buffers.push(new ArrayBuffer(this.getBaseSize()));
            buffers.push(TW.SDK.Types.StringPrimitive.encode(resultMessage));
            buffers.push(TW.SDK.HelperFunctions.convertInt8ToBuffer(resultType));
            buffers.push(TW.SDK.Primitives.fromCode(resultType).encode(result));

            var buffer = TW.SDK.HelperFunctions.combineArrayBuffers(buffers);

            var view = new DataView(buffer, 0);
            this.writeBaseContext(view);

            return buffer;
        }
    });

    return api;
};

// See the StatusCode enum in RESTAPIConstants.java
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.StatusCodes = (function () {
    // Should be kept in sync with each other -- the whitespace is used to make it visually clear which status code matches which hex code,
    // so we temporarily disable the whitespace enforcement in the codestyle checker.

    // jscs:disable disallowSpacesInsideArrayBrackets
    var apiCodes = [ 200,  201,  202,  204,  304,  400,  401,  403,  404,  405,  406,  408,  409,  500,  501,  503,  504,  505,  701,  703,  704];
    var hexCodes = [0x40, 0x41, 0x42, 0x44, 0x64, 0x80, 0x81, 0x83, 0x84, 0x85, 0x86, 0x88, 0x89, 0xa0, 0xa1, 0xa3, 0xa4, 0xa5, 0xe1, 0xe3, 0xe4];
    // jscs:enable disallowSpacesInsideArrayBrackets

    var validateParameter = TW.SDK.HelperFunctions.validateParameter;

    return {
        unencode: function(code) {
            validateParameter(code, 'code', 'number');

            var index = hexCodes.indexOf(code);

            if (index < 0) {
                throw 'Invalid status code encoding: ' + code;
            }

            return apiCodes[index];
        },

        encode: function(code) {
            validateParameter(code, 'code', 'number');

            var index = apiCodes.indexOf(code);

            if (index < 0) {
                throw 'Status code not supported by transport: ' + code;
            }

            return hexCodes[index];
        }
    };
})();

// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.Channel = function(config) {
    var setupUrl = function(ssl, host, port) {
        TW.SDK.HelperFunctions.validateParameter(host, 'config.host', 'string');
        TW.SDK.HelperFunctions.validateParameter(port, 'config.port', 'number');
        TW.SDK.HelperFunctions.validateParameter(ssl, 'config.ssl', 'boolean', true, true);

        if (_.isNull(ssl) || _.isUndefined(ssl)) {
            ssl = true;
        }

        var protocol = ssl ? "wss" : "ws";
        return protocol + "://" + host + ":" + port + "/Thingworx/WS";
    };

    var url = setupUrl(config.ssl, config.host, config.port);
    var reconnect = config.reconnect ? config.reconnect : 5;
    var socket = null;
    var callbacks = {
        open: [],
        close: [],
        message: []
    };
    var waitingRequests = {};
    var successCallbacks = {};
    var failureCallbacks = {};
    var firstSession = null;
    var pingTimeout = 10000;
    var requestID = 0;

    var validateParameter = TW.SDK.HelperFunctions.validateParameter;

    var autoReconnect = function(interval, callback) {
        var afterDelay = function() {
            api.connect(callback);
        };

        setTimeout(afterDelay, interval * 1000);
    };

    var pseudoPing = function() {
        if (firstSession !== null && api.isConnected()) {
            var payload = new TW.SDK.APIContext({
                requestId: -1,
                endpointId: firstSession.endpointID,
                sessionId: firstSession.sessionID,
                contextType: TW.SDK.ContextTypes.GET
            });

            api.send(payload, _.noop, _.noop);
        }

        // TODO: Make ping timeout configurable
        setTimeout(pseudoPing, pingTimeout);
    };

    var triggerEvent = function(event, content) {
        var relevantCallbacks = callbacks[event];

        if (_.isUndefined(relevantCallbacks)) {
            throw 'Cannot trigger invalid event "' + event + '".';
        }

        relevantCallbacks = relevantCallbacks.slice();

        _.each(relevantCallbacks, function(callback) {
            if (content) {
                callback(content);
            } else {
                callback();
            }
        });
    };

    var api = {
        isConnected: function() {
            return socket !== null && socket.readyState === WebSocket.OPEN;
        },

        isClosed: function() {
            return socket === null || socket.readyState === WebSocket.CLOSED;
        },

        connect: function(callback) {
            validateParameter(callback, 'callback', 'function', true, true);

            var called = false;
            var callbackFunction = callback || _.noop;

            var handleOpen = function(event) {
                requestID = 0;

                if (!called) {
                    called = true;
                    callbackFunction(true);
                }

                triggerEvent("open");
            };

            var handleClose = function(event) {
                if (!called) {
                    called = true;
                    callbackFunction(false);
                } else {
                    autoReconnect(reconnect, callback);
                }
                waitingRequests = {};

                triggerEvent("close");
            };

            var handleMessage = function(event) {
                var message = TW.SDK.ContextFactory(event.data);
                var id = message.getRequestId();

                triggerEvent("message", message);

                if (firstSession === null) {
                    if (message.getSessionId() !== -1) {
                        firstSession = {
                            endpointID: message.getEndpointId(),
                            sessionID: message.getSessionId()
                        };
                    }
                }

                if (message.isResponse()) {
                    var request = waitingRequests[id];
                    var callback;

                    if (message.getStatusCode() < 300) {
                        callback = successCallbacks[id];
                        delete waitingRequests[id];
                        delete successCallbacks[id];
                        delete failureCallbacks[id];

                        if (callback) {
                            callback({
                                "request": request,
                                "response": message
                            });
                        }
                    } else {
                        callback = failureCallbacks[id];
                        delete waitingRequests[id];
                        delete successCallbacks[id];
                        delete failureCallbacks[id];

                        if (callback) {
                            callback({
                                "request": request,
                                "response": message
                            });
                        }
                    }
                }
            };

            var handleError = function(event) {
            };

            socket = new WebSocket(url);
            socket.addEventListener('close', handleClose);
            socket.addEventListener('error', handleError);

            socket.binaryType = 'arraybuffer';

            socket.addEventListener('open', handleOpen);
            socket.addEventListener('message', handleMessage);
        },

        send: function(message, success, error) {
            validateParameter(message, 'message', 'object');
            validateParameter(success, 'success', 'function', true, true);
            validateParameter(error, 'error', 'function', true, true);

            var messageID = message.getRequestId();

            if (message.isRequest()) {
                waitingRequests[messageID] = message;
            }

            successCallbacks[messageID] = success;
            failureCallbacks[messageID] = error;

            socket.send(message.toBinary());
        },

        startPseudoPing: function(timeout) {
            if (timeout) {
                pingTimeout = timeout;
            }
            setTimeout(pseudoPing, pingTimeout);
        },

        getURL: function() {
            return url;
        },

        getProtocolContext: function() {
            // TODO: Does this make sense for JS?
        },

        // Effectively serves an identical purpose to the ChannelListener, ChannelListenerAdapter and RequestHandler
        // classes from the Java SDK and simpler from a JavaScript perspective.
        /**
         * Binds a callback function to an event. Valid events are 'open', 'close', and 'message'.
         *
         * @param event - the name of the event to bind against
         * @param callback - the function to be invoked when the event is triggered
         */
        addEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function');

            if (!callbacks[event]) {
                throw 'Cannot add listener to invalid event "' + event + '".';
            }

            callbacks[event].push(callback);
        },

        /**
         * Removes an existing event binding. Valid events are 'open', 'close', and 'message'.
         *
         * @param event - the name of the event to remove the binding from
         * @param callback - the bound function to remove
         */
        removeEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function');

            if (_.isUndefined(callbacks[event])) {
                throw 'Cannot remove listener from invalid event "' + event + '".';
            }

            var idx = callbacks[event].indexOf(callback);

            if (idx > -1) {
                callbacks[event].splice(idx, 1);
            }
        },

        /**
         * If callback is not provided, then returns true if at least one callback has been defined for the specified
         * event. Otherwise, returns true if the provided callback has been bound to the specified event.
         *
         * @param event - the name of the event
         * @param callback - optional; the function to check if it has been bound to the event
         */
        hasEventListener: function(event, callback) {
            validateParameter(event, 'event', 'string');
            validateParameter(callback, 'callback', 'function', true, true);

            if (!callback) {
                return callbacks[event].length > 0;
            } else {
                return callbacks[event].indexOf(callback) > -1;
            }
        },

        /**
         * Returns the next unused valid request ID.
         */
        getNextRequestID: function() {
            return requestID++;
        }
    };

    return api;
};

// Create namespace to avoid polluting global scope
var TW = TW || {};
TW.SDK = TW.SDK || {};

TW.SDK.Client = function (config) {
    var host = '';
    var port = '';
    var appKey = '';
    var ssl = true;
    var connected = false;
    var pingTimeout = 10000;
    var gatewayName = '';
    var gatewayType = '';
    var eventListeners = {};
    var channel = null;
    var endpointId = -1;
    var sessionId = -1;
    var boundThings = {};

    if (config) {
        host = config.host;
        port = config.port;
        appKey = config.appKey;
        ssl = config.ssl;
        if (config.pingTimeout) {
            pingTimeout = config.pingTimeout;
        }
        gatewayName = config.gatewayName;
        gatewayType = config.gatewayType;
        if (gatewayName && gatewayType) {
            var gatewayThing = new TW.SDK.VirtualThing({
                name: gatewayName
            });
            boundThings[gatewayName] = gatewayThing;
        }
    }

    var handleRequest = function (message) {
        if (message.isRequest()) {
            var response;

            try {
                if (message.isApiRequest()) {
                    var result = new TW.SDK.Types.InfoTable();
                    var thing = boundThings[message.getEntityName()];
                    if (thing) {
                        switch (message.getCharacteristic()) {
                            case TW.SDK.Characteristics.Properties:
                            {
                                if (message.getContextType() === TW.SDK.ContextTypes.GET) {
                                    result = thing.readProperty({}); // details TBD
                                }
                                break;
                            }
                            case TW.SDK.Characteristics.Services:
                            {
                                if (message.getContextType() === TW.SDK.ContextTypes.POST) {
                                    result = thing.invokeService(message.getTarget(), message.getParameters());
                                }
                                break;
                            }
                        }
                    }
                    response = new TW.SDK.ResponseContext({
                        requestId: message.getRequestId(),
                        endpointId: message.getEndpointId(),
                        sessionId: message.getSessionId(),
                        result: result
                    });
                    channel.send(response, function (data) {
                        // response is OK
                    }, function (error) {
                        // do something
                    });
                }
            } catch (err) {
                response = new TW.SDK.ResponseContext({
                    requestId: message.getRequestId(),
                    endpointId: message.getEndpointId(),
                    sessionId: message.getSessionId(),
                    contextType: TW.SDK.StatusCodes.encode(500),
                    result: TW.SDK.Types.NothingPrimitive.getDefaultValue(),
                    resultType: TW.SDK.BaseTypes.NOTHING,
                    resultMessage: err.toString()
                });
                channel.send(response);
            }
        }
    };

    var api = {
        connect: function () {
            var channelConfig = {
                host: host,
                port: port,
                ssl: ssl
            };
            channel = new TW.SDK.Channel(channelConfig);
            channel.addEventListener('close', function() {
                _.each(eventListeners.disconnect, function(callback) {
                    callback();
                });
            });
            channel.addEventListener('message', handleRequest);
            var onConnect = function (isConnected) {
                if (isConnected) {
                    // send auth message
                    var authConfig = {
                        requestId: channel.getNextRequestID(),
                        securityClaims: {
                            appKey: appKey
                        }
                    };
                    var authContext = new TW.SDK.AuthContext(authConfig);
                    channel.send(authContext, function (result) {
                            endpointId = result.response.getEndpointId();
                            sessionId = result.response.getSessionId();
                            connected = true;
                            channel.startPseudoPing();

                            _.each(eventListeners.connect, function(callback) {
                                callback();
                            });
                        },
                        function (error) {
                            connected = false;
                        });
                }
            };
            channel.connect(onConnect);
        },
        disconnect: function () {
            // calls TwxChannel disconnect
        },
        isConnected: function () {
            return connected;
        },
        bind: function (things) {
            var bindThings = [];
            if (_.isArray(things)) {
                _.each(things, function (value) {
                    bindThings.push(value.getName());
                });
            }
            if (gatewayName) {
                bindThings.push(gatewayName);
            }
            var bindConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                gatewayName: gatewayName,
                gatewayType: gatewayType,
                names: bindThings
            };
            var bindMessage = new TW.SDK.BindContext(bindConfig);
            var bindCallback = eventListeners.bind;
            channel.send(bindMessage, function (response) {
                if (_.isArray(things)) {
                    _.each(things, function (thing) {
                        if (!boundThings[thing.getName()]) {
                            boundThings[thing.getName()] = thing;
                        }
                    });
                }
                if (bindCallback) {
                    _.each(bindCallback.slice(), function(callback) {
                        callback();
                    });
                }
            }, function (error) {
                // do something
            });
        },
        unbind: function (things) {
            // things is an array of VirtualThings, creates TW.SDK.UnbindContext (TBD)
            if (_.isArray(things)) {
                _.each(things, function (thing) {
                    boundThings[thing.getName()] = undefined;
                });
            }
        },
        invokeService: function (serviceConfig, callback) {
            var apiConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                contextType: TW.SDK.ContextTypes.POST,
                entityTypeCode: TW.SDK.EntityTypes.Things,
                entityName: serviceConfig.entityName,
                characteristic: TW.SDK.Characteristics.Services,
                target: serviceConfig.target,
                parameters: serviceConfig.parameters
            };
            var message = new TW.SDK.APIContext(apiConfig);

            channel.send(message, function (data) {
                if (callback) {
                    callback(null, data.response.getResult());
                }
            }, function (error) {
                if (callback) {
                    callback(error, null);
                }
            });
        },
        readProperty: function (propertyConfig, callback) {
            var apiConfig = {
                requestId: channel.getNextRequestID(),
                sessionId: sessionId,
                endpointId: endpointId,
                contextType: TW.SDK.ContextTypes.GET,
                entityTypeCode: TW.SDK.EntityTypes.Things,
                entityName: propertyConfig.entityName,
                characteristic: TW.SDK.Characteristics.Properties,
                target: propertyConfig.property
            };

            var message = new TW.SDK.APIContext(apiConfig);

            channel.send(message, function(data) {
                if (callback) {
                    callback(null, data.response.getResult());
                }
            }, function (error) {
                if (callback) {
                    callback(error, null);
                }
            });
        },
        writeProperty: function (propertyConfig) {
            // creates an APIContext from propertyConfig and executes a callback?
            // Do we have a path from here to a bound thing?
        },
        fireEvent: function (eventConfig) {
            // creates an APIContext from eventConfig and executes a callback?
            // Do we have a path from here to a bound thing?
        },
        on: function (event, callback) {
            eventListeners[event] = eventListeners[event] || [];

            eventListeners[event].push(callback);
        },
        getThing: function(thingName) {
            return boundThings[thingName];
        },
        getGatewayName: function() {
            return gatewayName;
        },
        getGatewayType: function() {
            return gatewayType;
        },
        getApplicationKey: function() {
            return appKey;
        },
        setApplicationKey: function(key) {
            TW.SDK.HelperFunctions.validateParameter(key, 'key', 'string');
            appKey = key;
        }
    };

    return api;
};

var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.ContextFactory = function (data) {
    var buffer = new DataView(data);
    var contextType = buffer.getInt8(1);
    var context;
    switch (contextType) {
        case TW.SDK.ContextTypes.RESPONSE:
        {
            context = new TW.SDK.ResponseContext();
            context.fromBinary(data);
            return context;
        }
        case TW.SDK.ContextTypes.AUTHREQUEST:
        {
            context = new TW.SDK.AuthContext();
            context.fromBinary(data);
            return context;
        }
        case TW.SDK.ContextTypes.BINDREQUEST:
        {
            context = new TW.SDK.BindContext();
            context.fromBinary(data);
            return context;
        }
        case TW.SDK.ContextTypes.GET:
        case TW.SDK.ContextTypes.PUT:
        case TW.SDK.ContextTypes.POST:
        case TW.SDK.ContextTypes.DELETE:
        {
            context = new TW.SDK.APIContext();
            context.fromBinary(data);
            return context;
        }
        default:
        {
            // Don't know what it is, just create a BaseContext
            context = new TW.SDK.BaseContext();
            return context;
        }
    }
};
var TW = TW || {};
TW.SDK = TW.SDK || {};
TW.SDK.VirtualThing = function(config) {
    var name = '';
    var eventHandlers = {};

    if (config) {
        name = config.name;
    }

    var api = {
        getName: function() {
            return name;
        },
        addPropertyDefinition: function(propertyDef) {

        },
        addServiceDefinition: function(serviceDef) {

        },
        addEventDefinition: function(eventDef) {

        },
        invokeService: function(serviceName, parameters) {
            if (this[serviceName]) {
                return this[serviceName](parameters.rows[0]);
            }
        },
        readProperty: function(propertyName) {
            // reads a property of the VirtualThing and returns the value
        },
        writeProperty: function(propertyName, value) {
            // sets the value of a property on the Virtual Thing
        },
        fireEvent: function(eventConfig) {
            // executes an event handler for an event
        },
        HandleSubscribedEvent: function(event) {
            if (eventHandlers[event.eventName]) {
                eventHandlers[event.eventName](event);
            }
        },
        on: function(event, callback) {
            eventHandlers[event] = callback;
        },
        getEventListeners: function(eventName) {
            return eventHandlers[eventName];
        }
    };

    return api;
};

var TW = TW || {};

/**
 * The SubscriptionManager is a lightweight API that allows clients to easily create subscriptions to events on the
 * Thingworx Platform. The SubscriptionManager can optionally use a pre-made Client object, allowing it to coexist with
 * other bound entities, or can create and manage its own client instance internally.
 *
 * Note that when supplying an instance of Client, the client must have been created with the gatewayName and gatewayType
 * parameters specified.  Alternatively, the name to a VirtualThing can be specified and, optionally, the name of an event
 * handler service.  The VirtualThing must already be created and bound to the Client.  If a customized event handler service
 * is used, it is required that the event handler invoke the event handlers registered against the events (this can be
 * retrieved using the getEventListeners() function).
 *
 * When used in a browser, it is recommended to get an application key for the client by making a REST call to the service
 * GetClientApplicationKey against the EntityServices resource entity.
 * @param config - a configuration object defined as follows:
 * {
 *    client: <an instance of TW.SDK.Client>,
 *    thingName: [optional; String: the name of an existing bound VirtualThing on the client that will handle subscriptions],
 *    eventHandlerName: [optional; String: the name of the service to invoke on the VirtualThing when an event is received]
 * }
 * ... or ...
 * {
 *    host: <String: the host to connect to>,
 *    port: <Number: the port>,
 *    ssl: <Boolean: whether to connect over SSL>,
 *    appKey: <String: the application key to authenticate against>
 * }
 */
TW.SubscriptionManager = function(config) {
    var subscriptionDescriptors = [];
    var eventHandlers = {};
    var boundThing = null;
    var bindDelay = false;
    var client = null;
    var genAuthToken = null;
    var gatewayName = "PersistentSession" + uuid.v4();
    var eventHandlerName = "HandleSubscribedEvent";

    TW.SDK.HelperFunctions.validateParameter(config, 'config', 'object');

    /**
     * Validates an event descriptor object such that: it only contains the keys 'sourceType', 'source', 'sourceProperty',
     * and 'eventName'; and each value is a string (except for 'sourceProperty', which may accept a null value).
     * @param eventDescriptor - the event descriptor object to validate
     * @throws if an invalid key is detected, a required key is missing, or a value has an illegal type
     */
    var validateEventDescriptor = function(eventDescriptor) {
        var accepted = ['sourceType', 'source', 'sourceProperty', 'eventName'];
        var diff = _.difference(_.keys(eventDescriptor), accepted);

        if (diff.length > 0) {
            throw "eventDescriptor contains invalid keys: " + diff;
        }

        var missingKeys = _.omit(_.keys(eventDescriptor), accepted);

        if (missingKeys.length > 0) {
            throw "eventDescriptor is missing the required keys: " + missingKeys;
        }

        _.each(eventDescriptor, function(value, key) {
            TW.SDK.HelperFunctions.validateParameter(value, 'eventDescriptor.' + key, 'string', key === 'sourceProperty');
        });
    };

    /**
     * Converts an event descriptor object to an event descriptor string.
     * @param eventDescriptor - an event descriptor object
     * @returns {String} the string representation of the event descriptor
     */
    var convertDescriptorToString = function(eventDescriptor) {
        var result = "";

        if (!eventDescriptor.sourceType) {
            result += "Things:";
        } else {
            result += eventDescriptor.sourceType + ":";
        }

        result += eventDescriptor.source + ":";

        if (eventDescriptor.sourceProperty) {
            result += eventDescriptor.sourceProperty + "." + eventDescriptor.eventName;
        } else {
            result += eventDescriptor.eventName;
        }

        return result;
    };

    var sendSubscribeRequest = function(eventDescriptor, callback) {
        var service = {
            entityName: gatewayName,
            target: "AddDynamicRemoteSubscription",
            parameters: {
                rows: [{
                    thingName: eventDescriptor.source,
                    eventName: eventDescriptor.eventName,
                    propertyName: eventDescriptor.sourceProperty || null,
                    serviceName: eventHandlerName
                }],
                dataShape: {
                    fieldDefinitions: {
                        thingName: {
                            name: "thingName",
                            description: "",
                            ordinal: 0,
                            baseType: "THINGNAME",
                            aspects: {}
                        },
                        eventName: {
                            name: "eventName",
                            description: "",
                            ordinal: 1,
                            baseType: "STRING",
                            aspects: {}
                        },
                        propertyName: {
                            name: "propertyName",
                            description: "",
                            ordinal: 2,
                            baseType: "STRING",
                            aspects: {}
                        },
                        serviceName: {
                            name: "serviceName",
                            description: "",
                            ordinal: 3,
                            baseType: "STRING",
                            aspects: {}
                        }
                    }
                }
            }
        };

        client.invokeService(service, callback);
    };

    var sendUnsubscribeRequest = function(eventDescriptor, callback) {
        var service = {
            entityName: gatewayName,
            target: "RemoveDynamicRemoteSubscription",
            parameters: {
                rows: [{
                    thingName: eventDescriptor.source,
                    eventName: eventDescriptor.eventName,
                    propertyName: eventDescriptor.sourceProperty || null
                }],
                dataShape: {
                    fieldDefinitions: {
                        thingName: {
                            name: "thingName",
                            description: "",
                            ordinal: 0,
                            baseType: "THINGNAME",
                            aspects: {}
                        },
                        eventName: {
                            name: "eventName",
                            description: "",
                            ordinal: 1,
                            baseType: "STRING",
                            aspects: {}
                        },
                        propertyName: {
                            name: "propertyName",
                            description: "",
                            ordinal: 2,
                            baseType: "STRING",
                            aspects: {}
                        },
                        serviceName: {
                            name: "serviceName",
                            description: "",
                            ordinal: 3,
                            baseType: "STRING",
                            aspects: {}
                        }
                    }
                }
            }
        };

        client.invokeService(service, callback);
    };

    var rebind = function() {
        client.bind();
    };

    /**
     * A handler that is triggered whenever an event payload is received. The handler will utilize the handlers lookup
     * table and trigger each registered handler in succession.
     *
     * @param payload - the event payload from the Platform
     */
    var eventCallback = function(payload) {
        var descriptorString = convertDescriptorToString(payload);
        var handlers = eventHandlers[descriptorString].slice();

        _.each(handlers, function(handler) {
            handler(payload);
        });
    };

    /**
     * Automatically called whenever the underlying connection is reestablished.  Iterates through all existing
     * subscriptions and sends new subscription requests to the Platform.  In the event that the server refuses to
     * permit an old subscription from being restored, an exception is thrown.
     */
    var resubscribe = function() {
        _.each(subscriptionDescriptors, function(descriptor) {
            var checkForError = function(error, result) {
                if (error) {
                    throw "Could not restore subscription on " + convertDescriptorToString(descriptor) + ": " +
                    error.response.getResultMessage();
                }
            };

            if (bindDelay) {
                boundThing.on(descriptor.eventName, eventCallback);
            }

            sendSubscribeRequest(descriptor, checkForError);
        });

        bindDelay = false;
    };

    var regenerateToken = function() {
        try {
            genAuthToken(client.setApplicationKey);
        } catch (err) {
            // Ignore errors and allow execution to continue
        }
    };

    // Perform configuration after our internal methods have been defined.
    if (config.client) {
        TW.SDK.HelperFunctions.validateParameter(config.client, 'config.client', 'object');
        TW.SDK.HelperFunctions.validateParameter(config.thingName, 'config.thingName', 'string', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.eventHandlerName, 'config.eventHandlerName', 'string', true, true);

        client = config.client;

        if (config.eventHandlerName) {
            eventHandlerName = config.eventHandlerName;
        }

        if (config.thingName) {
            boundThing = client.getThing(config.thingName);

            if (!boundThing) {
                throw "thingName must refer to a bound VirtualThing on the provided Client instance.";
            }
        }

        client.on("connect", rebind);
        client.on("bind", resubscribe);

        if (!client.isConnected()) {
            client.connect();
        } else {
            resubscribe();
        }
    } else {
        TW.SDK.HelperFunctions.validateParameter(config.host, 'config.host', 'string');
        TW.SDK.HelperFunctions.validateParameter(config.port, 'config.port', 'number');
        TW.SDK.HelperFunctions.validateParameter(config.ssl, 'config.ssl', 'boolean');
        TW.SDK.HelperFunctions.validateParameter(config.gatewayType, 'config.gatewayType', 'string', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.authTokenFunction, 'config.authTokenFunction', 'function', true, true);
        TW.SDK.HelperFunctions.validateParameter(config.appKey, 'config.appKey', 'string', true, true);

        var host = config.host;
        var port = config.port;
        var ssl = config.ssl;
        var type = config.gatewayType || 'SDKGateway';

        if (!config.authTokenFunction && !config.appKey) {
            throw "At least one of appKey or authTokenFunction must be specified.";
        }

        genAuthToken = config.authTokenFunction;

        var callback = function(appKey) {
            client = new TW.SDK.Client({
                host: host,
                port: port,
                ssl: ssl,
                appKey: appKey,
                gatewayName: gatewayName,
                gatewayType: type
            });

            if (genAuthToken) {
                client.on("disconnect", regenerateToken);
            }

            if (!boundThing) {
                boundThing = client.getThing(client.getGatewayName());
            }

            if (!boundThing) {
                throw "Provided Client must be created with gatewayName and gatewayType specified.";
            }

            client.on("connect", rebind);
            client.on("bind", resubscribe);

            if (!client.isConnected()) {
                client.connect();
            } else {
                resubscribe();
            }
        };

        if (genAuthToken) {
            genAuthToken(callback);
            bindDelay = true;
        } else {
            callback(config.appKey);
        }
    }

    return {
        /**
         * Subscribes to an event based on the descriptor object provided. Event handlers should define one parameter
         * which will contain the event payload's InfoTable. Error handlers should define one parameter which will
         * contain the error message as received from the server (either a string, or an object containing the request
         * and response contexts). Success handlers do not need to define any parameters.
         * Subscribing to a non-existent event or entity will result in undefined behavior.
         *
         * @param eventDescriptor - an object describing the event to subscribe to, in the following format:
         * {
         *    sourceType: <String: a value from ThingworxAPIConstants.EntityTypes>,
         *    source: <String: the name of the entity>,
         *    sourceProperty: <String: the name of the property, or null>,
         *    eventName: <String: the name of the event>
         * }
         * @param eventHandler - a function that will be invoked whenever event data from the subscription is received
         * @param successHandler - optional; a function that will be invoked if the subscription was successfully made
         * @param errorHandler - optional; a function that will be invoked if an error occurred
         */
        subscribe: function(eventDescriptor, eventHandler, successHandler, errorHandler) {
            TW.SDK.HelperFunctions.validateParameter(eventDescriptor, 'eventDescriptor', 'object');
            TW.SDK.HelperFunctions.validateParameter(eventHandler, 'eventHandler', 'function');
            TW.SDK.HelperFunctions.validateParameter(successHandler, 'successHandler', 'function', true, true);
            TW.SDK.HelperFunctions.validateParameter(errorHandler, 'errorHandler', 'function', true, true);
            validateEventDescriptor(eventDescriptor);

            // Check if the subscription duplicates an existing one
            var descString = convertDescriptorToString(eventDescriptor);

            if (eventHandlers[descString]) {
                eventHandlers[descString].push(eventHandler);

                if ((typeof successHandler) === 'function') {
                    successHandler();
                }

                return;
            }

            var handler = function(error, result) {
                if (error) {
                    if ((typeof errorHandler) === 'function') {
                        errorHandler(error.response);
                    }
                } else {
                    subscriptionDescriptors.push(eventDescriptor);
                    eventHandlers[descString] = [eventHandler];

                    if ((typeof successHandler) === 'function') {
                        successHandler();
                    }

                    if (boundThing) {
                        boundThing.on(eventDescriptor.eventName, eventCallback);
                    }
                }
            };

            if (client && client.isConnected()) {
                sendSubscribeRequest(eventDescriptor, handler);
            } else {
                handler(null, true); // Let resubscribe() handle sending the request on connect, assume success
            }
        },

        /**
         * Unsubscribes from an event. The event descriptor provided must match the event descriptor that was passed
         * into the subscribe() function (they do not need to be the same instance, however). See the subscribe()
         * documentation for details on the format of the event descriptor. The event handler provided must equal one
         * of the event handlers passed to the subscribe() function previously. Attempting to unsubscribe from an event
         * you are not subscribed to or with an event handler that never had been passed to subscribe() will result in
         * an error.
         *
         * @param eventDescriptor - an event descriptor object
         * @param eventHandler - the event handler that should no longer be invoked
         * @param successHandler - optional; a function that will be invoked if successfully unsubscribed
         * @param errorHandler - optional; a function that will be invoked if an error occurred
         */
        unsubscribe: function(eventDescriptor, eventHandler, successHandler, errorHandler) {
            TW.SDK.HelperFunctions.validateParameter(eventDescriptor, 'eventDescriptor', 'object');
            TW.SDK.HelperFunctions.validateParameter(successHandler, 'successHandler', 'function', true, true);
            TW.SDK.HelperFunctions.validateParameter(errorHandler, 'errorHandler', 'function', true, true);
            validateEventDescriptor(eventDescriptor);

            var descString = convertDescriptorToString(eventDescriptor);

            var handlers = eventHandlers[descString];

            if (_.isUndefined(handlers)) {
                if ((typeof errorHandler) === 'function') {
                    errorHandler('Event has not been subscribed to.');
                }
                return;
            }

            var handlerIndex = handlers.indexOf(eventHandler);

            // In the event the event descriptor was never subscribed to...
            if (handlerIndex === -1) {
                if ((typeof errorHandler) === 'function') {
                    errorHandler('Handler not subscribed to requested event.');
                }
                return;
            }

            handlers.splice(handlerIndex, 1);

            if (handlers.length === 0) {
                var handler = function(error, result) {
                    if (error) {
                        handlers.push(eventHandler);

                        if ((typeof errorHandler) === 'function') {
                            errorHandler(error.response);
                        }
                    } else {
                        delete eventHandlers[descString];

                        var index = _.findIndex(subscriptionDescriptors, function(descriptor) {
                            var allMatched = true;
                            Object.keys(eventDescriptor).forEach(function(akey) {
                                if (descriptor[akey] !== eventDescriptor[akey]) {
                                    allMatched = false;
                                }
                            });
                            return allMatched;
                        });

                        subscriptionDescriptors.splice(index, 1);

                        if ((typeof successHandler) === 'function') {
                            successHandler();
                        }
                    }
                };

                if (client && client.isConnected()) {
                    sendUnsubscribeRequest(eventDescriptor, handler);
                } else {
                    handler(null, true);
                }
            } else {
                if ((typeof successHandler) === 'function') {
                    successHandler();
                }
            }
        },

        /**
         * Returns the Client instance associated to this SubscriptionManager.  Note that modifications to the client could cause the SubscriptionManager to subsequently fail.
         */
        getClient: function() {
            return client;
        }
    };
};